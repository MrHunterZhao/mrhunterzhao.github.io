<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[集群架构中的异步回调模型实现]]></title>
    <url>%2Fpost%2F2018%2F05%2F06%2Fasync-callback-model-in-cluster-architecture%2F</url>
    <content type="text"><![CDATA[团队中前些天遇到这样一个问题，比较有意思也比较典型，我给出方案后团队成员实施出来，最终问题得以解决。 一个智能终端连接到Netty服务保持会话，在异步完成某项操作后回调回来需要通过会话通知终端，终端再根据通知做相应业务处理，在部署单节点的情况下是OK的，但是系统整体由于要做HA，部署多节点后就会出现问题: 并不能保证该回调请求一定负载到终端保持会话的节点。 如何解决这个问题？这里跟大家分享一种类似场景的通用解决方案，以下是流程图： 1234567891011121314151617181920212223242526 &lt; Async Callback Model in Cluster Architecture &gt; (D) Broadcast to all nodes +-----------------------------------------------------------------------+ v | + - - - - - - - - - + &apos; Cluster: &apos; &apos; &apos;+--------+ (A) Connect &apos; +---------------+ &apos; (B) Async call +---------------+ (C) Callback +----+| | -------------&gt; &apos; | Server Node A | &apos; ----------------&gt; | | --------------&gt; | || | &apos; +---------------+ &apos; | | | || | &apos; &apos; | | | || | + - - - - - - - - - + | | | || | (E) Notify : | | | || | &lt;................... | | | || | | | | || Client | + - - - - - - - - - + | Remote Server | | MQ || | &apos; &apos; | | | || | &apos; +---------------+ &apos; | | | || | &apos; | Server Node B | &apos; | | | || | &apos; +---------------+ &apos; | | | || | &apos; +---------------+ &apos; | | | || | &apos; | Server Node C | &apos; | | | || | &apos; +---------------+ &apos; | | | || | &apos; &apos; | | | |+--------+ + - - - - - - - - - + +---------------+ +----+ (A) 客户端向Server Node A发起请求并保持会话。 (B) 异步向Remote Server发起请求处理业务。 (C) Remote Server处理完成后回调将消息放入消息队列。 (D) MQ将回调消息以广播形式广播到集群各个节点。 (E) 各节点收到广播消息后，能取到对应客户端会话则处理，否则丢弃消息。 注：本案例中的客户端是以TCP连接至服务端，在HTTP服务中如果处理类似场景可以使用Java8中的CompletableFuture来实现。]]></content>
      <categories>
        <category>架构</category>
      </categories>
      <tags>
        <tag>架构</tag>
        <tag>集群</tag>
        <tag>异步</tag>
        <tag>回调</tag>
        <tag>Netty</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[聊一聊使用多线程处理MQ消息的正确姿势]]></title>
    <url>%2Fpost%2F2018%2F05%2F01%2Fconsume-mq-message-with-multithreading%2F</url>
    <content type="text"><![CDATA[Q：有这样一个场景，MQ的生产者生产消息能力是消费者的数倍。如果不能尽快消费完会导致队列中的消息随着时间的推移会越积越多，而且业务也无任何时效性可言，那么问题来了，在不增加消费节点的前提下如何快速处理完消息以保证吞吐量？ 面对以上问题，有人可能会信心满满地脱口而出：用多线程。OK，我只能说思路没错，那么如何落地呢？ 你可能会说使用JDK的ThreadPoolExecutor或者Executors线程池来处理。具体如何去用？只用线程池就够了吗？有什么坑吗？带着这些疑问，我们分别来深入分析一下看看是否能满足需求。 ThreadPoolExecutor()123456789101112131415161718192021222324252627282930313233private void exec() &#123; /* * 创建线程池 * corePoolSize 10 * maximumPoolSize 10 * queue capacity 10 */ ThreadPoolExecutor threadPoolExecutor = new ThreadPoolExecutor( 10, 10, 60, TimeUnit.SECONDS, new ArrayBlockingQueue&lt;Runnable&gt;(10)); // 提交100个任务 for (int i = 0; i &lt; 100; i++) &#123; threadPoolExecutor.submit(new WorkerThread()); &#125;&#125;/** * 任务线程 */private class WorkerThread implements Runnable &#123; public void run() &#123; System.out.println(new Date() + " " + Thread.currentThread().getName() + " is running..."); try &#123; TimeUnit.SECONDS.sleep(2); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 执行以上程序会抛出错误，原因是因为submit的任务数已经超出了其queue的容量，导致触发了拒绝策略。1Exception in thread &quot;main&quot; java.util.concurrent.RejectedExecutionException: Task java.util.concurrent.FutureTask@4d7e1886 Q: 能不能把有界队列ArrayBlockingQueue的容量尽量设置大一些呢？或者干脆换成无界队列LinkedBlockingQueue？ 由于队列中的消息数量无法提前预测具体数量，所以无法使设置准确默认值。 换成LinkedBlockingQueue虽然不会抛出以上错误，但这里会有一个问题：N多待处理任务临时放在JVM中，一方面占用大量内存，另一方面如果服务重启就会导致大量任务丢失。 既然无法从queue容量上去解决，那能否从线程池的拒绝策略着手？ JDK线程池有四种拒绝策略AbortPolicy、CallerRunsPolicy、 DiscardOledestPolicy、DiscardPolicy，默认使用AbortPolicy直接抛出异常。 其中AbortPolicy，DiscardOledestPolicy、DiscardPolicy均会直接丢弃任务肯定不符合预期，CallerRunsPolicy是将该任务抛给主线程执行，这里也会有一个问题，主线程在执行任务时是无法向线程池中提交任务的，假如主线程执行该任务需要3秒，在执行至第1秒的时候，线程池中已经有若干工作线程处于闲置状态，此时主线程需要执行完剩余的2秒才能继续向线程池工作线程分配任务，使用该拒绝策略虽然不会导致消息丢失，但也不能达到资源最优利用，所以pass。 所以，问题解决方案基本浮出水面， 主线程只负责分配任务，Worker线程只负责执行任务。 Worker线程执行完成后第一时间通知主线程，然后主线程及时分配任务。 这里，我们引入Semaphore作为令牌桶，以达到主线程和工作线程间通信的目的。 初始化与Worker线程数量相同的令牌 主线程向线程池提交任务时先尝试从令牌桶获取一个令牌，如果令牌桶为空则block。 把令牌传入Worker线程，Worker线程执行完后调用release()归还令牌。 最终代码参见以下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051/* 初始化与Worker线程数量相同的令牌 */private Semaphore permits = new Semaphore(10);private void exec() throws InterruptedException &#123; /* * 创建线程池 * corePoolSize 10 * maximumPoolSize 10 * queue capacity 10 */ ThreadPoolExecutor threadPoolExecutor = new ThreadPoolExecutor( 10, 10, 60, TimeUnit.SECONDS, new ArrayBlockingQueue&lt;Runnable&gt;(10)); for (int i = 0; i &lt; 100; i++) &#123; // 获取令牌，如果获取不到则block，直到有worker线程归还 permits.acquire(); // 提交任务 threadPoolExecutor.submit(new WorkerThread(permits)); &#125;&#125;/** * 任务线程 */private class WorkerThread implements Runnable &#123; private Semaphore permits; public WorkerThread(Semaphore permits) &#123; this.permits = permits; &#125; public void run() &#123; System.out.println(new Date() + " " + Thread.currentThread().getName() + " is running..."); try &#123; TimeUnit.SECONDS.sleep(2); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; finally &#123; if (permits != null) &#123; // 释放令牌 permits.release(); &#125; &#125; &#125;&#125;]]></content>
      <categories>
        <category>多线程</category>
      </categories>
      <tags>
        <tag>多线程</tag>
        <tag>MQ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【JVM源码探秘】HotSpot启动流程分析-初始化]]></title>
    <url>%2Fpost%2F2018%2F04%2F30%2Fanalysis-of-hotspot-jvm-startup-process-initialization%2F</url>
    <content type="text"><![CDATA[接上篇，HotSpot在启动流程完成了参数的解析、JNI入口的定位、环境变量的设置等一系列操作， 最终在JavaMain()中调用了InitializeJVM()方法，用于完成虚拟机所需的内存申请、挂载和初始化，本文我们就一起一探究竟。 java.c # InitializeJVM()123456789101112131415161718192021222324252627282930313233/* * Initializes the Java Virtual Machine. Also frees options array when * finished. */static jbooleanInitializeJVM(JavaVM **pvm, JNIEnv **penv, InvocationFunctions *ifn)&#123; JavaVMInitArgs args; jint r; memset(&amp;args, 0, sizeof(args)); args.version = JNI_VERSION_1_2; args.nOptions = numOptions; args.options = options; args.ignoreUnrecognized = JNI_FALSE; if (JLI_IsTraceLauncher()) &#123; int i = 0; printf("JavaVM args:\n "); printf("version 0x%08lx, ", (long)args.version); printf("ignoreUnrecognized is %s, ", args.ignoreUnrecognized ? "JNI_TRUE" : "JNI_FALSE"); printf("nOptions is %ld\n", (long)args.nOptions); for (i = 0; i &lt; numOptions; i++) printf(" option[%2d] = '%s'\n", i, args.options[i].optionString); &#125; // 调用JNI_CreateJavaVM方法 r = ifn-&gt;CreateJavaVM(pvm, (void **)penv, &amp;args); JLI_MemFree(options); return r == JNI_OK;&#125; jni.cpp # JNI_CreateJavaVM()此处调用了之前加载的JNI_CreateJavaVM方法，位于src/hotspot/share/prims/jni.cpp 1234567891011121314_JNI_IMPORT_OR_EXPORT_ jint JNICALL JNI_CreateJavaVM(JavaVM **vm, void **penv, void *args) &#123; jint result = JNI_ERR; // On Windows, let CreateJavaVM run with SEH protection#ifdef _WIN32 __try &#123;#endif result = JNI_CreateJavaVM_inner(vm, penv, args);#ifdef _WIN32 &#125; __except(topLevelExceptionFilter((_EXCEPTION_POINTERS*)_exception_info())) &#123; // Nothing to do. &#125;#endif return result;&#125; jni.cpp # JNI_CreateJavaVM_inner()JNI_CreateJavaVM()调用了内部方法JNI_CreateJavaVM_inner() 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455static jint JNI_CreateJavaVM_inner(JavaVM **vm, void **penv, void *args) &#123; HOTSPOT_JNI_CREATEJAVAVM_ENTRY((void **) vm, penv, args); /** * Certain errors during initialization are recoverable and do not * prevent this method from being called again at a later time * (perhaps with different arguments). However, at a certain * point during initialization if an error occurs we cannot allow * this function to be called again (or it will crash). In those * situations, the 'canTryAgain' flag is set to false, which atomically * sets safe_to_recreate_vm to 1, such that any new call to * JNI_CreateJavaVM will immediately fail using the above logic. */ bool can_try_again = true; // ================================= // 创建虚拟机 // ================================= result = Threads::create_vm((JavaVMInitArgs*) args, &amp;can_try_again); // 如果创建成功 if (result == JNI_OK) &#123; JavaThread *thread = JavaThread::current(); assert(!thread-&gt;has_pending_exception(), "should have returned not OK"); /* thread is thread_in_vm here */ *vm = (JavaVM *)(&amp;main_vm); *(JNIEnv**)penv = thread-&gt;jni_environment(); // Tracks the time application was running before GC RuntimeService::record_application_start(); // Notify JVMTI if (JvmtiExport::should_post_thread_life()) &#123; JvmtiExport::post_thread_start(thread); &#125; EventThreadStart event; if (event.should_commit()) &#123; event.set_thread(THREAD_TRACE_ID(thread)); event.commit(); &#125; // Since this is not a JVM_ENTRY we have to set the thread state manually before leaving. ThreadStateTransition::transition_and_fence(thread, _thread_in_vm, _thread_in_native); &#125; // 如果未创建成功 else &#123; .... &#125; return result;&#125; thread.cpp # Threads::create_vm()Threads::create_vm()方法位于src/hotspot/share/runtime/thread.cpp中 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216jint Threads::create_vm(JavaVMInitArgs* args, bool* canTryAgain) &#123; extern void JDK_Version_init(); // 版本信息初始化 VM_Version::early_initialize(); // 检查JNI版本 if (!is_supported_jni_version(args-&gt;version)) return JNI_EVERSION; // 初始化TLS // Initialize library-based TLS ThreadLocalStorage::init(); // 初始化系统输出流模块 // Initialize the output stream module ostream_init(); // 处理Java启动参数，如-Dsun.java.launcher* // Process java launcher properties. Arguments::process_sun_java_launcher_properties(args); // 初始化操作系统模块，如页大小，处理器数量，系统时钟等 // Initialize the os module os::init(); // 启动VM创建计时器 // Record VM creation timing statistics TraceVmCreationTime create_vm_timer; create_vm_timer.start(); // 初始化系统属性，其中分为【可读属性】和【可读写属性】 // 可读属性： // java.vm.specification.name // java.vm.version // java.vm.name // java.vm.info // 可读写属性： // java.ext.dirs // java.endorsed.dirs // sun.boot.library.path // java.library.path // java.home // sun.boot.class.path // java.class.path // Initialize system properties. Arguments::init_system_properties(); // JDK版本初始化 // So that JDK version can be used as a discriminator when parsing arguments JDK_Version_init(); // 设置java.vm.specification.vendor // java.vm.specification.version和java.vm.vendor属性 // Update/Initialize System properties after JDK version number is known Arguments::init_version_specific_system_properties(); // 初始化日志配置 // Make sure to initialize log configuration *before* parsing arguments LogConfiguration::initialize(create_vm_timer.begin_time()); // 解析启动参数，如-XX:Flags=、-XX:+PrintVMOptions、-XX:+PrintFlagsInitial etc. // Parse arguments jint parse_result = Arguments::parse(args); if (parse_result != JNI_OK) return parse_result; os::init_before_ergo(); // 初始化GC日志输出流，用来处理-Xloggc参数 // Initialize output stream logging ostream_init_log(); // Convert -Xrun to -agentlib: if there is no JVM_OnLoad // Must be before create_vm_init_agents() if (Arguments::init_libraries_at_startup()) &#123; convert_vm_init_libraries_to_agents(); &#125; // 初始化agent // Launch -agentlib/-agentpath and converted -Xrun agents if (Arguments::init_agents_at_startup()) &#123; create_vm_init_agents(); &#125; // Initialize Threads state _thread_list = NULL; _number_of_threads = 0; _number_of_non_daemon_threads = 0; /* * ======================================== * 初始化VM全局数据结构及系统类 * ======================================== * 初始化Java基础类型 * 初始化对象OOP大小 * 初始化锁 * 初始化chunkpool * 初始化性能数据统计模块 * ======================================== */ // Initialize global data structures and create system classes in heap vm_init_globals(); // 初始化Java级别的对象同步器子系统 // Initialize Java-Level synchronization subsystem ObjectMonitor::Initialize(); /* * 初始化全局模块 * ======================================== * 1. 初始化management模块 * 2. 初始化字节码/操作符表 * 3. 初始化ClassLoader * 4. 根据命令行参数决定编译策略 * 5. 代码缓存初始化 * 6. 虚拟机版本初始化 * 7. OS全局初始化 * .... * * ======================================== */ jint status = init_globals(); if (status != JNI_OK) &#123; delete main_thread; *canTryAgain = false; // don't let caller call JNI_CreateJavaVM again return status; &#125; if (TRACE_INITIALIZE() != JNI_OK) &#123; vm_exit_during_initialization("Failed to initialize tracing backend"); &#125; // Should be done after the heap is fully created main_thread-&gt;cache_global_variables(); HandleMark hm; &#123; MutexLocker mu(Threads_lock); Threads::add(main_thread); &#125; Thread* THREAD = Thread::current(); // Always call even when there are not JVMTI environments yet, since environments // may be attached late and JVMTI must track phases of VM execution JvmtiExport::enter_early_start_phase(); // Notify JVMTI agents that VM has started (JNI is up) - nop if no agents. JvmtiExport::post_early_vm_start(); // 初始化Java的lang包 initialize_java_lang_classes(main_thread, CHECK_JNI_ERR); // We need this for ClassDataSharing - the initial vm.info property is set // with the default value of CDS "sharing" which may be reset through // command line options. reset_vm_info_property(CHECK_JNI_ERR); quicken_jni_functions(); // No more stub generation allowed after that point. StubCodeDesc::freeze(); // Set flag that basic initialization has completed. Used by exceptions and various // debug stuff, that does not work until all basic classes have been initialized. set_init_completed(); LogConfiguration::post_initialize(); Metaspace::post_initialize(); HOTSPOT_VM_INIT_END(); // record VM initialization completion time#if INCLUDE_MANAGEMENT Management::record_vm_init_completed();#endif // INCLUDE_MANAGEMENT // 启动一个叫做“信号分发器”的线程用来处理进程间的信号 // 比如通过jstack获取一个jvm实例的栈信息 // Signal Dispatcher needs to be started before VMInit event is posted os::signal_init(CHECK_JNI_ERR); // Start Attach Listener if +StartAttachListener or it can't be started lazily if (!DisableAttachMechanism) &#123; AttachListener::vm_start(); if (StartAttachListener || AttachListener::init_at_startup()) &#123; AttachListener::init(); &#125; &#125; // Launch -Xrun agents // Must be done in the JVMTI live phase so that for backward compatibility the JDWP // back-end can launch with -Xdebug -Xrunjdwp. if (!EagerXrunInit &amp;&amp; Arguments::init_libraries_at_startup()) &#123; create_vm_init_libraries(); &#125; // 通知JVMTI agents虚拟机初始化开始 // Notify JVMTI agents that VM has started (JNI is up) - nop if no agents. JvmtiExport::post_vm_start(); // Final system initialization including security manager and system class loader call_initPhase3(CHECK_JNI_ERR); // cache the system class loader SystemDictionary::compute_java_system_loader(CHECK_(JNI_ERR)); if (MemProfiling) MemProfiler::engage(); StatSampler::engage(); if (CheckJNICalls) JniPeriodicChecker::engage(); // 初始化偏向锁 BiasedLocking::init(); return JNI_OK;&#125; init.cpp # init_globals()init_globals()方法用于初始化虚拟机全局模块，位于调用了src/hotspot/share/runtime/init.cpp 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174jint init_globals() &#123; HandleMark hm; // 初始化各子系统的监控及管理服务 // JMX、线程和同步子系统、类加载子系统的监控和管理 management_init(); // 初始化字节码表，如istore、iload、iadd bytecodes_init(); // 类加载器初始化 classLoader_init1(); // 初始化编译策略（根据启动参数决定编译策略） compilationPolicy_init(); // 代码缓存池初始化 codeCache_init(); // 虚拟机版本初始化 VM_Version_init(); // OS全局初始化 os_init_globals(); stubRoutines_init1(); // ============================ // 初始化堆以及决定所使用GC策略 // ============================ jint status = universe_init(); // dependent on codeCache_init and // stubRoutines_init1 and metaspace_init. if (status != JNI_OK) return status; // 初始化解析器 interpreter_init(); // before any methods loaded // 初始化动作触发器 invocationCounter_init(); // before any methods loaded // 初始化MarkSweep marksweep_init(); // 初始化访问标识 accessFlags_init(); // 初始化操作码模板表 templateTable_init(); // 接口支持提供了VM_LEAF_BASE和VM_ENTRY_BASE宏 InterfaceSupport_init(); SharedRuntime::generate_stubs(); // 初始化语法表及系统字典等 universe2_init(); // dependent on codeCache_init and stubRoutines_init1 // 初始化软引用时间戳表并设定软引用清除策略 referenceProcessor_init(); jni_handles_init();#if INCLUDE_VM_STRUCTS // 代码数据结构的必要性检查（仅限debug版本） vmStructs_init();#endif // INCLUDE_VM_STRUCTS vtableStubs_init(); InlineCacheBuffer_init(); // oracle编译器初始化（oracle编译器是一个编译器开关接口） compilerOracle_init(); dependencyContext_init(); if (!compileBroker_init()) &#123; return JNI_EINVAL; &#125; VMRegImpl::set_regName(); // 执行初始化 if (!universe_post_init()) &#123; return JNI_ERR; &#125; javaClasses_init(); // must happen after vtable initialization stubRoutines_init2(); // note: StubRoutines need 2-phase init MethodHandles::generate_adapters();#if INCLUDE_NMT // Solaris stack is walkable only after stubRoutines are set up. // On Other platforms, the stack is always walkable. NMT_stack_walkable = true;#endif // INCLUDE_NMT // All the flags that get adjusted by VM_Version_init and os::init_2 // have been set so dump the flags now. if (PrintFlagsFinal || PrintFlagsRanges) &#123; CommandLineFlags::printFlags(tty, false, PrintFlagsRanges); &#125; return JNI_OK;&#125;``` # universe.cpp # universe_init()`universe_init()`方法初始化堆以及决定所使用GC策略，位于`src/hotspot/share/memory/universe.cpp````cjint universe_init() &#123; assert(!Universe::_fully_initialized, "called after initialize_vtables"); guarantee(1 &lt;&lt; LogHeapWordSize == sizeof(HeapWord), "LogHeapWordSize is incorrect."); guarantee(sizeof(oop) &gt;= sizeof(HeapWord), "HeapWord larger than oop?"); guarantee(sizeof(oop) % sizeof(HeapWord) == 0, "oop size is not not a multiple of HeapWord size"); TraceTime timer("Genesis", TRACETIME_LOG(Info, startuptime)); JavaClasses::compute_hard_coded_offsets(); /* * ============================================================== * 初始化堆空间 * ============================================================== * 在JDK7以前的版本中默认使用CMS收集器，这里会创建及初始化各分区代，设定空间比例大小，回收策略等 * 流程：根据启动参数决定使用的回收策略，初始化回收策略时会指定所使用的代规范， * 最后根据规范创建对应类型的回收堆。 * i.e. arguments -&gt; policy -&gt; spec -&gt; heap * * 在最新的JDK10中默认使用G1作为默认收集器，在JEP248里就提议，参见http://openjdk.java.net/jeps/248， * 虽然也采用分代算法，但由连续内存的年轻（老）代改为非连续的小块region（单个region连续） * ============================================================== */ jint status = Universe::initialize_heap(); if (status != JNI_OK) &#123; return status; &#125; // 初始化元数据空间 // 在JDK8里移除了PermGen，就是加入了它 Metaspace::global_initialize(); // 初始化AOT loader AOTLoader::universe_init(); // Checks 'AfterMemoryInit' constraints. if (!CommandLineFlagConstraintList::check_constraints(CommandLineFlagConstraint::AfterMemoryInit)) &#123; return JNI_EINVAL; &#125; // 为元数据申请内存空间 // Create memory for metadata. Must be after initializing heap for // DumpSharedSpaces. ClassLoaderData::init_null_class_loader_data(); // We have a heap so create the Method* caches before // Metaspace::initialize_shared_spaces() tries to populate them. Universe::_finalizer_register_cache = new LatestMethodCache(); Universe::_loader_addClass_cache = new LatestMethodCache(); Universe::_pd_implies_cache = new LatestMethodCache(); Universe::_throw_illegal_access_error_cache = new LatestMethodCache(); Universe::_do_stack_walk_cache = new LatestMethodCache();#if INCLUDE_CDS if (UseSharedSpaces) &#123; // Read the data structures supporting the shared spaces (shared // system dictionary, symbol table, etc.). After that, access to // the file (other than the mapped regions) is no longer needed, and // the file is closed. Closing the file does not affect the // currently mapped regions. MetaspaceShared::initialize_shared_spaces(); StringTable::create_table(); &#125; else#endif &#123; // 创建符号表 SymbolTable::create_table(); // 创建字符串缓存池 StringTable::create_table();#if INCLUDE_CDS if (DumpSharedSpaces) &#123; MetaspaceShared::prepare_for_dumping(); &#125;#endif &#125; if (strlen(VerifySubSet) &gt; 0) &#123; Universe::initialize_verify_flags(); &#125; // 创建方法表 ResolvedMethodTable::create_table(); return JNI_OK;&#125; universe.cpp # initialize_heap()initialize_heap()方法用于初始化堆空间，位于src/hotspot/share/memory/universe.cpp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384// Choose the heap base address and oop encoding mode// when compressed oops are used:// Unscaled - Use 32-bits oops without encoding when// NarrowOopHeapBaseMin + heap_size &lt; 4Gb// ZeroBased - Use zero based compressed oops with encoding when// NarrowOopHeapBaseMin + heap_size &lt; 32Gb// HeapBased - Use compressed oops with heap base + encoding.jint Universe::initialize_heap() &#123; jint status = JNI_ERR; // 根据GC策略创建堆空间 _collectedHeap = create_heap_ext(); if (_collectedHeap == NULL) &#123; _collectedHeap = create_heap(); &#125; /* * ========================================== * 初始化堆空间 * ========================================== * 这里会调用G1CollectedHeap::initialize()方法， * 真正向操作系统申请内存 * ========================================== */ status = _collectedHeap-&gt;initialize(); if (status != JNI_OK) &#123; return status; &#125; log_info(gc)("Using %s", _collectedHeap-&gt;name()); ThreadLocalAllocBuffer::set_max_size(Universe::heap()-&gt;max_tlab_size());#ifdef _LP64 // 在LP64数据模型下是否开启对象指针压缩 if (UseCompressedOops) &#123; // Subtract a page because something can get allocated at heap base. // This also makes implicit null checking work, because the // memory+1 page below heap_base needs to cause a signal. // See needs_explicit_null_check. // Only set the heap base for compressed oops because it indicates // compressed oops for pstack code. if ((uint64_t)Universe::heap()-&gt;reserved_region().end() &gt; UnscaledOopHeapMax) &#123; // Didn't reserve heap below 4Gb. Must shift. Universe::set_narrow_oop_shift(LogMinObjAlignmentInBytes); &#125; if ((uint64_t)Universe::heap()-&gt;reserved_region().end() &lt;= OopEncodingHeapMax) &#123; // Did reserve heap below 32Gb. Can use base == 0; Universe::set_narrow_oop_base(0); &#125; Universe::set_narrow_ptrs_base(Universe::narrow_oop_base()); LogTarget(Info, gc, heap, coops) lt; if (lt.is_enabled()) &#123; ResourceMark rm; LogStream ls(lt); Universe::print_compressed_oops_mode(&amp;ls); &#125; // Tell tests in which mode we run. Arguments::PropertyList_add(new SystemProperty("java.vm.compressedOopsMode", narrow_oop_mode_to_string(narrow_oop_mode()), false)); &#125; // Universe::narrow_oop_base() is one page below the heap. assert((intptr_t)Universe::narrow_oop_base() &lt;= (intptr_t)(Universe::heap()-&gt;base() - os::vm_page_size()) || Universe::narrow_oop_base() == NULL, "invalid value"); assert(Universe::narrow_oop_shift() == LogMinObjAlignmentInBytes || Universe::narrow_oop_shift() == 0, "invalid value");#endif // We will never reach the CATCH below since Exceptions::_throw will cause // the VM to exit if an exception is thrown during initialization // 如果使用TLAB if (UseTLAB) &#123; assert(Universe::heap()-&gt;supports_tlab_allocation(), "Should support thread-local allocation buffers"); ThreadLocalAllocBuffer::startup_initialization(); &#125; return JNI_OK;&#125; universe.cpp # create_heap()create_heap()用于根据GC策略创建堆空间，位于src/hotspot/share/memory/universe.cpp 12345678910111213141516171819202122232425CollectedHeap* Universe::create_heap() &#123; assert(_collectedHeap == NULL, "Heap already created");#if !INCLUDE_ALL_GCS if (UseParallelGC) &#123; fatal("UseParallelGC not supported in this VM."); &#125; else if (UseG1GC) &#123; fatal("UseG1GC not supported in this VM."); &#125; else if (UseConcMarkSweepGC) &#123; fatal("UseConcMarkSweepGC not supported in this VM.");#else if (UseParallelGC) &#123; return Universe::create_heap_with_policy&lt;ParallelScavengeHeap, GenerationSizer&gt;(); &#125; else if (UseG1GC) &#123; // 此处默认使用G1 return Universe::create_heap_with_policy&lt;G1CollectedHeap, G1CollectorPolicy&gt;(); &#125; else if (UseConcMarkSweepGC) &#123; return Universe::create_heap_with_policy&lt;GenCollectedHeap, ConcurrentMarkSweepPolicy&gt;();#endif &#125; else if (UseSerialGC) &#123; return Universe::create_heap_with_policy&lt;GenCollectedHeap, MarkSweepPolicy&gt;(); &#125; ShouldNotReachHere(); return NULL;&#125; g1CollectedHeap.cpp # G1CollectedHeap::initialize()堆空间创建完毕，接下来是初始化，从上面return Universe::create_heap_with_policy&lt;G1CollectedHeap, G1CollectorPolicy&gt;();可以看出，_collectedHeap对应的堆实现是G1CollectedHeap，位于src/hotspot/share/gc/g1/g1CollectedHeap.cpp，对应上面的_collectedHeap-&gt;initialize()， 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136// G1CollectedHeap初始化jint G1CollectedHeap::initialize() &#123; CollectedHeap::pre_initialize(); os::enable_vtime(); // Necessary to satisfy locking discipline assertions. MutexLocker x(Heap_lock); size_t init_byte_size = collector_policy()-&gt;initial_heap_byte_size(); size_t max_byte_size = collector_policy()-&gt;max_heap_byte_size(); size_t heap_alignment = collector_policy()-&gt;heap_alignment(); // 申请Java堆内存及确定CompressedOops模式 ReservedSpace heap_rs = Universe::reserve_heap(max_byte_size, heap_alignment); // 初始化申请的内存区域 initialize_reserved_region((HeapWord*)heap_rs.base(), (HeapWord*)(heap_rs.base() + heap_rs.size())); // 为整个保留区域创建barrier // Create the barrier set for the entire reserved region. G1SATBCardTableLoggingModRefBS* bs = new G1SATBCardTableLoggingModRefBS(reserved_region()); bs-&gt;initialize(); assert(bs-&gt;is_a(BarrierSet::G1SATBCTLogging), "sanity"); set_barrier_set(bs); // 创建热卡缓存 // Create the hot card cache. _hot_card_cache = new G1HotCardCache(this); // Carve out the G1 part of the heap. ReservedSpace g1_rs = heap_rs.first_part(max_byte_size); size_t page_size = UseLargePages ? os::large_page_size() : os::vm_page_size(); // 创建mapper G1RegionToSpaceMapper* heap_storage = G1RegionToSpaceMapper::create_mapper(g1_rs, g1_rs.size(), page_size, HeapRegion::GrainBytes, 1, mtJavaHeap); os::trace_page_sizes("Heap", collector_policy()-&gt;min_heap_byte_size(), max_byte_size, page_size, heap_rs.base(), heap_rs.size()); heap_storage-&gt;set_mapping_changed_listener(&amp;_listener); FreeRegionList::set_unrealistically_long_length(max_regions() + 1); _bot = new G1BlockOffsetTable(reserved_region(), bot_storage); &#123; HeapWord* start = _hrm.reserved().start(); HeapWord* end = _hrm.reserved().end(); size_t granularity = HeapRegion::GrainBytes; _in_cset_fast_test.initialize(start, end, granularity); _humongous_reclaim_candidates.initialize(start, end, granularity); &#125; // 创建G1ConcurrentMark数据结构和线程 // Create the G1ConcurrentMark data structure and thread. // (Must do this late, so that "max_regions" is defined.) _cm = new G1ConcurrentMark(this, prev_bitmap_storage, next_bitmap_storage); if (_cm == NULL || !_cm-&gt;completed_initialization()) &#123; vm_shutdown_during_initialization("Could not create/initialize G1ConcurrentMark"); return JNI_ENOMEM; &#125; _cmThread = _cm-&gt;cmThread(); // Now expand into the initial heap size. if (!expand(init_byte_size, _workers)) &#123; vm_shutdown_during_initialization("Failed to allocate initial heap."); return JNI_ENOMEM; &#125; // 执行委托给内存（G1）策略的所有初始化操作 // Perform any initialization actions delegated to the policy. g1_policy()-&gt;init(this, &amp;_collection_set); JavaThread::satb_mark_queue_set().initialize(SATB_Q_CBL_mon, SATB_Q_FL_lock, G1SATBProcessCompletedThreshold, Shared_SATB_Q_lock); jint ecode = initialize_concurrent_refinement(); if (ecode != JNI_OK) &#123; return ecode; &#125; JavaThread::dirty_card_queue_set().initialize(DirtyCardQ_CBL_mon, DirtyCardQ_FL_lock, (int)concurrent_g1_refine()-&gt;yellow_zone(), (int)concurrent_g1_refine()-&gt;red_zone(), Shared_DirtyCardQ_lock, NULL, // fl_owner true); // init_free_ids dirty_card_queue_set().initialize(DirtyCardQ_CBL_mon, DirtyCardQ_FL_lock, -1, // never trigger processing -1, // no limit on length Shared_DirtyCardQ_lock, &amp;JavaThread::dirty_card_queue_set()); // Here we allocate the dummy HeapRegion that is required by the // G1AllocRegion class. HeapRegion* dummy_region = _hrm.get_dummy_region(); // We'll re-use the same region whether the alloc region will // require BOT updates or not and, if it doesn't, then a non-young // region will complain that it cannot support allocations without // BOT updates. So we'll tag the dummy region as eden to avoid that. dummy_region-&gt;set_eden(); // Make sure it's full. dummy_region-&gt;set_top(dummy_region-&gt;end()); G1AllocRegion::setup(this, dummy_region); _allocator-&gt;init_mutator_alloc_region(); // Do create of the monitoring and management support so that // values in the heap have been properly initialized. _g1mm = new G1MonitoringSupport(this); G1StringDedup::initialize(); _preserved_marks_set.init(ParallelGCThreads); _collection_set.initialize(max_regions()); return JNI_OK;&#125; 至此，JVM的整个初始化工作完成，关于GC策略的空间分配具体细节在以后的文章中再详细介绍。]]></content>
      <categories>
        <category>OpenJDK</category>
      </categories>
      <tags>
        <tag>OpenJDK</tag>
        <tag>JVM</tag>
        <tag>HotSpot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【JVM源码探秘】HotSpot启动流程分析-创建]]></title>
    <url>%2Fpost%2F2018%2F04%2F30%2Fanalysis-of-hotspot-jvm-startup-process-creation%2F</url>
    <content type="text"><![CDATA[在之前的文章中已经介绍了如何在Mac上编译及调试OpenJDK10源码， 那么，一个Java实例从开始运行至结束经历了什么？本文将从JVM源码角度一探究竟，深入剖析HotSpot其创建流程。 main.c # main()程序主入口位于src/java.base/share/native/launcher/main.c 12345678910111213141516171819202122intmain(int argc, char **argv)&#123; int margc; char** margv; int jargc; char** jargv; const jboolean const_javaw = JNI_FALSE; ...#endif /* WIN32 */ return JLI_Launch(margc, margv, jargc, (const char**) jargv, 0, NULL, VERSION_STRING, DOT_VERSION, (const_progname != NULL) ? const_progname : *margv, (const_launcher != NULL) ? const_launcher : *margv, jargc &gt; 0, const_cpwildcard, const_javaw, 0);&#125; main返回了JLI_Launch()函数，位于src/java.base/share/native/libjli/java.c java.c # JLI_Launch()123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102/* * Entry point. */intJLI_Launch(int argc, char ** argv, /* main argc, argc */ int jargc, const char** jargv, /* java args */ int appclassc, const char** appclassv, /* app classpath */ const char* fullversion, /* full version defined */ const char* dotversion, /* UNUSED dot version defined */ const char* pname, /* program name */ const char* lname, /* launcher name */ jboolean javaargs, /* JAVA_ARGS */ jboolean cpwildcard, /* classpath wildcard*/ jboolean javaw, /* windows-only javaw */ jint ergo /* unused */)&#123; int mode = LM_UNKNOWN; char *what = NULL; char *main_class = NULL; int ret; InvocationFunctions ifn; jlong start, end; char jvmpath[MAXPATHLEN]; char jrepath[MAXPATHLEN]; char jvmcfg[MAXPATHLEN]; /* * 确保运行适当的JRE * * SelectVersion() has several responsibilities: * * 1) Disallow specification of another JRE. With 1.9, another * version of the JRE cannot be invoked. * 2) Allow for a JRE version to invoke JDK 1.9 or later. Since * all mJRE directives have been stripped from the request but * the pre 1.9 JRE [ 1.6 thru 1.8 ], it is as if 1.9+ has been * invoked from the command line. */ SelectVersion(argc, argv, &amp;main_class); // 创建运行环境，如检查系统使用的数据模型（32bit、64bit），获取使用的JRE路径，找到jvm.cfg解析已知的vm类型 // 设置新的LD_LIBRARY_PATH变量 CreateExecutionEnvironment(&amp;argc, &amp;argv, jrepath, sizeof(jrepath), jvmpath, sizeof(jvmpath), jvmcfg, sizeof(jvmcfg)); // 加载JVM // 通过jvmpath找到libjvm.so 返回以下方法 // JNI_CreateJavaVM // JNI_GetDefaultJavaVMInitArgs // GetCreatedJavaVMs // 的符号地址返回，挂载到InvocationFunctions以便后续调用 if (!LoadJavaVM(jvmpath, &amp;ifn)) &#123; return(6); &#125; if (IsJavaArgs()) &#123; // 转换命令行参数 如：javac -cp foo:foo/"*" -J-ms32m /* Preprocess wrapper arguments */ TranslateApplicationArgs(jargc, jargv, &amp;argc, &amp;argv); /* * 添加了三个VM选项 * -Denv.class.path 用户设置的CLASSPATH变量，如果CLASSPATH显式设置了tools.jar * 则可以反编译VM的工具类sun.tools.* * -Dapplication.home 应用程序目录 * -Djava.class.path 应用程序的类文件目录 */ if (!AddApplicationOptions(appclassc, appclassv)) &#123; return(1); &#125; &#125; else &#123; /* Set default CLASSPATH */ char* cpath = getenv("CLASSPATH"); if (cpath != NULL) &#123; SetClassPath(cpath); &#125; &#125; /* 解析命令行参数-jar -cp、-version、-*path、-X*等参数 * * Parse command line options; if the return value of * ParseArguments is false, the program should exit. */ if (!ParseArguments(&amp;argc, &amp;argv, &amp;mode, &amp;what, &amp;ret, jrepath)) &#123; return(ret); &#125; // 设置classpath /* Override class path if -jar flag was specified */ if (mode == LM_JAR) &#123; SetClassPath(what); /* Override class path */ &#125; ... return JVMInit(&amp;ifn, threadStackSize, argc, argv, mode, what, ret);&#125; 继续跟进JVMInit()方法，位于src/java.base/macosx/native/libjli/java_md_macosx.c， 注：由于我的系统是Mac，所以对应的是java_md_macosx.c，其他系统位于目录src/java.base对应操作系统类型下的java_md.c或java_md_xxx.c java_md_macosx.c # JVMInit()12345678910111213141516171819202122232425262728293031323334353637intJVMInit(InvocationFunctions* ifn, jlong threadStackSize, int argc, char **argv, int mode, char *what, int ret) &#123; if (sameThread) &#123; JLI_TraceLauncher("In same thread\n"); // need to block this thread against the main thread // so signals get caught correctly __block int rslt = 0; NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init]; &#123; NSBlockOperation *op = [NSBlockOperation blockOperationWithBlock: ^&#123; JavaMainArgs args; args.argc = argc; args.argv = argv; args.mode = mode; args.what = what; args.ifn = *ifn; rslt = JavaMain(&amp;args); &#125;]; /* * We cannot use dispatch_sync here, because it blocks the main dispatch queue. * Using the main NSRunLoop allows the dispatch queue to run properly once * SWT (or whatever toolkit this is needed for) kicks off it's own NSRunLoop * and starts running. */ [op performSelectorOnMainThread:@selector(start) withObject:nil waitUntilDone:YES]; &#125; [pool drain]; return rslt; &#125; else &#123; // block当前线程并且在新线程中继续执行 // 至于为什么在新线程中创建JVM见引用https://bugs.openjdk.java.net/browse/JDK-6316197 return ContinueInNewThread(ifn, threadStackSize, argc, argv, mode, what, ret); &#125;&#125; JVMInit方法紧接着又return回java.c的ContinueInNewThread()方法 java.c # ContinueInNewThread()1234567891011121314151617181920212223242526272829303132333435363738394041intContinueInNewThread(InvocationFunctions* ifn, jlong threadStackSize, int argc, char **argv, int mode, char *what, int ret)&#123; /* * 指定线程大小 * If user doesn't specify stack size, check if VM has a preference. * Note that HotSpot no longer supports JNI_VERSION_1_1 but it will * return its default stack size through the init args structure. */ if (threadStackSize == 0) &#123; struct JDK1_1InitArgs args1_1; memset((void*)&amp;args1_1, 0, sizeof(args1_1)); args1_1.version = JNI_VERSION_1_1; ifn-&gt;GetDefaultJavaVMInitArgs(&amp;args1_1); /* ignore return value */ if (args1_1.javaStackSize &gt; 0) &#123; threadStackSize = args1_1.javaStackSize; &#125; &#125; &#123; /* Create a new thread to create JVM and invoke main method */ JavaMainArgs args; int rslt; args.argc = argc; args.argv = argv; args.mode = mode; args.what = what; args.ifn = *ifn; // 在新线程中执行 rslt = ContinueInNewThread0(JavaMain, threadStackSize, (void*)&amp;args); /* If the caller has deemed there is an error we * simply return that, otherwise we return the value of * the callee */ return (ret != 0) ? ret : rslt; &#125;&#125; ContinueInNewThread()方法调用了执行方法ContinueInNewThread0() java.c # ContinueInNewThread0()1234567891011121314151617181920212223242526272829303132333435/* * Block current thread and continue execution in a new thread */intContinueInNewThread0(int (JNICALL *continuation)(void *), jlong stack_size, void * args) &#123; int rslt; pthread_t tid; pthread_attr_t attr; pthread_attr_init(&amp;attr); pthread_attr_setdetachstate(&amp;attr, PTHREAD_CREATE_JOINABLE); if (stack_size &gt; 0) &#123; pthread_attr_setstacksize(&amp;attr, stack_size); &#125; pthread_attr_setguardsize(&amp;attr, 0); // no pthread guard page on java threads if (pthread_create(&amp;tid, &amp;attr, (void *(*)(void*))continuation, (void*)args) == 0) &#123; void * tmp; pthread_join(tid, &amp;tmp); rslt = (int)(intptr_t)tmp; &#125; else &#123; /* * 调用JNI_CreateJavaVM执行创建虚拟机 * * Continue execution in current thread if for some reason (e.g. out of * memory/LWP) a new thread can't be created. This will likely fail * later in continuation as JNI_CreateJavaVM needs to create quite a * few new threads, anyway, just give it a try.. */ rslt = continuation(args); &#125; pthread_attr_destroy(&amp;attr); return rslt;&#125; ContinueInNewThread0()中最终执行了名为continuation的JNICALL，而这个的JNICALL正是上一步传过来的JavaMain，单看JavaMain这个名字就好熟悉，有木有？接下来我们看看JavaMain的庐山真面目 java.c # JavaMain()123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140int JNICALLJavaMain(void * _args)&#123; JavaMainArgs *args = (JavaMainArgs *)_args; int argc = args-&gt;argc; char **argv = args-&gt;argv; int mode = args-&gt;mode; char *what = args-&gt;what; InvocationFunctions ifn = args-&gt;ifn; JavaVM *vm = 0; JNIEnv *env = 0; jclass mainClass = NULL; jclass appClass = NULL; // actual application class being launched jmethodID mainID; jobjectArray mainArgs; int ret = 0; jlong start, end; RegisterThread(); // ================================ // 初始化虚拟机 // ================================ /* Initialize the virtual machine */ start = CounterGet(); if (!InitializeJVM(&amp;vm, &amp;env, &amp;ifn)) &#123; JLI_ReportErrorMessage(JVM_ERROR1); exit(1); &#125; ... // 如果输入了-version或-showversion参数 if (printVersion || showVersion) &#123; PrintJavaVersion(env, showVersion); CHECK_EXCEPTION_LEAVE(0); if (printVersion) &#123; LEAVE(); &#125; &#125; // 如果jar文件和类名均未指定则输出默认usage信息 /* If the user specified neither a class name nor a JAR file */ if (printXUsage || printUsage || what == 0 || mode == LM_UNKNOWN) &#123; PrintUsage(env, printXUsage); CHECK_EXCEPTION_LEAVE(1); LEAVE(); &#125; FreeKnownVMs(); /* after last possible PrintUsage */ ret = 1; /* * 加载Java程序的main方法，如果没找到则退出 * * Get the application's main class. It also checks if the main * method exists. * * See bugid 5030265. The Main-Class name has already been parsed * from the manifest, but not parsed properly for UTF-8 support. * Hence the code here ignores the value previously extracted and * uses the pre-existing code to reextract the value. This is * possibly an end of release cycle expedient. However, it has * also been discovered that passing some character sets through * the environment has "strange" behavior on some variants of * Windows. Hence, maybe the manifest parsing code local to the * launcher should never be enhanced. * * Hence, future work should either: * 1) Correct the local parsing code and verify that the * Main-Class attribute gets properly passed through * all environments, * 2) Remove the vestages of maintaining main_class through * the environment (and remove these comments). * * This method also correctly handles launching existing JavaFX * applications that may or may not have a Main-Class manifest entry. */ mainClass = LoadMainClass(env, mode, what); CHECK_EXCEPTION_NULL_LEAVE(mainClass); /* * 获取程序主类Class对象 * * In some cases when launching an application that needs a helper, e.g., a * JavaFX application with no main method, the mainClass will not be the * applications own main class but rather a helper class. To keep things * consistent in the UI we need to track and report the application main class. */ appClass = GetApplicationClass(env); NULL_CHECK_RETURN_VALUE(appClass, -1); // 构建main方法参数列表 /* Build platform specific argument array */ mainArgs = CreateApplicationArgs(env, argv, argc); CHECK_EXCEPTION_NULL_LEAVE(mainArgs); if (dryRun) &#123; ret = 0; LEAVE(); &#125; /* * PostJVMInit uses the class name as the application name for GUI purposes, * for example, on OSX this sets the application name in the menu bar for * both SWT and JavaFX. So we'll pass the actual application class here * instead of mainClass as that may be a launcher or helper class instead * of the application class. */ PostJVMInit(env, appClass, vm); CHECK_EXCEPTION_LEAVE(1); /* * 获取main方法ID * * The LoadMainClass not only loads the main class, it will also ensure * that the main method's signature is correct, therefore further checking * is not required. The main method is invoked here so that extraneous java * stacks are not in the application stack trace. */ mainID = (*env)-&gt;GetStaticMethodID(env, mainClass, "main", "([Ljava/lang/String;)V"); CHECK_EXCEPTION_NULL_LEAVE(mainID); // 调用main方法 /* Invoke main method. */ (*env)-&gt;CallStaticVoidMethod(env, mainClass, mainID, mainArgs); /* * 如果有异常抛出，程序将返回非零结束码 * * The launcher's exit code (in the absence of calls to * System.exit) will be non-zero if main threw an exception. */ ret = (*env)-&gt;ExceptionOccurred(env) == NULL ? 0 : 1; // 退出 LEAVE();&#125; 可见JavaMain()是Java主程序的native调用。在该方法里会执行虚拟机的初始化，获取Java程序主类及main方法，然后通过JNI调用main方法，自此，整个JVM进程执行结束，最终退出。 值得注意的是:该方法中调用的InitializeJVM()方法会执行一系列关于虚拟机的分配、挂载、初始化等工作，下篇文章我们继续详细深入介绍。]]></content>
      <categories>
        <category>OpenJDK</category>
      </categories>
      <tags>
        <tag>OpenJDK</tag>
        <tag>JVM</tag>
        <tag>HotSpot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【JVM源码探秘】在Mac上搭建OpenJDK10源码调试环境]]></title>
    <url>%2Fpost%2F2018%2F01%2F30%2Fdebug-openjdk10-source-code-on-mac-with-clion-ide%2F</url>
    <content type="text"><![CDATA[前面文章已经介绍了如何在Mac上编译OpenJDK10源码，拥有了自己的JDK版本， 为了深入了解Java实例的创建、初始化和执行流程以及内部实现原理，DEBUG是必不可少的必杀技。 所以，本篇文章继续介绍在Mac上搭建OpenJDK10源码调试环境，黑喂狗。 软件环境 OS: macOS Sierra 10.12 IDE: Clion 2018.1 Code: OpenJDK 10 下载IDE从JetBrains官网下载Clion，安装。 导入项目打开Clion依次选择File &gt; Import Project 编辑配置如下图编辑DEBUG配置信息 Executable 选择之前build出的镜像里的java可执行文件（i.e. build/macosx-x86_64-normal-server-slowdebug/jdk/bin/java） Program arguments 填写-version，输出Java版本 Before launch 注意：这里一定要移除Build，否则会报错无法调试 调试源码在hotspot/share/runtime/thread.cpp文件的Threads::create_vm方法内部打断点， 点击DEBUG按钮，不出意外会发现进入如下界面，congrats！ 接下来，泡杯咖啡，Step by step慢慢DEBUG吧，后面的文章将陆续介绍JVM创建及初始化流程。]]></content>
      <categories>
        <category>OpenJDK</category>
      </categories>
      <tags>
        <tag>OpenJDK</tag>
        <tag>JVM</tag>
        <tag>HotSpot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【JVM源码探秘】在Mac上编译OpenJDK10源码]]></title>
    <url>%2Fpost%2F2018%2F01%2F29%2Fcompile-openjdk10-source-code-on-mac%2F</url>
    <content type="text"><![CDATA[以前尝试编译过OpenJDK7、8和9，由于源代码中存在诸多BUG，导致各种编译问题，解决来解决去，还是很难编译通过，很是不爽。 今天抱着试试看的态度又服用了一个疗程，拿起桌上的OpenJDK10，反手就是一次编译，居然像德芙一样丝滑，一次通过。 软件环境 OS：macOS Sierra 10.12 Xcode: 8.3.3 Oracle JDK: 1.8.0_151 freetype: 2.9 ccache: 3.3.5(Optional) 前置条件先确保系统已安装freetype和ccache1$ brew install freetype ccache 拉取代码1$ hg clone http://hg.openjdk.java.net/jdk10/master openjdk10 此处需要耐心等待一段时间，必要情况下需要多尝试几次才能拉取成功。 配置参数接下来配置编译参数，以下是相关选项说明 --with-debug-level=slowdebug 启用slowdebug级别调试 --enable-dtrace 启用dtrace --with-jvm-variants=server 编译server类型JVM --with-target-bits=64 指定JVM为64位 --enable-ccache 启用ccache，加快编译 --with-num-cores=8 编译使用CPU核心数 --with-memory-size=8000 编译使用内存 --disable-warnings-as-errors 忽略警告 123456789101112131415161718192021222324252627$ bash configure --with-debug-level=slowdebug --enable-dtrace --with-jvm-variants=server --with-target-bits=64 --enable-ccache --with-num-cores=8 --with-memory-size=8000 --disable-warnings-as-errors...====================================================A new configuration has been successfully created in/Users/hunterzhao/CLionProjects/OpenJDK10/build/macosx-x86_64-normal-server-slowdebugusing configure arguments '--with-debug-level=slowdebug --enable-dtrace --with-jvm-variants=server --with-target-bits=64 --enable-ccache --with-num-cores=8 --with-memory-size=8000 --disable-warnings-as-errors'.Configuration summary:* Debug level: slowdebug* HS debug level: debug* JDK variant: normal* JVM variants: server* OpenJDK target: OS: macosx, CPU architecture: x86, address length: 64* Version string: 10-internal+0-adhoc.hunterzhao.OpenJDK10 (10-internal)Tools summary:* Boot JDK: java version "1.8.0_151" Java(TM) SE Runtime Environment (build 1.8.0_151-b12) Java HotSpot(TM) 64-Bit Server VM (build 25.151-b12, mixed mode) (at /Library/Java/JavaVirtualMachines/jdk1.8.0_151.jdk/Contents/Home)* Toolchain: clang (clang/LLVM from Xcode 8.3.3)* C Compiler: Version 8.1.0 (at /usr/bin/clang)* C++ Compiler: Version 8.1.0 (at /usr/bin/clang++)Build performance summary:* Cores to use: 7* Memory limit: 8000 MB* ccache status: Active (3.3.5) 执行编译123456789101112131415161718192021222324$ make images...Creating support/demos/image/jfc/CodePointIM/CodePointIM.jarCreating support/demos/image/applets/MoleculeViewer/MoleculeViewer.jarCreating support/demos/image/applets/WireFrame/WireFrame.jarCreating support/demos/image/jfc/SwingApplet/SwingApplet.jarCreating support/demos/image/jfc/FileChooserDemo/FileChooserDemo.jarCreating support/demos/image/jfc/Font2DTest/Font2DTest.jarCreating support/demos/image/jfc/Metalworks/Metalworks.jarCreating support/demos/image/jfc/Notepad/Notepad.jarCreating support/demos/image/jfc/SampleTree/SampleTree.jarCreating support/demos/image/jfc/TableExample/TableExample.jarCreating support/demos/image/jfc/TransparentRuler/TransparentRuler.jarCreating support/classlist.jarCreating images/jmods/jdk.jlink.jmodCreating images/jmods/java.base.jmodCreating jre jimageCreating jdk jimageWARNING: Using incubator modules: jdk.incubator.httpclientWARNING: Using incubator modules: jdk.incubator.httpclientStopping sjavac serverFinished building target &apos;images&apos; in configuration &apos;macosx-x86_64-normal-server-slowdebug&apos; 大约10分钟后编译完成，由于机器配置不同可能会导致编译时长有所差异。 测试1234$ ./build/macosx-x86_64-normal-server-slowdebug/jdk/bin/java -versionopenjdk version "10-internal"OpenJDK Runtime Environment (slowdebug build 10-internal+0-adhoc.hunterzhao.OpenJDK10)OpenJDK 64-Bit Server VM (slowdebug build 10-internal+0-adhoc.hunterzhao.OpenJDK10, mixed mode) 本篇文章至此结束，下篇介绍搭建OpenJDK10 DEBUG环境。]]></content>
      <categories>
        <category>OpenJDK</category>
      </categories>
      <tags>
        <tag>OpenJDK</tag>
        <tag>JVM</tag>
        <tag>HotSpot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一行Python命令开启简单的静态文件服务器]]></title>
    <url>%2Fpost%2F2017%2F08%2F30%2Fstart-up-a-file-server-using-one-python-command%2F</url>
    <content type="text"><![CDATA[在开发过程当中，常常会需要启动一个静态文件服务器用来访问静态资源或传输文件，安装Nginx？安装Tomcat？ No！都太重了。只需要执行一个Python命令即可马上拥有一个轻量级静态服务器。 如果你使用的是Python2.x12$ python -m SimpleHTTPServerServing HTTP on 0.0.0.0 port 8000 ... 如果你使用的是Python3.x1$ python -m http.server 打开浏览器即可访问http://localhost:8000，也可在后面追加指定目标端口，如：python -m SimpleHTTPServer 9000]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于MyBatis通用代码生成器CoffeeMaker的设计思路]]></title>
    <url>%2Fpost%2F2017%2F07%2F21%2Fdesign-of-universal-code-generator-coffee-maker%2F</url>
    <content type="text"><![CDATA[CoffeeMaker是一款经过良好设计的代码生成器，可快速生成通用CRUD代码模板，使用方便且易于扩展。于2017年7月开发完成，源代码托管于GitHub仓库。 引言在整个软件开发过程中有一大部分内容是相当有共性的，比如模型对象、配置文件、基本CRUD操作方法等等， 程序员是用来思考问题的，不是用来执行重复任务的，所以那些重复性的工作交给机器或工具去做就好了。 而开源社区里不乏一些代码生成器，但生成代码的格式、风格往往并不符合团队开发规范，去修改的话还得先去去读懂别人代码，为何不写一个出来沉淀为自己团队的产物呢。 设计 通过JDBC读取DB元数据封装成数据对象。 使用DefinitionConverter转换成模型文件定义对象。 将模型文件对象封装成所需文件封装器FileWrapper。 使用FileParser将FileWrapper渲染至对应的模板文件。 输出最终目标文件。 流程1234567891011121314151617181920212223242526272829303132333435 &lt; Workflow diagram of CoffeeMaker &gt; +----------+ JDBC +---------------------+ TableMetadata +------------------------+| | ------&gt; | | ----------------&gt; | DefinitionConverter || Database | | MetadataProvider | +------------------------+| | | | || | | | | FileDefinition+----------+ +---------------------+ v +- - - - - - - - - - - - - - + &apos; Various of file wrappers &apos; &apos; &apos; &apos; +------------------------+ &apos; &apos; | FileWrapper | &apos; &apos; +------------------------+ &apos; &apos; &apos; +- - - - - - - - - - - - - - + | | | +- - - - - - - - - - - - -+ | &apos; OUTPUT: &apos; | &apos; &apos; | &apos; XxxEntity.java &apos; | &apos; XxxMapper.xml &apos; | &apos; XxxDao.java &apos; | &apos; XxxService.java &apos; | &apos; XxxServiceImpl.java &apos; | &apos; XxxController.java &apos; | &apos; XxxVo.java &apos; | &apos; &apos; v &apos; +---------------------+ &apos; Parse &amp; export +------------------------+ &apos; | Ultimate Code Files | &apos; &lt;---------------- | | &apos; +---------------------+ &apos; | FileParser | &apos; &apos; | | +- - - - - - - - - - - - -+ +------------------------+ 配置 配置数据源文件src/main/resource/config.properties 配置代码生成规则 1234567Configuration configuration = new Configuration(); configuration.setTableName("t_user") .setTablePrefix("") .setPackageName("com.workholiday") .setPagerPackageName("com.workholiday.base.core.page") .setWithPager(true) .setOutputPath("/Users/hunterzhao/tmp/output"); 执行通过CoffeeMakerLauncher类的main方法执行代码生成器 输出生成的代码模板如下： Entity文件 DAO文件 MyBatis mapper文件 Service文件 Service实现类 VO文件 Controller文件 扩展如果需要定制化CoffeeMaker，可以通过修改（新增）FileWrapper和FileTemplate来轻松实现。]]></content>
      <categories>
        <category>MyBatis</category>
      </categories>
      <tags>
        <tag>MyBatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于IntelliJ IDEA插件Open Terminal Here的设计思路]]></title>
    <url>%2Fpost%2F2015%2F12%2F03%2Fdesign-of-intellij-plugin-open-terminal-here%2F</url>
    <content type="text"><![CDATA[Open Terminal Here是一款用于在终端中直接打开文件所在目录的IntelliJ插件，于2015年12月3日发布至IntelliJ IDEA官方插件库，目前有3K+次下载，源代码托管于GitHub。 痛点场景一直使用IntelliJ IDEA作为IDE，深爱它的智能，正如其名。然而，再完美的东西也有不完美的地方。 作为命令行重度用户自然免不了在命令行进行操作，这种情况下就不得不逐级cd到某个工程文件所在目录，如果目录层级特别深，那酸爽不可思议。 那么，问题来了，如何从命令行中一步切换到文件所在目录？答案就是：给IntelliJ写插件。 实现思路IntelliJ IDEA开放了一套完整的OpenAPI，通过该OpenAPI几乎可以完成对IDEA各个组件的操作及扩展，非常方便。 思路大致为： 首先通过OpenAPI获取工程文件的VirtualFile对象，VirtualFile是对文件系统的封装，包含了工程文件几乎所有信息，包括所在系统目录。 将文件系统目录封装成对应OS的自定义Command对象 通过Runtime.getRuntime().exec(command)调用系统命令行并切换至目标目录 代码实现通过OpenAPI获取工程文件所在目录12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849/** * Author: Hunter Zhao * Date: 12/2/15 18:31 * Description: tool for file operation */public class FileUtil &#123; /** * determine the VirtualFile which selected in Project view * @param project * @return */ public static VirtualFile getSelectedProjectFile(@NotNull Project project) &#123; AbstractProjectViewPane currentProjectViewPane = ProjectView.getInstance(project).getCurrentProjectViewPane(); if (currentProjectViewPane == null) &#123; return null; &#125; DefaultMutableTreeNode node = currentProjectViewPane.getSelectedNode(); if (node == null) &#123; return null; &#125; Object selected = null; Object userObject = node.getUserObject(); if (userObject instanceof AbstractTreeNode) &#123; selected = ((AbstractTreeNode)userObject).getValue(); &#125; else if (userObject instanceof NodeDescriptor) &#123; selected = ((NodeDescriptor)userObject).getElement(); &#125; if (selected == null) &#123; return null; &#125; VirtualFile vf = null; if (selected instanceof PsiDirectory) &#123; vf = ((PsiDirectory)selected).getVirtualFile(); &#125; else if (selected instanceof PsiElement) &#123; vf = ((PsiElement) selected).getContainingFile().getVirtualFile().getParent(); &#125; else &#123; // ignored &#125; return vf; &#125;&#125; 封装成Command对象 Command对象 1234567891011121314151617181920public class Command &#123; private String[] cmdArray; private String[] envp; private File dir; public Command(String[] cmdArray) &#123; this.cmdArray = cmdArray; &#125; public Command(String[] cmdArray, String[] envp, File dir) &#123; this.cmdArray = cmdArray; this.envp = envp; this.dir = dir; &#125; ... 省略setters &amp; getters&#125; Win平台命令执行器 123456789101112131415161718192021222324252627/** * Author: Hunter Zhao * Date: 12/2/15 18:43 * Description: command executor for Windows Platform */public class WinExecutor extends CommandExecutor &#123;private static final String WIN_CMD = "C:\\Windows\\System32\\cmd.exe"; public WinExecutor(String targetPath) &#123; super.targetPath = targetPath; &#125; @Override public String getTerminalPath() &#123; return WIN_CMD; &#125; @Override public Command buildCommand() &#123; String terminalPath = this.getTerminalPath(); String[] cmdArr = &#123;terminalPath, "/k", "start", "cd", getTargetPath()&#125;; return new Command(cmdArr, null, new File(getTargetPath())); &#125;&#125; Mac平台命令执行器 123456789101112131415161718192021222324252627282930313233343536/** * Author: Hunter Zhao * Date: 12/2/15 18:42 * Description: command executor for Mac Platform */public class MacExecutor extends CommandExecutor &#123; private static final String MAC_TERMINAL = "/Applications/Utilities/Terminal.app/Contents/MacOS/Terminal"; private static final String ITERM = "/Applications/iTerm.app/Contents/MacOS/iTerm"; private static final String ITERM2 = "/Applications/iTerm.app/Contents/MacOS/iTerm2"; public MacExecutor(String targetPath) &#123; setTargetPath(targetPath); &#125; @Override public String getTerminalPath() &#123; if (isTerminalInstalled(ITERM)) &#123; return ITERM; &#125; else if (isTerminalInstalled(ITERM2)) &#123; return ITERM2; &#125; return MAC_TERMINAL; &#125; @Override Command buildCommand() &#123; String terminalPath = this.getTerminalPath(); String[] cmdArr = &#123;terminalPath, getTargetPath()&#125;; return new Command(cmdArr); &#125;&#125; 调用系统命令行并切换至目标目录123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354/** * Author: Hunter Zhao * Date: 12/2/15 18:41 * Description: command execution template */public abstract class CommandExecutor &#123; /** * determine which terminal to be used * @return */ abstract String getTerminalPath(); /** * build the Command object * @return */ abstract Command buildCommand(); /** path to open */ protected String targetPath; /** * determine if the specified terminal has been installed * @param terminalPath * @return */ protected boolean isTerminalInstalled(String terminalPath) &#123; File terminal = new File(terminalPath); return terminal.exists() &amp;&amp; terminal.canExecute(); &#125; /** * open the target path in terminal */ public void openTerminal() &#123; Command cmd = this.buildCommand(); try &#123; Runtime.getRuntime().exec(cmd.getCmdArray(), cmd.getEnvp(), cmd.getDir()); &#125; catch (IOException e) &#123; // ignored &#125; &#125;; public String getTargetPath() &#123; return targetPath; &#125; public void setTargetPath(String targetPath) &#123; this.targetPath = targetPath; &#125;&#125; 开放插件入口1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950/** * Author: Hunter Zhao * Date: 12/2/15 18:31 * Description: An IntelliJ plugin for opening current directory in terminal */public class OpenTerminalHereAction extends AnAction &#123; public static final String PLUGIN_NAME = "OpenTerminalHere"; @Override public void actionPerformed(AnActionEvent event) &#123; Project project = event.getProject(); if (project == null) &#123; return; &#125; perform(project); &#125; /** * perform the action * @param project */ private void perform(@NotNull Project project) &#123; VirtualFile selectedFile = FileUtil.getSelectedProjectFile(project); if (selectedFile == null) &#123; return; &#125; String targetPath = selectedFile.getPath(); CommandExecutor executor = null; if (SystemInfo.isMac) &#123; executor = new MacExecutor(targetPath); &#125; else if (SystemInfo.isWindows) &#123; executor = new WinExecutor(targetPath); &#125; if (executor == null) &#123; NotificationTool.notify(project, PLUGIN_NAME, "Your operating system is not supported temporarily.", NotificationType.ERROR); return; &#125; executor.openTerminal(); &#125;&#125; 编辑plugin.xml配置12345678910&lt;actions&gt; &lt;!-- 插件基本信息 --&gt; &lt;action id="com.bobz.action.OpenTerminalHereAction" class="com.bobz.action.OpenTerminalHereAction" text="Open Terminal Here" description="Open Terminal Here"&gt; &lt;!-- 添加至目标分组 --&gt; &lt;add-to-group group-id="ProjectViewPopupMenu" anchor="after" relative-to-action="RevealIn"/&gt; &lt;!-- 快捷键设置 --&gt; &lt;keyboard-shortcut keymap="$default" first-keystroke="ctrl alt T"/&gt; &lt;/action&gt;&lt;/actions&gt; 参考引用 IntelliJ Platform SDK]]></content>
      <categories>
        <category>IntelliJ IDEA</category>
      </categories>
      <tags>
        <tag>IntelliJ IDEA</tag>
        <tag>插件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Hotspot源码分析】从HotSpot源码角度深入分析Java程序启动过程-初始化]]></title>
    <url>%2Fpost%2F2014%2F12%2F01%2Fanalyse-jvm-startup-flow-through-source-code-initialize%2F</url>
    <content type="text"><![CDATA[接上篇文章从Hotpost源码角度深入分析Java程序启动过程-创建 ，本文将继续介绍JVM启动过程的初始化部分。 在上篇文章中在执行LoadJavaVM方法的时候将libjvm.so内的方法JNI_CreateJavaVM和JNI_GetDefaultJavaVMInitArgs符号引用挂载到了结构体InvocationFunctions上，并且在执行InitializeJVM方法的时候进行了调用。 这里执行了JNI调用JNI_CreateJavaVM，文件位于hotspot/src/share/vm/prims/jni.cpp。方法内容如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243_JNI_IMPORT_OR_EXPORT_ jint JNICALL JNI_CreateJavaVM(JavaVM **vm, void **penv, void *args) &#123; // 略去部分非重要内容 /** * Certain errors during initialization are recoverable and do not * prevent this method from being called again at a later time * (perhaps with different arguments). However, at a certain * point during initialization if an error occurs we cannot allow * this function to be called again (or it will crash). In those * situations, the 'canTryAgain' flag is set to false, which atomically * sets safe_to_recreate_vm to 1, such that any new call to * JNI_CreateJavaVM will immediately fail using the above logic. */ bool can_try_again = true; //======================================== // 通过Threads模块初始化VM并创建VM线程 //======================================== result = Threads::create_vm((JavaVMInitArgs*) args, &amp;can_try_again); if (result == JNI_OK) &#123; JavaThread *thread = JavaThread::current(); /* thread is thread_in_vm here */ *vm = (JavaVM *)(&amp;main_vm); *(JNIEnv**)penv = thread-&gt;jni_environment(); // Tracks the time application was running before GC RuntimeService::record_application_start(); // Notify JVMTI if (JvmtiExport::should_post_thread_life()) &#123; JvmtiExport::post_thread_start(thread); &#125; EventThreadStart event; if (event.should_commit()) &#123; event.set_javalangthread(java_lang_Thread::thread_id(thread-&gt;threadObj())); event.commit(); &#125; // 略去部分内容 return result;&#125; 这里调用了hotspot/src/share/vm/runtime/thread.cpp的create_vm方法： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402jint Threads::create_vm(JavaVMInitArgs* args, bool* canTryAgain) &#123; extern void JDK_Version_init(); // Check version if (!is_supported_jni_version(args-&gt;version)) return JNI_EVERSION; // Initialize the output stream module // 初始化输出流 ostream_init(); // Process java launcher properties. // 处理Java启动参数，如-Dsun.java.launcher* Arguments::process_sun_java_launcher_properties(args); // Initialize the os module before using TLS // 初始化操作系统模块，如页大小，处理器数量，系统时钟等 os::init(); // Initialize system properties. // 初始化系统属性，其中分为【可读属性】和【可读写属性】 // 可读属性： // java.vm.specification.name // java.vm.version // java.vm.name // java.vm.info // 可读写属性： // java.ext.dirs // java.endorsed.dirs // sun.boot.library.path // java.library.path // java.home // sun.boot.class.path // java.class.path Arguments::init_system_properties(); // So that JDK version can be used as a discrimintor when parsing arguments JDK_Version_init(); // Update/Initialize System properties after JDK version number is known // 设置java.vm.specification.vendor属性（1.6之前是Sun Microsystems Inc. 1.7之后是Oracle Corporation） // 设置java.vm.specification.version和java.vm.vendor属性 Arguments::init_version_specific_system_properties(); // Parse arguments // 解析启动参数，如-XX:Flags=、-XX:+PrintVMOptions、-XX:+PrintFlagsInitial etc. jint parse_result = Arguments::parse(args); if (parse_result != JNI_OK) return parse_result; if (PauseAtStartup) &#123; os::pause(); &#125;#ifndef USDT2 HS_DTRACE_PROBE(hotspot, vm__init__begin);#else /* USDT2 */ HOTSPOT_VM_INIT_BEGIN();#endif /* USDT2 */ // Record VM creation timing statistics TraceVmCreationTime create_vm_timer; create_vm_timer.start(); // Timing (must come after argument parsing) TraceTime timer("Create VM", TraceStartupTime); // Initialize the os module after parsing the args jint os_init_2_result = os::init_2(); if (os_init_2_result != JNI_OK) return os_init_2_result; // intialize TLS ThreadLocalStorage::init(); // Bootstrap native memory tracking, so it can start recording memory // activities before worker thread is started. This is the first phase // of bootstrapping, VM is currently running in single-thread mode. MemTracker::bootstrap_single_thread(); // Initialize output stream logging // 初始化GC日志输出流，用来处理-Xloggc参数 ostream_init_log(); // Convert -Xrun to -agentlib: if there is no JVM_OnLoad // Must be before create_vm_init_agents() if (Arguments::init_libraries_at_startup()) &#123; convert_vm_init_libraries_to_agents(); &#125; // Launch -agentlib/-agentpath and converted -Xrun agents // 加载agent库 if (Arguments::init_agents_at_startup()) &#123; create_vm_init_agents(); &#125; // Initialize Threads state _thread_list = NULL; _number_of_threads = 0; _number_of_non_daemon_threads = 0; // Initialize global data structures and create system classes in heap // 初始化全局数据数据结构及系统类，包括： // 初始化Java基础类型 // 初始化时间队列 // 初始化锁 // 初始化chunkpool // 初始化性能数据统计模块 vm_init_globals(); // Attach the main thread to this os thread JavaThread* main_thread = new JavaThread(); main_thread-&gt;set_thread_state(_thread_in_vm); main_thread-&gt;record_stack_base_and_size(); main_thread-&gt;initialize_thread_local_storage(); main_thread-&gt;set_active_handles(JNIHandleBlock::allocate_block()); if (!main_thread-&gt;set_as_starting_thread()) &#123; vm_shutdown_during_initialization( "Failed necessary internal allocation. Out of swap space"); delete main_thread; *canTryAgain = false; // don't let caller call JNI_CreateJavaVM again return JNI_ENOMEM; &#125; // Enable guard page *after* os::create_main_thread(), otherwise it would // crash Linux VM, see notes in os_linux.cpp. main_thread-&gt;create_stack_guard_pages(); // Initialize Java-Level synchronization subsystem ObjectMonitor::Initialize() ; // Second phase of bootstrapping, VM is about entering multi-thread mode MemTracker::bootstrap_multi_thread(); // Initialize global modules // ======================================== // IMPORTANT!!! 初始化全局模块 // ======================================== jint status = init_globals(); if (status != JNI_OK) &#123; delete main_thread; *canTryAgain = false; // don't let caller call JNI_CreateJavaVM again return status; &#125; // Should be done after the heap is fully created main_thread-&gt;cache_global_variables(); HandleMark hm; &#123; MutexLocker mu(Threads_lock); Threads::add(main_thread); &#125; // Any JVMTI raw monitors entered in onload will transition into // real raw monitor. VM is setup enough here for raw monitor enter. JvmtiExport::transition_pending_onload_raw_monitors(); // Fully start NMT MemTracker::start(); // Create the VMThread &#123; TraceTime timer("Start VMThread", TraceStartupTime); VMThread::create(); Thread* vmthread = VMThread::vm_thread(); if (!os::create_thread(vmthread, os::vm_thread)) vm_exit_during_initialization("Cannot create VM thread. Out of system resources."); // Wait for the VM thread to become ready, and VMThread::run to initialize // Monitors can have spurious returns, must always check another state flag &#123; MutexLocker ml(Notify_lock); os::start_thread(vmthread); while (vmthread-&gt;active_handles() == NULL) &#123; Notify_lock-&gt;wait(); &#125; &#125; &#125; assert (Universe::is_fully_initialized(), "not initialized"); if (VerifyBeforeGC &amp;&amp; VerifyGCStartAt == 0) &#123; Universe::heap()-&gt;prepare_for_verify(); Universe::verify(); // make sure we're starting with a clean slate &#125; EXCEPTION_MARK; // At this point, the Universe is initialized, but we have not executed // any byte code. Now is a good time (the only time) to dump out the // internal state of the JVM for sharing. if (DumpSharedSpaces) &#123; Universe::heap()-&gt;preload_and_dump(CHECK_0); ShouldNotReachHere(); &#125; // Always call even when there are not JVMTI environments yet, since environments // may be attached late and JVMTI must track phases of VM execution JvmtiExport::enter_start_phase(); // Notify JVMTI agents that VM has started (JNI is up) - nop if no agents. JvmtiExport::post_vm_start(); &#123; TraceTime timer("Initialize java.lang classes", TraceStartupTime); if (EagerXrunInit &amp;&amp; Arguments::init_libraries_at_startup()) &#123; create_vm_init_libraries(); &#125; if (InitializeJavaLangString) &#123; initialize_class(vmSymbols::java_lang_String(), CHECK_0); &#125; else &#123; warning("java.lang.String not initialized"); &#125; // Initialize java_lang.System (needed before creating the thread) if (InitializeJavaLangSystem) &#123; initialize_class(vmSymbols::java_lang_System(), CHECK_0); initialize_class(vmSymbols::java_lang_ThreadGroup(), CHECK_0); Handle thread_group = create_initial_thread_group(CHECK_0); Universe::set_main_thread_group(thread_group()); initialize_class(vmSymbols::java_lang_Thread(), CHECK_0); oop thread_object = create_initial_thread(thread_group, main_thread, CHECK_0); main_thread-&gt;set_threadObj(thread_object); // Set thread status to running since main thread has // been started and running. java_lang_Thread::set_thread_status(thread_object, java_lang_Thread::RUNNABLE); // The VM preresolve methods to these classes. Make sure that get initialized initialize_class(vmSymbols::java_lang_reflect_Method(), CHECK_0); initialize_class(vmSymbols::java_lang_ref_Finalizer(), CHECK_0); // The VM creates &amp; returns objects of this class. Make sure it's initialized. initialize_class(vmSymbols::java_lang_Class(), CHECK_0); call_initializeSystemClass(CHECK_0); // get the Java runtime name after java.lang.System is initialized JDK_Version::set_runtime_name(get_java_runtime_name(THREAD)); JDK_Version::set_runtime_version(get_java_runtime_version(THREAD)); &#125; else &#123; warning("java.lang.System not initialized"); &#125; // an instance of OutOfMemory exception has been allocated earlier if (InitializeJavaLangExceptionsErrors) &#123; initialize_class(vmSymbols::java_lang_OutOfMemoryError(), CHECK_0); initialize_class(vmSymbols::java_lang_NullPointerException(), CHECK_0); initialize_class(vmSymbols::java_lang_ClassCastException(), CHECK_0); initialize_class(vmSymbols::java_lang_ArrayStoreException(), CHECK_0); initialize_class(vmSymbols::java_lang_ArithmeticException(), CHECK_0); initialize_class(vmSymbols::java_lang_StackOverflowError(), CHECK_0); initialize_class(vmSymbols::java_lang_IllegalMonitorStateException(), CHECK_0); initialize_class(vmSymbols::java_lang_IllegalArgumentException(), CHECK_0); &#125; else &#123; warning("java.lang.OutOfMemoryError has not been initialized"); warning("java.lang.NullPointerException has not been initialized"); warning("java.lang.ClassCastException has not been initialized"); warning("java.lang.ArrayStoreException has not been initialized"); warning("java.lang.ArithmeticException has not been initialized"); warning("java.lang.StackOverflowError has not been initialized"); warning("java.lang.IllegalArgumentException has not been initialized"); &#125; &#125; initialize_class(vmSymbols::java_lang_Compiler(), CHECK_0); reset_vm_info_property(CHECK_0); quicken_jni_functions(); // Must be run after init_ft which initializes ft_enabled if (TRACE_INITIALIZE() != JNI_OK) &#123; vm_exit_during_initialization("Failed to initialize tracing backend"); &#125; // Set flag that basic initialization has completed. Used by exceptions and various // debug stuff, that does not work until all basic classes have been initialized. set_init_completed();#ifndef USDT2 HS_DTRACE_PROBE(hotspot, vm__init__end);#else /* USDT2 */ HOTSPOT_VM_INIT_END();#endif /* USDT2 */ // record VM initialization completion time // 向VM管理模块发送初始化完成信号 Management::record_vm_init_completed(); // Compute system loader. Note that this has to occur after set_init_completed, since // valid exceptions may be thrown in the process. // Note that we do not use CHECK_0 here since we are inside an EXCEPTION_MARK and // set_init_completed has just been called, causing exceptions not to be shortcut // anymore. We call vm_exit_during_initialization directly instead. // 载入classloader SystemDictionary::compute_java_system_loader(THREAD); if (HAS_PENDING_EXCEPTION) &#123; vm_exit_during_initialization(Handle(THREAD, PENDING_EXCEPTION)); &#125;#ifndef SERIALGC // Support for ConcurrentMarkSweep. This should be cleaned up // and better encapsulated. The ugly nested if test would go away // once things are properly refactored. XXX YSR if (UseConcMarkSweepGC || UseG1GC) &#123; if (UseConcMarkSweepGC) &#123; ConcurrentMarkSweepThread::makeSurrogateLockerThread(THREAD); &#125; else &#123; ConcurrentMarkThread::makeSurrogateLockerThread(THREAD); &#125; if (HAS_PENDING_EXCEPTION) &#123; vm_exit_during_initialization(Handle(THREAD, PENDING_EXCEPTION)); &#125; &#125;#endif // SERIALGC // Always call even when there are not JVMTI environments yet, since environments // may be attached late and JVMTI must track phases of VM execution JvmtiExport::enter_live_phase(); // Signal Dispatcher needs to be started before VMInit event is posted // 启动一个叫做“信号分发器”的线程用来处理进程间的信号 // 比如通过jstack获取一个jvm实例的栈信息 os::signal_init(); // Start Attach Listener if +StartAttachListener or it can't be started lazily if (!DisableAttachMechanism) &#123; AttachListener::vm_start(); if (StartAttachListener || AttachListener::init_at_startup()) &#123; AttachListener::init(); &#125; &#125; // Launch -Xrun agents // Must be done in the JVMTI live phase so that for backward compatibility the JDWP // back-end can launch with -Xdebug -Xrunjdwp. if (!EagerXrunInit &amp;&amp; Arguments::init_libraries_at_startup()) &#123; create_vm_init_libraries(); &#125; // Notify JVMTI agents that VM initialization is complete - nop if no agents. JvmtiExport::post_vm_initialized(); if (TRACE_START() != JNI_OK) &#123; vm_exit_during_initialization("Failed to start tracing backend."); &#125; if (CleanChunkPoolAsync) &#123; Chunk::start_chunk_pool_cleaner_task(); &#125; // initialize compiler(s) CompileBroker::compilation_init(); // 加载sun.management.Agent类并调用startAgent方法开启管理服务 Management::initialize(THREAD); if (HAS_PENDING_EXCEPTION) &#123; // management agent fails to start possibly due to // configuration problem and is responsible for printing // stack trace if appropriate. Simply exit VM. vm_exit(1); &#125; if (Arguments::has_profile()) FlatProfiler::engage(main_thread, true); if (Arguments::has_alloc_profile()) AllocationProfiler::engage(); if (MemProfiling) MemProfiler::engage(); StatSampler::engage(); if (CheckJNICalls) JniPeriodicChecker::engage(); BiasedLocking::init(); if (JDK_Version::current().post_vm_init_hook_enabled()) &#123; call_postVMInitHook(THREAD); // The Java side of PostVMInitHook.run must deal with all // exceptions and provide means of diagnosis. if (HAS_PENDING_EXCEPTION) &#123; CLEAR_PENDING_EXCEPTION; &#125; &#125; &#123; MutexLockerEx ml(PeriodicTask_lock, Mutex::_no_safepoint_check_flag); // Make sure the watcher thread can be started by WatcherThread::start() // or by dynamic enrollment. WatcherThread::make_startable(); // Start up the WatcherThread if there are any periodic tasks // NOTE: All PeriodicTasks should be registered by now. If they // aren't, late joiners might appear to start slowly (we might // take a while to process their first tick). if (PeriodicTask::num_tasks() &gt; 0) &#123; WatcherThread::start(); &#125; &#125; // Give os specific code one last chance to start os::init_3(); create_vm_timer.end(); return JNI_OK;&#125; 其中init_globals()方法位于hotspot/src/share/vm/runtime/init.cpp用来初始化全局模块:12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364jint init_globals() &#123; HandleMark hm; // 初始化各子系统的监控及管理服务 // JMX、线程和同步子系统、类加载子系统的监控和管理 management_init(); // 初始化字节码表，如istore、iload、iadd bytecodes_init(); // 类加载器初始化 classLoader_init(); // 代码缓存池初始化 codeCache_init(); // VM版本初始化 VM_Version_init(); // 系统初始化 os_init_globals(); stubRoutines_init1(); // ============================ // 初始化堆以及决定所使用GC策略 // ============================ jint status = universe_init(); // dependent on codeCache_init and // stubRoutines_init1 if (status != JNI_OK) return status; // 初始化解析器 interpreter_init(); // before any methods loaded invocationCounter_init(); // before any methods loaded // 初始化MarkSweep marksweep_init(); accessFlags_init(); // 初始化操作码模板表 templateTable_init(); InterfaceSupport_init(); SharedRuntime::generate_stubs(); // 初始化语法表及系统字典等 universe2_init(); // dependent on codeCache_init and stubRoutines_init1 // 初始化软引用时间戳表并设定软引用清除策略 referenceProcessor_init(); jni_handles_init(); // 代码数据结构的必要性检查（仅限debug版本） vmStructs_init(); vtableStubs_init(); InlineCacheBuffer_init(); // oracle编译器初始化（oracle编译器是一个编译器开关接口） compilerOracle_init(); // 初始化编译策略（根据启动参数决定编译策略） compilationPolicy_init(); compileBroker_init(); VMRegImpl::set_regName(); if (!universe_post_init()) &#123; return JNI_ERR; &#125; javaClasses_init(); // must happen after vtable initialization stubRoutines_init2(); // note: StubRoutines need 2-phase init // All the flags that get adjusted by VM_Version_init and os::init_2 // have been set so dump the flags now. if (PrintFlagsFinal) &#123; CommandLineFlags::printFlags(tty, false); &#125; return JNI_OK;&#125; 其中universe_init()方法位于hotspot/src/share/vm/memory/universe.cpp 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970jint universe_init() &#123; assert(!Universe::_fully_initialized, "called after initialize_vtables"); guarantee(1 &lt;&lt; LogHeapWordSize == sizeof(HeapWord), "LogHeapWordSize is incorrect."); guarantee(sizeof(oop) &gt;= sizeof(HeapWord), "HeapWord larger than oop?"); guarantee(sizeof(oop) % sizeof(HeapWord) == 0, "oop size is not not a multiple of HeapWord size"); TraceTime timer("Genesis", TraceStartupTime); GC_locker::lock(); // do not allow gc during bootstrapping JavaClasses::compute_hard_coded_offsets(); // Get map info from shared archive file. if (DumpSharedSpaces) UseSharedSpaces = false; FileMapInfo* mapinfo = NULL; if (UseSharedSpaces) &#123; mapinfo = NEW_C_HEAP_OBJ(FileMapInfo, mtInternal); memset(mapinfo, 0, sizeof(FileMapInfo)); // Open the shared archive file, read and validate the header. If // initialization files, shared spaces [UseSharedSpaces] are // disabled and the file is closed. if (mapinfo-&gt;initialize()) &#123; FileMapInfo::set_current_info(mapinfo); &#125; else &#123; assert(!mapinfo-&gt;is_open() &amp;&amp; !UseSharedSpaces, "archive file not closed or shared spaces not disabled."); &#125; &#125; //=================================== // 初始化堆 // 包括创建及初始化各分区代，设定空间比例大小，回收策略等 // 流程：根据启动参数决定使用的回收策略，初始化回收策略时会指定所使用的代规范， // 最后根据规范创建对应类型的回收堆。i.e. // arguments -&gt; policy -&gt; spec -&gt; heap //=================================== jint status = Universe::initialize_heap(); if (status != JNI_OK) &#123; return status; &#125; // We have a heap so create the methodOop caches before // CompactingPermGenGen::initialize_oops() tries to populate them. Universe::_finalizer_register_cache = new LatestMethodOopCache(); Universe::_loader_addClass_cache = new LatestMethodOopCache(); Universe::_pd_implies_cache = new LatestMethodOopCache(); Universe::_reflect_invoke_cache = new ActiveMethodOopsCache(); if (UseSharedSpaces) &#123; // Read the data structures supporting the shared spaces (shared // system dictionary, symbol table, etc.). After that, access to // the file (other than the mapped regions) is no longer needed, and // the file is closed. Closing the file does not affect the // currently mapped regions. CompactingPermGenGen::initialize_oops(); mapinfo-&gt;close(); &#125; else &#123; SymbolTable::create_table(); StringTable::create_table(); ClassLoader::create_package_info_table(); &#125; return JNI_OK;&#125; initialize_heap()方法如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128jint Universe::initialize_heap() &#123; // 如果使用并行GC if (UseParallelGC) &#123;#ifndef SERIALGC // 回收堆类型使用并行回收堆 Universe::_collectedHeap = new ParallelScavengeHeap();#else // SERIALGC fatal("UseParallelGC not supported in java kernel vm.");#endif // SERIALGC &#125; else if (UseG1GC) &#123;#ifndef SERIALGC // 如果使用G1回收，设定回收器策略和回收堆类型为G1CollectorPolicy和G1CollectedHeap G1CollectorPolicy* g1p = new G1CollectorPolicy(); G1CollectedHeap* g1h = new G1CollectedHeap(g1p); Universe::_collectedHeap = g1h;#else // SERIALGC fatal("UseG1GC not supported in java kernel vm.");#endif // SERIALGC &#125; else &#123; GenCollectorPolicy *gc_policy; // 使用串行回收 if (UseSerialGC) &#123; gc_policy = new MarkSweepPolicy(); // 使用并发回收 &#125; else if (UseConcMarkSweepGC) &#123;#ifndef SERIALGC // 是否使用自适应策略 // ASConcurrentMarkSweepPolicy继承自ConcurrentMarkSweepPolicy， if (UseAdaptiveSizePolicy) &#123; gc_policy = new ASConcurrentMarkSweepPolicy(); &#125; else &#123; gc_policy = new ConcurrentMarkSweepPolicy(); &#125;#else // SERIALGC fatal("UseConcMarkSweepGC not supported in java kernel vm.");#endif // SERIALGC // 默认使用标记清除算法 &#125; else &#123; // default old generation gc_policy = new MarkSweepPolicy(); &#125; // 回收策略类型体系图 // AllocatedObj // └── CHeapObj // └── CollectorPolicy // └── GenCollectorPolicy // └── TwoGenerationCollectorPolicy // └── ConcurrentMarkSweepPolicy // └── ASConcurrentMarkSweepPolicy Universe::_collectedHeap = new GenCollectedHeap(gc_policy); &#125; //=================================== // 初始化堆空间 // 这里调用GenCollectedHeap::initialize()方法， 真正向操作系统申请内存 //=================================== jint status = Universe::heap()-&gt;initialize(); if (status != JNI_OK) &#123; return status; &#125;#ifdef _LP64 // 在LP64数据模型下是否开启对象指针压缩 if (UseCompressedOops) &#123; // Subtract a page because something can get allocated at heap base. // This also makes implicit null checking work, because the // memory+1 page below heap_base needs to cause a signal. // See needs_explicit_null_check. // Only set the heap base for compressed oops because it indicates // compressed oops for pstack code. bool verbose = PrintCompressedOopsMode || (PrintMiscellaneous &amp;&amp; Verbose); if (verbose) &#123; tty-&gt;cr(); tty-&gt;print("heap address: " PTR_FORMAT ", size: " SIZE_FORMAT " MB", Universe::heap()-&gt;base(), Universe::heap()-&gt;reserved_region().byte_size()/M); &#125; if ((uint64_t)Universe::heap()-&gt;reserved_region().end() &gt; OopEncodingHeapMax) &#123; // Can't reserve heap below 32Gb. Universe::set_narrow_oop_base(Universe::heap()-&gt;base() - os::vm_page_size()); Universe::set_narrow_oop_shift(LogMinObjAlignmentInBytes); if (verbose) &#123; tty-&gt;print(", %s: "PTR_FORMAT, narrow_oop_mode_to_string(HeapBasedNarrowOop), Universe::narrow_oop_base()); &#125; &#125; else &#123; Universe::set_narrow_oop_base(0); if (verbose) &#123; tty-&gt;print(", %s", narrow_oop_mode_to_string(ZeroBasedNarrowOop)); &#125;#ifdef _WIN64 if (!Universe::narrow_oop_use_implicit_null_checks()) &#123; // Don't need guard page for implicit checks in indexed addressing // mode with zero based Compressed Oops. Universe::set_narrow_oop_use_implicit_null_checks(true); &#125;#endif // _WIN64 if((uint64_t)Universe::heap()-&gt;reserved_region().end() &gt; NarrowOopHeapMax) &#123; // Can't reserve heap below 4Gb. Universe::set_narrow_oop_shift(LogMinObjAlignmentInBytes); &#125; else &#123; Universe::set_narrow_oop_shift(0); if (verbose) &#123; tty-&gt;print(", %s", narrow_oop_mode_to_string(UnscaledNarrowOop)); &#125; &#125; &#125; if (verbose) &#123; tty-&gt;cr(); tty-&gt;cr(); &#125; &#125; assert(Universe::narrow_oop_base() == (Universe::heap()-&gt;base() - os::vm_page_size()) || Universe::narrow_oop_base() == NULL, "invalid value"); assert(Universe::narrow_oop_shift() == LogMinObjAlignmentInBytes || Universe::narrow_oop_shift() == 0, "invalid value");#endif // We will never reach the CATCH below since Exceptions::_throw will cause // the VM to exit if an exception is thrown during initialization // 如果使用TLAB则对其进行初始化 if (UseTLAB) &#123; assert(Universe::heap()-&gt;supports_tlab_allocation(), "Should support thread-local allocation buffers"); ThreadLocalAllocBuffer::startup_initialization(); &#125; return JNI_OK;&#125; 在上面的代码中Universe::heap()-&gt;initialize()会调用GenCollectedHeap的initialize()方法：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109jint GenCollectedHeap::initialize() &#123; CollectedHeap::pre_initialize(); int i; _n_gens = gen_policy()-&gt;number_of_generations(); // While there are no constraints in the GC code that HeapWordSize // be any particular value, there are multiple other areas in the // system which believe this to be true (e.g. oop-&gt;object_size in some // cases incorrectly returns the size in wordSize units rather than // HeapWordSize). guarantee(HeapWordSize == wordSize, "HeapWordSize must equal wordSize"); // The heap must be at least as aligned as generations. size_t alignment = Generation::GenGrain; _gen_specs = gen_policy()-&gt;generations(); PermanentGenerationSpec *perm_gen_spec = collector_policy()-&gt;permanent_generation(); // Make sure the sizes are all aligned. for (i = 0; i &lt; _n_gens; i++) &#123; _gen_specs[i]-&gt;align(alignment); &#125; perm_gen_spec-&gt;align(alignment); // If we are dumping the heap, then allocate a wasted block of address // space in order to push the heap to a lower address. This extra // address range allows for other (or larger) libraries to be loaded // without them occupying the space required for the shared spaces. if (DumpSharedSpaces) &#123; uintx reserved = 0; uintx block_size = 64*1024*1024; while (reserved &lt; SharedDummyBlockSize) &#123; char* dummy = os::reserve_memory(block_size); reserved += block_size; &#125; &#125; // Allocate space for the heap. char* heap_address; size_t total_reserved = 0; int n_covered_regions = 0; ReservedSpace heap_rs(0); //分配区域，三个区域:YoungGen,OldGen,PermGen heap_address = allocate(alignment, perm_gen_spec, &amp;total_reserved, &amp;n_covered_regions, &amp;heap_rs); if (UseSharedSpaces) &#123; if (!heap_rs.is_reserved() || heap_address != heap_rs.base()) &#123; if (heap_rs.is_reserved()) &#123; heap_rs.release(); &#125; FileMapInfo* mapinfo = FileMapInfo::current_info(); mapinfo-&gt;fail_continue("Unable to reserve shared region."); allocate(alignment, perm_gen_spec, &amp;total_reserved, &amp;n_covered_regions, &amp;heap_rs); &#125; &#125; if (!heap_rs.is_reserved()) &#123; vm_shutdown_during_initialization( "Could not reserve enough space for object heap"); return JNI_ENOMEM; &#125; //_reserved区域包括Y,O,P三个区域 _reserved = MemRegion((HeapWord*)heap_rs.base(), (HeapWord*)(heap_rs.base() + heap_rs.size())); // It is important to do this in a way such that concurrent readers can't // temporarily think somethings in the heap. (Seen this happen in asserts.) _reserved.set_word_size(0); _reserved.set_start((HeapWord*)heap_rs.base()); size_t actual_heap_size = heap_rs.size() - perm_gen_spec-&gt;misc_data_size() - perm_gen_spec-&gt;misc_code_size(); _reserved.set_end((HeapWord*)(heap_rs.base() + actual_heap_size)); _rem_set = collector_policy()-&gt;create_rem_set(_reserved, n_covered_regions); set_barrier_set(rem_set()-&gt;bs()); _gch = this; for (i = 0; i &lt; _n_gens; i++) &#123; ReservedSpace this_rs = heap_rs.first_part(_gen_specs[i]-&gt;max_size(), UseSharedSpaces, UseSharedSpaces); _gens[i] = _gen_specs[i]-&gt;init(this_rs, i, rem_set()); // tag generations in JavaHeap MemTracker::record_virtual_memory_type((address)this_rs.base(), mtJavaHeap); heap_rs = heap_rs.last_part(_gen_specs[i]-&gt;max_size()); &#125; _perm_gen = perm_gen_spec-&gt;init(heap_rs, PermSize, rem_set()); // tag PermGen MemTracker::record_virtual_memory_type((address)heap_rs.base(), mtJavaHeap); clear_incremental_collection_failed();#ifndef SERIALGC // If we are running CMS, create the collector responsible // for collecting the CMS generations. if (collector_policy()-&gt;is_concurrent_mark_sweep_policy()) &#123; bool success = create_cms_collector(); if (!success) return JNI_ENOMEM; &#125;#endif // SERIALGC return JNI_OK;&#125; 至此JVM的初始化全部完成，至于内存策略的计算部分详细内容请阅读Hotspot源码，这里只作抛砖引玉。]]></content>
      <categories>
        <category>OpenJDK</category>
      </categories>
      <tags>
        <tag>OpenJDK</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Hotspot源码分析】从HotSpot源码角度深入分析Java程序启动过程-创建]]></title>
    <url>%2Fpost%2F2014%2F12%2F01%2Fanalyse-jvm-startup-flow-through-source-code-create%2F</url>
    <content type="text"><![CDATA[博主在11年到12年的时候曾连续研究过十个月的JVM，读过的相关书籍包括： 深入Java虚拟机这本书可以说是介绍JVM内部原理的鼻祖了，于2003年出版现已绝版，不过可以再某宝买到影印版。虽然当时JDK最高仅为1.4但JVM内部的构造已大体形成，所以博主强烈推荐此书。p.s 我肯定不会告诉你这书博主看了3遍：D 深入理解Java虚拟机国内周某人写的，鉴于博主对于国人写的书向来不怎么感兴趣还是不提了。 说起JVM它可以是以下三种： 一个正在运行的Java实例 Java虚拟机规范 一种JVM虚拟机实现 之前的研究基本上都是虚拟机规范和JVM参数调优层面的内容，但是总觉得有些意犹未尽所以决定深入研究一下Hotspot实现，由大部分C/C++和少量汇编代码构成，但清晰的结构和优雅的编码使其并不难读，不得不赞叹一句SUN的大师们的智慧。至于如何编译、调试OpenJDK&amp;Hotspot博主在前面的文章已经介绍过，这里便不再赘述，所以直入主题。 让我们从Java程序主入口开始逐步分析，主入口文件位于 hotspot/src/share/tools/launcher/java.c main方法内容如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473/* * Entry point. * JAVA程序主入口 */intmain(int argc, char ** argv)&#123; char *jarfile = 0; char *classname = 0; char *s = 0; char *main_class = NULL; int ret; InvocationFunctions ifn; jlong start, end; char jrepath[MAXPATHLEN], jvmpath[MAXPATHLEN]; char ** original_argv = argv; if (getenv("_JAVA_LAUNCHER_DEBUG") != 0) &#123; _launcher_debug = JNI_TRUE; printf("----_JAVA_LAUNCHER_DEBUG----\n"); &#125;#ifndef GAMMA // 确保指定的版本正在运行 SelectVersion(argc, argv, &amp;main_class);#endif /* ifndef GAMMA */ /* copy original argv */ &#123; int i; original_argv = (char**)JLI_MemAlloc(sizeof(char*)*(argc+1)); for(i = 0; i &lt; argc+1; i++) original_argv[i] = argv[i]; &#125; // 创建运行环境，如检查系统使用的数据模型（32bit、64bit），获取使用的JRE路径，找到jvm.cfg解析已知的vm类型 // 设置新的LD_LIBRARY_PATH变量 CreateExecutionEnvironment(&amp;argc, &amp;argv, jrepath, sizeof(jrepath), jvmpath, sizeof(jvmpath), original_argv); printf("Using java runtime at: %s\n", jrepath); ifn.CreateJavaVM = 0; ifn.GetDefaultJavaVMInitArgs = 0; if (_launcher_debug) start = CounterGet(); // 通过jvmpath找到libjvm.so 并将其JNI_CreateJavaVM和JNI_GetDefaultJavaVMInitArgs方法的 // 符号地址返回，挂载到InvocationFunctions的CreateJavaVM和GetDefaultJavaVMInitArgs以便初始化调用 if (!LoadJavaVM(jvmpath, &amp;ifn)) &#123; exit(6); &#125; if (_launcher_debug) &#123; end = CounterGet(); printf("%ld micro seconds to LoadJavaVM\n", (long)(jint)Counter2Micros(end-start)); &#125;#ifdef JAVA_ARGS /* javac, jar and friends. */ progname = "java";#else /* java, oldjava, javaw and friends */#ifdef PROGNAME progname = PROGNAME;#else progname = *argv; if ((s = strrchr(progname, FILE_SEPARATOR)) != 0) &#123; progname = s + 1; &#125;#endif /* PROGNAME */#endif /* JAVA_ARGS */ ++argv; --argc;#ifdef JAVA_ARGS // 转换命令行参数 如：javac -cp foo:foo/"*" -J-ms32m /* Preprocess wrapper arguments */ TranslateApplicationArgs(&amp;argc, &amp;argv); /** * 添加了三个VM选项 * -Denv.class.patp 用户设置的CLASSPATH变量，如果CLASSPATH显式设置了tools.jar * 则可以反编译VM的工具类sun.tools.* * -Dapplication.home 应用程序目录 * -Djava.class.path 应用程序的类文件目录 */ if (!AddApplicationOptions()) &#123; exit(1); &#125;#endif /* Set default CLASSPATH */ if ((s = getenv("CLASSPATH")) == 0) &#123; s = "."; &#125;#ifndef JAVA_ARGS SetClassPath(s);#endif /* * 解析命令行参数-cp、-version、-*path、-X*等参数 * Parse command line options; if the return value of * ParseArguments is false, the program should exit. */ if (!ParseArguments(&amp;argc, &amp;argv, &amp;jarfile, &amp;classname, &amp;ret, jvmpath)) &#123; exit(ret); &#125; /* Override class path if -jar flag was specified */ if (jarfile != 0) &#123; SetClassPath(jarfile); &#125; /* set the -Dsun.java.command pseudo property */ SetJavaCommandLineProp(classname, jarfile, argc, argv); /* Set the -Dsun.java.launcher pseudo property */ SetJavaLauncherProp(); /* set the -Dsun.java.launcher.* platform properties */ SetJavaLauncherPlatformProps();#ifndef GAMMA /* Show the splash screen if needed */ ShowSplashScreen();#endif /* * 移除环境变量防止重复执行 * Done with all command line processing and potential re-execs so * clean up the environment. */ (void)UnsetEnv(ENV_ENTRY);#ifndef GAMMA (void)UnsetEnv(SPLASH_FILE_ENV_ENTRY); (void)UnsetEnv(SPLASH_JAR_ENV_ENTRY); JLI_MemFree(splash_jar_entry); JLI_MemFree(splash_file_entry);#endif /* * 指定线程大小 * If user doesn't specify stack size, check if VM has a preference. * Note that HotSpot no longer supports JNI_VERSION_1_1 but it will * return its default stack size through the init args structure. */ if (threadStackSize == 0) &#123; struct JDK1_1InitArgs args1_1; memset((void*)&amp;args1_1, 0, sizeof(args1_1)); args1_1.version = JNI_VERSION_1_1; ifn.GetDefaultJavaVMInitArgs(&amp;args1_1); /* ignore return value */ if (args1_1.javaStackSize &gt; 0) &#123; threadStackSize = args1_1.javaStackSize; &#125; &#125; &#123; /* Create a new thread to create JVM and invoke main method */ struct JavaMainArgs args; args.argc = argc; args.argv = argv; args.jarfile = jarfile; args.classname = classname; args.ifn = ifn; // block当前线程并且在新线程中继续执行 // 至于为什么在新线程中创建JVM见如下注释引用或原文https://bugs.openjdk.java.net/browse/JDK-6316197// Primordial thread is created by the kernel before any program/library code// has a chance to run. It's stack size and location can be very different// from other threads created by the application. Creating JVM from primordial// thread and later running Java code in the primordial thread introduced// many problems://// 1. On Windows primordial thread stack size is controlled by PE header in// the executable. There is no way for user to change it dynamically, which// means -Xss does not work for primordial thread.//// 2. On Solaris/Linux, primordial thread stack size is controlled by ulimit -s,// which is usually very large (8M). To compensate for that we set guard// page in the middle of stack to artificially reduce the stack size. However,// this may interfere with native applications.//// 3. Setting guard page for primordial thread is dangerous. Unlike other// threads, primordial thread stack can grow on demand. getrlimit()// tells VM the ulimit value which is the upper limit but not necessarily// the actual stack size. What could happen is that VM sets up the guard// at the theoretical limit, but because the program doesn't really use// that much stack, the unused space is reused for other purposes (e.g. malloc)// by the OS (this reuse won't occur with other threads). We ended up having// some C heap inserted between stack and its guard page.//// 4. On Linux VM bangs stack address below current SP to check for stack overflows.// This will trigger SEGV's if it happens in primordial thread due to a security// feature built into the kernel. Linux VM gets around the problem by manually// expanding the stack. However when VM is expanding the stack, for a very short// period the available stack space will be reduced to just 1 page. If a signal// is delivered in that window, VM could end up without space to handle the signal.//// 5. Some Linux kernel randomizes the starting stack address for primordial thread// both for stack coloring and exec-shield, but it won't tell the application.// This makes it impossible to reliably detect stack location and size in primordial// thread. VM needs the information to correctly handle stack overflows. We do// have some cushion which is enough most of the time, but as shown in bug reports// people do hit crashes because of this.//// 6. On Linux there is no thr_main() equivalent that can tell if current thread// is primordial thread, makes it even harder to have special code to handle// primordial thread.//// I'm sure there are other issues that I didn't cover in the list. Basically// primordial thread has been a constant source of runtime bugs.//// This proposal calls for java launcher to stop calling JNI_CreateJavaVM from// primordial thread. Instead, it can create a new thread and move all invocation// code to the new thread. Primordial thread simply waits for the new thread// to return and then it can terminate the process with the same exit value returned// by the new thread. With this change we won't see any of the above problems// as long as the application is started by a standard Sun launcher.//// The above mentioned will still exist if VM is invoked from natvie application.// Which means we have to keep all current VM workarounds for primordial thread,// and probably need to add more. But reliability wise this is still significantly// better as most people are using standard launcher. Also, unlike standard java// launcher, customers have full control of native launcher. For example, if they// wish to use larger stack on Windows, they could simply rebuild their launcher// with larger stack size. return ContinueInNewThread(JavaMain, threadStackSize, (void*)&amp;args); &#125;&#125;int JNICALLJavaMain(void * _args)&#123; struct JavaMainArgs *args = (struct JavaMainArgs *)_args; int argc = args-&gt;argc; char **argv = args-&gt;argv; char *jarfile = args-&gt;jarfile; char *classname = args-&gt;classname; InvocationFunctions ifn = args-&gt;ifn; JavaVM *vm = 0; JNIEnv *env = 0; jstring mainClassName; jclass mainClass; jmethodID mainID; jobjectArray mainArgs; int ret = 0; jlong start, end; /* * Error message to print or display; by default the message will * only be displayed in a window. */ char * message = "Fatal exception occurred. Program will exit."; jboolean messageDest = JNI_FALSE; /* Initialize the virtual machine */ if (_launcher_debug) start = CounterGet(); // ================================ // 开始进行虚拟机初始化，此方法内部调用了JNI_CreateJavaVM， // 这里做的事情非常之多，也是JVM启动的精华部分 // 由于这部分内容甚多，所以在下篇文章中介绍 // ================================ if (!InitializeJVM(&amp;vm, &amp;env, &amp;ifn)) &#123; ReportErrorMessage("Could not create the Java virtual machine.", JNI_TRUE); exit(1); &#125; // 如果输入了-version或-showversion参数 if (printVersion || showVersion) &#123; PrintJavaVersion(env); if ((*env)-&gt;ExceptionOccurred(env)) &#123; ReportExceptionDescription(env); goto leave; &#125; if (printVersion) &#123; ret = 0; message = NULL; goto leave; &#125; if (showVersion) &#123; fprintf(stderr, "\n"); &#125; &#125; // 如果jar文件和类名均未指定则输出默认usage信息 /* If the user specified neither a class name nor a JAR file */ if (jarfile == 0 &amp;&amp; classname == 0) &#123; PrintUsage(); message = NULL; goto leave; &#125;#ifndef GAMMA FreeKnownVMs(); /* after last possible PrintUsage() */#endif if (_launcher_debug) &#123; end = CounterGet(); printf("%ld micro seconds to InitializeJVM\n", (long)(jint)Counter2Micros(end-start)); &#125; /* At this stage, argc/argv have the applications' arguments */ if (_launcher_debug) &#123; int i = 0; printf("Main-Class is '%s'\n", classname ? classname : ""); printf("Apps' argc is %d\n", argc); for (; i &lt; argc; i++) &#123; printf(" argv[%2d] = '%s'\n", i, argv[i]); &#125; &#125; ret = 1; /* * 获取应用程序的主类文件 */ // 解析jar包并加载主类文件 if (jarfile != 0) &#123; // 如果传入的是jar文件名称则通过调用java.util.jar.JarFile加载jar包并获取主类 mainClassName = GetMainClassName(env, jarfile); if ((*env)-&gt;ExceptionOccurred(env)) &#123; ReportExceptionDescription(env); goto leave; &#125; if (mainClassName == NULL) &#123; const char * format = "Failed to load Main-Class manifest " "attribute from\n%s"; message = (char*)JLI_MemAlloc((strlen(format) + strlen(jarfile)) * sizeof(char)); sprintf(message, format, jarfile); messageDest = JNI_TRUE; goto leave; &#125; classname = (char *)(*env)-&gt;GetStringUTFChars(env, mainClassName, 0); if (classname == NULL) &#123; ReportExceptionDescription(env); goto leave; &#125; // 加载mainClass mainClass = LoadClass(env, classname); if(mainClass == NULL) &#123; /* exception occured */ const char * format = "Could not find the main class: %s. Program will exit."; ReportExceptionDescription(env); message = (char *)JLI_MemAlloc((strlen(format) + strlen(classname)) * sizeof(char) ); messageDest = JNI_TRUE; sprintf(message, format, classname); goto leave; &#125; (*env)-&gt;ReleaseStringUTFChars(env, mainClassName, classname); &#125; else &#123; // 加载主类文件 mainClassName = NewPlatformString(env, classname); if (mainClassName == NULL) &#123; const char * format = "Failed to load Main Class: %s"; message = (char *)JLI_MemAlloc((strlen(format) + strlen(classname)) * sizeof(char) ); sprintf(message, format, classname); messageDest = JNI_TRUE; goto leave; &#125; classname = (char *)(*env)-&gt;GetStringUTFChars(env, mainClassName, 0); if (classname == NULL) &#123; ReportExceptionDescription(env); goto leave; &#125; mainClass = LoadClass(env, classname); if(mainClass == NULL) &#123; /* exception occured */ const char * format = "Could not find the main class: %s. Program will exit."; ReportExceptionDescription(env); message = (char *)JLI_MemAlloc((strlen(format) + strlen(classname)) * sizeof(char) ); messageDest = JNI_TRUE; sprintf(message, format, classname); goto leave; &#125; (*env)-&gt;ReleaseStringUTFChars(env, mainClassName, classname); &#125; // 获得主方法的ID mainID = (*env)-&gt;GetStaticMethodID(env, mainClass, "main", "([Ljava/lang/String;)V"); if (mainID == NULL) &#123; if ((*env)-&gt;ExceptionOccurred(env)) &#123; ReportExceptionDescription(env); &#125; else &#123; message = "No main method found in specified class."; messageDest = JNI_TRUE; &#125; goto leave; &#125; &#123; /* Make sure the main method is public */ jint mods; jmethodID mid; // 通过反射获得main方法修饰符 jobject obj = (*env)-&gt;ToReflectedMethod(env, mainClass, mainID, JNI_TRUE); if( obj == NULL) &#123; /* exception occurred */ ReportExceptionDescription(env); goto leave; &#125; mid = (*env)-&gt;GetMethodID(env, (*env)-&gt;GetObjectClass(env, obj), "getModifiers", "()I"); if ((*env)-&gt;ExceptionOccurred(env)) &#123; ReportExceptionDescription(env); goto leave; &#125; // 确保是public类型 mods = (*env)-&gt;CallIntMethod(env, obj, mid); if ((mods &amp; 1) == 0) &#123; /* if (!Modifier.isPublic(mods)) ... */ message = "Main method not public."; messageDest = JNI_TRUE; goto leave; &#125; &#125; // 构建参数数组 mainArgs = NewPlatformStringArray(env, argv, argc); if (mainArgs == NULL) &#123; ReportExceptionDescription(env); goto leave; &#125; // 调用main方法 /* Invoke main method. */ (*env)-&gt;CallStaticVoidMethod(env, mainClass, mainID, mainArgs); /* * The launcher's exit code (in the absence of calls to * System.exit) will be non-zero if main threw an exception. */ ret = (*env)-&gt;ExceptionOccurred(env) == NULL ? 0 : 1; /* * Detach the main thread so that it appears to have ended when * the application's main method exits. This will invoke the * uncaught exception handler machinery if main threw an * exception. An uncaught exception handler cannot change the * launcher's return code except by calling System.exit. */ if ((*vm)-&gt;DetachCurrentThread(vm) != 0) &#123; message = "Could not detach main thread."; messageDest = JNI_TRUE; ret = 1; goto leave; &#125; message = NULL; leave: /* * Wait for all non-daemon threads to end, then destroy the VM. * This will actually create a trivial new Java waiter thread * named "DestroyJavaVM", but this will be seen as a different * thread from the one that executed main, even though they are * the same C thread. This allows mainThread.join() and * mainThread.isAlive() to work as expected. */ (*vm)-&gt;DestroyJavaVM(vm); if(message != NULL &amp;&amp; !noExitErrorMessage) ReportErrorMessage(message, messageDest); return ret;&#125; 下篇文章将介绍JVM初始化部分。]]></content>
      <categories>
        <category>OpenJDK</category>
      </categories>
      <tags>
        <tag>OpenJDK</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在Linux下搭建OpenJDK7源码调试环境]]></title>
    <url>%2Fpost%2F2014%2F11%2F19%2Fbuild-hotspot-jvm-debug-environment-on-linux%2F</url>
    <content type="text"><![CDATA[在前面的文章中博主已经介绍过如何在Linux下编译OpenJDK7源码，现继续介绍如何在Linux下搭建基于eclipse IDE的Hotspot源码调试环境。鉴于网上关于JVM源码调试方面的文章寥寥无几并且内容参差不全，本文将把博主摸索数天的经验及成果以图文形式详细介绍Hotspot的debug过程。 软件环境 OS：CentOS 6.5 OpenJDK: OpenJDK-7u40 JDK Version：openjdk-7u40-fcs-src-b43-26_aug_2013 IDE：eclipse-cpp-luna-SR1-linux-gtk-x86_64 导入源码首先解压JDK源码包至/usr/local目录，然后启动eclipse，依次选择File &gt; New &gt; Makefile Project with Existing Code(如果没有则在Other里找) 配置环境变量定位到项目名右键 &gt; Properties &gt;C/C++ Build需要修改两个地方： 将Builder里Use default build command的对勾去掉，填入参数ARCH_DATA_MODEL=64 将Build location的Build directory追加上/make，最终是${workspace_lc:/hotspot}/make，目的是告诉make编译器到该目录下寻找编译文件Makefile。 开始编译选择菜单栏Project &gt; Build Project，如果运气不差的话会看到已经开始build了，沏杯咖啡慢慢等吧（首次build大概需要10-20m）。 部分LOG信息： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546make[4]: Entering directory `/usr/local/openjdk/hotspot/build/linux/linux_amd64_compiler2/fastdebug'echo "**NOTICE** Dtrace support disabled: "/usr/include/sys/sdt.h not found""**NOTICE** Dtrace support disabled: /usr/include/sys/sdt.h not foundmake[4]: Leaving directory `/usr/local/openjdk/hotspot/build/linux/linux_amd64_compiler2/fastdebug'All done.make[3]: Leaving directory `/usr/local/openjdk/hotspot/build/linux/linux_amd64_compiler2/fastdebug'cd linux_amd64_compiler2/fastdebug &amp;&amp; ./test_gammajava version "1.7.0_67"Java(TM) SE Runtime Environment (build 1.7.0_67-b01)OpenJDK 64-Bit Server VM (build 24.0-b56-internal-fastdebug, mixed mode) 1. A1 B5 C8 D6 E3 F7 G2 H4 2. A1 B6 C8 D3 E7 F4 G2 H5 3. A1 B7 C4 D6 E8 F2 G5 H3 4. A1 B7 C5 D8 E2 F4 G6 H3 5. A2 B4 C6 D8 E3 F1 G7 H5 6. A2 B5 C7 D1 E3 F8 G6 H4 -- 此处略去N行------ Using java runtime at: /usr/java/jdk1.7.0_67/jremake[2]: Leaving directory `/usr/local/openjdk/hotspot/build/linux'make[1]: Leaving directory `/usr/local/openjdk/hotspot/make'cd /usr/local/openjdk/hotspot/make; \ make BUILD_FLAVOR=fastdebug VM_TARGET=fastdebug1 generic_build1 INFO: ENABLE_FULL_DEBUG_SYMBOLS=1INFO: /usr/bin/objcopy cmd found so will create .debuginfo files.INFO: STRIP_POLICY=min_stripINFO: ZIP_DEBUGINFO_FILES=1make[1]: Entering directory `/usr/local/openjdk/hotspot/make'mkdir -p /usr/local/openjdk/hotspot/build/linuxNo compiler1 (fastdebug1) for ARCH_DATA_MODEL=64make[1]: Leaving directory `/usr/local/openjdk/hotspot/make'make BUILD_FLAVOR=fastdebug VM_SUBDIR=fastdebug \ EXPORT_SUBDIR=/fastdebug \ generic_exportINFO: ENABLE_FULL_DEBUG_SYMBOLS=1INFO: /usr/bin/objcopy cmd found so will create .debuginfo files.INFO: STRIP_POLICY=min_stripINFO: ZIP_DEBUGINFO_FILES=1make[1]: Entering directory `/usr/local/openjdk/hotspot/make'make[1]: Nothing to be done for `generic_export'.make[1]: Leaving directory `/usr/local/openjdk/hotspot/make'16:02:09 Build Finished (took 8s.216ms) 配置DEBUG环境 编译成功之后就可以测试了，需配置如下几步点选菜单栏Run &gt; Debug Configurations &gt; New launch configuration，在C/C++ Application里填入/usr/local/openjdk/hotspot/build/linux/linux_amd64_compiler2/fastdebug/gamma，Project选择当前项目。 在Argument tab页里Program arguments填入-version 在Environment tab页里Environment variables to set填入JAVA_HOME | /usr/java/jdk1.7.0.67 在Common tab页里勾选Debug 进入调试模式配置完毕后，点击Debug即可进入调试模式，Hotspot内部一览无余，]]></content>
      <categories>
        <category>OpenJDK</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>CentOS</tag>
        <tag>OpenJDK</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在Linux上编译OpenJDK7源码]]></title>
    <url>%2Fpost%2F2014%2F11%2F08%2Fcompile-jdk7-source-code-on-centos%2F</url>
    <content type="text"><![CDATA[软件环境 OS：CentOS 6.5 JDK: OpenJDK-7u40 准备工作下载源码包OpenJDK Source Releases 解压源码包1# unzip openjdk-7u40-fcs-src-b43-26_aug_2013.zip hotspot 虚拟机实现，大部分是C/C++代码 jdk Java核心类库目录，位于 jdk/src/share/classes langtools 一些编译工具 安装依赖1yum -y install gcc gcc-c++ alsa-lib alsa-lib-devel libXrender libXrender-devel libXi-devel libXt-devel libXtst-devel cups cups-devel 安装freetype1# ./configure &amp;&amp; make &amp;&amp; make install 安装Ant1ln -s /usr/local/apache-ant-1.9.4/bin/ant /usr/bin/ant 安装JDK（如果已有则不必重新安装）Sun JDK或Open JDK均可，过程略. 环境配置编辑文件vim ~/.bash_profile加入以下变量 1234567891011export LANG=&quot;C&quot;export ALT_BOOTDIR=&quot;/usr/java/jdk1.7.0_67/&quot;export ANT_HOME=&quot;/usr/local/apache-ant-1.9.4&quot;export ALT_FREETYPE_HEADERS_PATH=&quot;/usr/local/include/freetype2&quot;export ALT_FREETYPE_LIB_PATH=&quot;/usr/local/lib&quot;export ALLOW_DOWNLOADS=trueexport SKIP_DEBUG_BUILD=falseexport SKIP_FASTDEBUG_BUILD=trueexport DEBUG_NAME=debugunset JAVA_HOMEunset CLASSPATH 使变量生效1# source ~/.bash_profile 编译源码测试环境是否健全1# make sanity 如果输出以下内容则表示通过，可以进行编译。1Sanity check passed. 开始编译1# make ARCH_DATA_MODEL=64 看到如下输出则为编译成功12345678910111213141516171819202122&gt;&gt;&gt;Finished making images @ Sat Nov 8 00:45:16 EST 2014 ...make[2]: Leaving directory `/usr/local/openjdk/jdk/make&apos;############################################################################# Leaving jdk for target(s) sanity all docs images ################################################################################## Build time 00:10:15 jdk for target(s) sanity all docs images ##############################################################################-- Build times ----------Target debug_buildStart 2014-11-08 00:26:41End 2014-11-08 00:45:1600:02:11 corba00:04:36 hotspot00:00:24 jaxp00:00:30 jaxws00:10:15 jdk00:00:39 langtools00:18:35 TOTAL-------------------------make[1]: Leaving directory `/usr/local/openjdk&apos;[root@BobServerStation openjdk]# 测试验证一个测试类123456789/*** Author: HunterZhao* Date: 2014-11-08*/public class Test&#123; public static void main(String[] args)&#123; System.out.println("Hello OpenJDK~"); &#125;&#125; 使用刚生成的JDK编译1# ./build/linux-amd64/bin/javac Test.java 在当前目录下会生成Test.class文件，然后运行便会看到输出。12# ./build/linux-amd64/bin/java TestHello OpenJDK~ 另一个测试类进入目录jdk/src/share/classes/java/io，然后修改PrintStream.java 12345678910111213141516/** * Prints a string. If the argument is &lt;code&gt;null&lt;/code&gt; then the string * &lt;code&gt;"null"&lt;/code&gt; is printed. Otherwise, the string's characters are * converted into bytes according to the platform's default character * encoding, and these bytes are written in exactly the manner of the * &lt;code&gt;&#123;@link #write(int)&#125;&lt;/code&gt; method. * * @param s The &lt;code&gt;String&lt;/code&gt; to be printed */ public void print(String s) &#123; if (s == null) &#123; s = "null"; &#125; s = s + " This is OpenJdk7 compiled by Bob.Z!!!"; // 重新赋值 write(s); &#125; 接下来重新编译JDK，重新编译刚才的Test.java文件并运行会看到如下输出： Enjoy them~ Reference OpenJDK: https://jdk7.java.net/ freetype: http://download.savannah.gnu.org/releases/freetype/ Ant: http://archive.apache.org/dist/ant/binaries/]]></content>
      <categories>
        <category>OpenJDK</category>
      </categories>
      <tags>
        <tag>CentOS</tag>
        <tag>OpenJDK</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac下vim开启语法高亮&着色]]></title>
    <url>%2Fpost%2F2014%2F01%2F20%2Fconfigure-vim-syntax-highlight-on-mac%2F</url>
    <content type="text"><![CDATA[Mac OS并不像大多数Linux发行版vim默认自带语法着色高亮显示（通常Linux可通过编辑/etc/vimrc进行全局设置或~/vimrc进行单用户设置），使用vi/vim编辑文件时很不方便，如何解决 ? 编辑文件/usr/share/vim/vimrc1234567891011121314BobZhao@mac:~ &gt; sudo vim /usr/share/vim/vimrcPassword:" Configuration file for vimset modelines=0 " CVE-2007-2438" Normally we use vim-extensions. If you want true vi-compatibility" remove change the following statementsset nocompatible " Use Vim defaults instead of 100% vi compatibilityset backspace=2 " more powerful backspacing" Don't write backup file if vim is being called by "crontab -e"au BufWrite /private/tmp/crontab.* set nowritebackup" Don't write backup file if vim is being called by "chpass"au BufWrite /private/etc/pw.* set nowritebackup 在set backspace=2下插入配置1234567891011121314set ai " auto indentingset history=100 " keep 100 lines of historyset ruler " show the cursor positionsyntax on " syntax highlightingset hlsearch " highlight the last searched termfiletype plugin on " use the file type plugins" When editing a file, always jump to the last cursor positionautocmd BufReadPost *\ if ! exists("g:leave_my_cursor_position_alone") |\ if line("'\"") &gt; 0 &amp;&amp; line ("'\"") &lt;= line("$") |\ exe "normal g'\"" |\ endif |\ endif 验证再次打开该文件发现已经生效]]></content>
      <categories>
        <category>Mac</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>vim</tag>
        <tag>Mac</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CentOS通过yum安装配置MySQL]]></title>
    <url>%2Fpost%2F2014%2F01%2F20%2Finstall-and-configure-mysql-on-centos%2F</url>
    <content type="text"><![CDATA[安装MySQL1[root@HunterWorkStation local]# yum -y install mysql mysql-server 启动MySQL服务1234567891011121314151617181920212223242526272829303132[root@HunterWorkStation local]# service mysqld startInitializing MySQL database: Installing MySQL system tables... OKFilling help tables... OKTo start mysqld at boot time you have to copysupport-files/mysql.server to the right place for your systemPLEASE REMEMBER TO SET A PASSWORD FOR THE MySQL root USER !To do so, start the server, then issue the following commands:/usr/bin/mysqladmin -u root password 'new-password'/usr/bin/mysqladmin -u root -h localhost.localdomain password 'new-password'Alternatively you can run:/usr/bin/mysql_secure_installationwhich will also give you the option of removing the testdatabases and anonymous user created by default. This isstrongly recommended for production servers.See the manual for more instructions.You can start the MySQL daemon with:cd /usr ; /usr/bin/mysqld_safe &amp;You can test the MySQL daemon with mysql-test-run.plcd /usr/mysql-test ; perl mysql-test-run.plPlease report any problems with the /usr/bin/mysqlbug script!Starting mysqld: [ OK ] 设置root用户密码1[root@HunterWorkStation local]# mysqladmin -u root password 'YOUR PASSWORD HERE' 登陆数据库并授权此时用户是无法远程登陆该数据库的，接下来为用户授权1234567891011121314151617[root@HunterWorkStation local]# mysql -u root -pEnter password: Welcome to the MySQL monitor. Commands end with ; or \g.Your MySQL connection id is 4Server version: 5.1.71 Source distributionCopyright (c) 2000, 2013, Oracle and/or its affiliates. All rights reserved.Oracle is a registered trademark of Oracle Corporation and/or itsaffiliates. Other names may be trademarks of their respectiveowners.Type 'help;' or '\h' for help. Type '\c' to clear the current input statement.mysql&gt; grant all on *.* to root@'%' identified by '123456'; # 为所有主机授权使用root用户操作所有库和表，密码123456Query OK, 0 rows affected (0.00 sec) 设置MySQL服务开机自启动1[root@HunterWorkStation local]# chkconfig mysqld on 设置后查看是否设置成功123[root@HunterWorkStation local]# chkconfig --list | grep mysqldmysqld 0:off 1:off 2:on 3:on 4:on 5:on 6:off # 2-5为on则表示自启动 设置服务端编码123456789[root@HunterWorkStation local]# vim /etc/my.cnf[mysqld]datadir=/var/lib/mysqlsocket=/var/lib/mysql/mysql.sockuser=mysqldefault-character-set=utf8# Disabling symbolic-links is recommended to prevent assorted security riskssymbolic-links=0 重启MySQL服务123[root@HunterWorkStation local]# service mysqld restartStopping mysqld: [ OK ]Starting mysqld: [ OK ] 至此，安装配置完毕，接来下可以用客户端连接操作MySQL。]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>CentOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2Fpost%2F2011%2F01%2F10%2Fhello-world%2F</url>
    <content type="text"><![CDATA[原博客从2007年7月24日注册已经有10+个年头了，估计也算是中国第一批博客用户了，也见证了网易博客从最初到后来发展成熟的过程。 记得当年比较流行装扮博客，网易官方推出了各式各样的皮肤，并且允许用户博客自定义和分享，后来推出首页自定义模块，具体方式是通过特定的代码来加入更丰富的功能，也就是那时候最初接触到了HTML/CSS。 装扮玩博客后还有更重要的一项就是：推广。当时为了提高博客访问量增加影响力也着实费了一番功夫，通过各种方式各种渠道宣传、互换人气，当时比较有名的是博客群(http://www.bokequn.cn) 博搜(http://www.boosou.com)和博无忧（http://www.bo56.com）。 2009年的时候，网易博客推出了圈子功能，类似QQ群，博友可以把自己的博文、相册推荐到圈子里，圈子里同时有论坛功能，于是大家开始各种灌水，我的圈子从2009年1月份开通，到后来网易博客没落共有3万7千多圈友，在当时也是个比较大的社群了。同年，网易博客每隔段时间就发系统公告，说要对系统存储空间进行扩容，后来技术团队应该是攻克了存储扩容问题，于是便再也没有发过类似公告。 从2011年工作后开始更新技术文章，有时候写博客需要贴代码，但网易博客没有这个功能，所以通过意见反馈渠道反馈了这一情况，意外的是居然收到了网易的产品经理的回复，并且网易博客很快加入了该功能，虽然不太好用，但还是很感谢。 2013年网易博客向部分博主推出了广告服务内测，很荣幸被选入其中，由于访问量还不错，前后一年内共入账了1K左右，算是人生中第一桶金。不过随着业务发展，网易公司决定对推广资源进行合理调整，于2014年4月1日下线网易博客有道推广广告位。 … 十一年，零零散散记载了很多篇，随着工作的忙碌近几年更新频率与日俱减。工作年头越来越多，反而慢慢有了重新执笔的冲动，突然想写点什么。 今年（2017）建立了自己的GitHub Pages并注册了自己的域名，经过一番折腾后，决定把原博客的部分文章迁移过来，一方面用于纪念曾经的青葱岁月，另一方面同时鼓励自己笔耕不辍，把自己这些年以来的所见所闻、所感所悟以文字的方式记录下来，如果恰巧你也有类似的经历或共鸣，那也算是人生中一大幸事了。]]></content>
      <categories>
        <category>默认分类</category>
      </categories>
  </entry>
</search>
