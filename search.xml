<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[【JVM源码探秘】深入理解Thread.run()底层实现]]></title>
    <url>%2Fpost%2F2018%2F06%2F11%2Fhotspot-explore-understand-java-thread-run%2F</url>
    <content type="text"><![CDATA[对于Java程序猿来说可以通过new java.lang.Thread.start()来启动一个线程，只需要将业务逻辑放在run()方法里即可，如此高效且易用的Java线程在JVM层面是怎样的呢？本文将从源码角度深入解读。 java.lang.Thread # start()我们尝试去启动一个Java线程，调用start()方法，然后跟随源码逐渐dive into进去。 12345678910111213141516171819202122232425262728293031public synchronized void start() &#123; /** * This method is not invoked for the main method thread or "system" * group threads created/set up by the VM. Any new functionality added * to this method in the future may have to also be added to the VM. * * A zero status value corresponds to state "NEW". */ if (threadStatus != 0) throw new IllegalThreadStateException(); /* Notify the group that this thread is about to be started * so that it can be added to the group's list of threads * and the group's unstarted count can be decremented. */ group.add(this); boolean started = false; try &#123; start0(); started = true; &#125; finally &#123; try &#123; if (!started) &#123; group.threadStartFailed(this); &#125; &#125; catch (Throwable ignore) &#123; /* do nothing. If start0 threw a Throwable then it will be passed up the call stack */ &#125; &#125;&#125; 在启动一个线程时会调用start0()这个native方法，关于本地方法的注册请参照之前的文章【JVM源码探秘】深入registerNatives()底层实现 Thread.cThread类源码位于src/java.base/share/native/libjava/Thread.c，可见，start0对应JVM_StartThread 123456789101112131415161718static JNINativeMethod methods[] = &#123; &#123;"start0", "()V", (void *)&amp;JVM_StartThread&#125;, &#123;"stop0", "(" OBJ ")V", (void *)&amp;JVM_StopThread&#125;, &#123;"isAlive", "()Z", (void *)&amp;JVM_IsThreadAlive&#125;, &#123;"suspend0", "()V", (void *)&amp;JVM_SuspendThread&#125;, &#123;"resume0", "()V", (void *)&amp;JVM_ResumeThread&#125;, &#123;"setPriority0", "(I)V", (void *)&amp;JVM_SetThreadPriority&#125;, &#123;"yield", "()V", (void *)&amp;JVM_Yield&#125;, &#123;"sleep", "(J)V", (void *)&amp;JVM_Sleep&#125;, &#123;"currentThread", "()" THD, (void *)&amp;JVM_CurrentThread&#125;, &#123;"countStackFrames", "()I", (void *)&amp;JVM_CountStackFrames&#125;, &#123;"interrupt0", "()V", (void *)&amp;JVM_Interrupt&#125;, &#123;"isInterrupted", "(Z)Z", (void *)&amp;JVM_IsInterrupted&#125;, &#123;"holdsLock", "(" OBJ ")Z", (void *)&amp;JVM_HoldsLock&#125;, &#123;"getThreads", "()[" THD, (void *)&amp;JVM_GetAllThreads&#125;, &#123;"dumpThreads", "([" THD ")[[" STE, (void *)&amp;JVM_DumpThreads&#125;, &#123;"setNativeName", "(" STR ")V", (void *)&amp;JVM_SetNativeThreadName&#125;,&#125;; jvm.cpp # JVM_StartThread()JVM_StartThread方法位于src/hotspot/share/prims/jvm.cpp 1234567891011121314151617181920212223242526272829303132333435363738394041424344JVM_ENTRY(void, JVM_StartThread(JNIEnv* env, jobject jthread)) JVMWrapper("JVM_StartThread"); JavaThread *native_thread = NULL; bool throw_illegal_thread_state = false; // We must release the Threads_lock before we can post a jvmti event // in Thread::start. &#123; // 获取互斥锁 MutexLocker mu(Threads_lock); // 线程状态检查，确保尚未启动 if (java_lang_Thread::thread(JNIHandles::resolve_non_null(jthread)) != NULL) &#123; throw_illegal_thread_state = true; &#125; else &#123; jlong size = java_lang_Thread::stackSize(JNIHandles::resolve_non_null(jthread)); // 创建本地线程 NOT_LP64(if (size &gt; SIZE_MAX) size = SIZE_MAX;) size_t sz = size &gt; 0 ? (size_t) size : 0; // 创建C++级别的本地线程，&amp;thread_entry为线程run方法执行入口 native_thread = new JavaThread(&amp;thread_entry, sz); // 检查该本地线程中是否包含OSThread，因为可能出现由于内存不足导致OSThread未创建成功的情况 if (native_thread-&gt;osthread() != NULL) &#123; // Note: the current thread is not being used within "prepare". // =============================================================== // 准备Java本地线程，链接Java线程 &lt;-&gt; C++线程 // =============================================================== native_thread-&gt;prepare(jthread); &#125; &#125; &#125; // =============================================================== // 启动Java本地线程 // =============================================================== Thread::start(native_thread);JVM_END thread.cpp # JavaThread::JavaThread()代码native_thread = new JavaThread(&amp;thread_entry, sz);用于创建JavaThread实例，位于src/hotspot/share/runtime/thread.cpp 1234567891011121314151617181920212223242526// C++级别Java线程构造方法JavaThread::JavaThread(ThreadFunction entry_point, size_t stack_sz) : Thread()#if INCLUDE_ALL_GCS , _satb_mark_queue(&amp;_satb_mark_queue_set), _dirty_card_queue(&amp;_dirty_card_queue_set)#endif // INCLUDE_ALL_GCS&#123; // 初始化实例变量 initialize(); _jni_attach_state = _not_attaching_via_jni; // ============================================= // 设置Java执行线程入口，最终会调用 // ============================================= set_entry_point(entry_point); // 创建系统级本地线程 os::ThreadType thr_type = os::java_thread; thr_type = entry_point == &amp;compiler_thread_entry ? os::compiler_thread : os::java_thread; // ============================================= // 调用系统库创建线程 // ============================================= os::create_thread(this, thr_type, stack_sz);&#125; os_linux.cpp # os::create_thread()通过OS创建线程，位于src/hotspot/os/linux/os_linux.cpp1234567891011121314151617181920212223242526272829303132333435363738394041424344454647bool os::create_thread(Thread* thread, ThreadType thr_type, size_t req_stack_size) &#123; // 创建操作系统线程 OSThread* osthread = new OSThread(NULL, NULL); if (osthread == NULL) &#123; return false; &#125; // 把osthread状态设置为已分配 osthread-&gt;set_state(ALLOCATED); // 绑定至JavaThread thread-&gt;set_osthread(osthread); // 初始化线程数形 pthread_attr_t attr; pthread_attr_init(&amp;attr); pthread_attr_setdetachstate(&amp;attr, PTHREAD_CREATE_DETACHED); ThreadState state; &#123; pthread_t tid; // ======================================================== // 调用系统库创建线程，thread_native_entry为本地Java线程执行入口 // ======================================================== int ret = pthread_create(&amp;tid, &amp;attr, (void* (*)(void*)) thread_native_entry, thread); if (ret != 0) &#123; // Need to clean up stuff we've allocated so far thread-&gt;set_osthread(NULL); delete osthread; return false; &#125; // Store pthread info into the OSThread osthread-&gt;set_pthread_id(tid); // Wait until child thread is either initialized or aborted &#123; Monitor* sync_with_child = osthread-&gt;startThread_lock(); MutexLockerEx ml(sync_with_child, Mutex::_no_safepoint_check_flag); while ((state = osthread-&gt;get_state()) == ALLOCATED) &#123; sync_with_child-&gt;wait(Mutex::_no_safepoint_check_flag); &#125; &#125; &#125; return true;&#125; os_linux.cpp # *thread_native_entry()thread_native_entry为本地Java线程执行入口123456789101112131415161718192021222324252627282930313233// 线程执行入口// Thread start routine for all newly created threadsstatic void *thread_native_entry(Thread *thread) &#123; // 初始化当前线程，把当前线程加入到TLS里 thread-&gt;initialize_thread_current(); OSThread* osthread = thread-&gt;osthread(); // 获取同步锁 Monitor* sync = osthread-&gt;startThread_lock(); osthread-&gt;set_thread_id(os::current_thread_id()); // handshaking with parent thread &#123; MutexLockerEx ml(sync, Mutex::_no_safepoint_check_flag); // notify parent thread osthread-&gt;set_state(INITIALIZED); sync-&gt;notify_all(); // wait until os::start_thread() while (osthread-&gt;get_state() == INITIALIZED) &#123; sync-&gt;wait(Mutex::_no_safepoint_check_flag); &#125; &#125; // ======================================================= // 调用JavaThread的run方法以便触发执行java.lang.Thread.run() // ======================================================= thread-&gt;run(); return 0;&#125; thread.cpp # JavaThread::run()这里调用JavaThread的run方法以便执行java.lang.Thread.run()用户逻辑代码，位于src/hotspot/share/runtime/thread.cpp 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950void JavaThread::run() &#123; // 执行run方法前的初始化和缓存工作 this-&gt;initialize_tlab(); ... // 通知JVMTI if (JvmtiExport::should_post_thread_life()) &#123; JvmtiExport::post_thread_start(this); &#125; EventThreadStart event; if (event.should_commit()) &#123; event.set_thread(THREAD_TRACE_ID(this)); event.commit(); &#125; // ================================================== // 执行Java级别Thread类run()方法内容 // ================================================== thread_main_inner();&#125;void JavaThread::thread_main_inner() &#123; if (!this-&gt;has_pending_exception() &amp;&amp; !java_lang_Thread::is_stillborn(this-&gt;threadObj())) &#123; &#123; ResourceMark rm(this); this-&gt;set_native_thread_name(this-&gt;get_thread_name()); &#125; HandleMark hm(this); // ========================================== // 执行线程入口java.lang.Thread # run()方法 // ========================================== this-&gt;entry_point()(this, this); &#125; DTRACE_THREAD_PROBE(stop, this); // 退出并释放空间 this-&gt;exit(false); // 释放资源 delete this;&#125; jvm.cpp # thread_entry()最终执行实例化JavaThread时设置的入口方法entry_point，代表了Java代码级别Java线程执行入口，这里通过JavaCalls组件调用java.lang.Thread.run()方法，执行真正的用户逻辑代码。 123456789101112static void thread_entry(JavaThread* thread, TRAPS) &#123; HandleMark hm(THREAD); Handle obj(THREAD, thread-&gt;threadObj()); JavaValue result(T_VOID); // 执行Java调用 JavaCalls::call_virtual(&amp;result, obj, SystemDictionary::Thread_klass(), vmSymbols::run_method_name(), vmSymbols::void_method_signature(), THREAD);&#125;]]></content>
      <categories>
        <category>OpenJDK</category>
      </categories>
      <tags>
        <tag>OpenJDK</tag>
        <tag>JVM</tag>
        <tag>HotSpot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【JVM源码探秘】JVM线程模型概览]]></title>
    <url>%2Fpost%2F2018%2F05%2F20%2Fhotspot-explore-thread-model%2F</url>
    <content type="text"><![CDATA[HotSpot中的线程模型是Java线程（java.lang.Thread）与本地操作系统线程一一映射，本地线程在Java线程启动（调用start()）时创建，并在终止时回收。操作系统负责调度本地线程给可用的CPU来执行。Java线程优先级和操作系统优先级之间的关系是相当复杂的，并且因操作系统而异。 JVM线程类结构JVM中线程模型是相当重要的一部分，如执行虚拟机指令的VM线程、执行内存垃圾回收的GC线程、采集虚拟机内存及CPU状况的监控线程，还有专门用于执行用户线程的Java线程，如此多的线程之间是怎样一种联系和区别，我们一起来看一下。 JVM内部主要的线程主要分为以下几类： 12345678910111213141516// ==================================================// 线程实现类结构// ==================================================// Class hierarchy// - Thread// - NamedThread 支持命名的非Java线程// - VMThread VM原始线程，用于执行VM操作// - ConcurrentGCThread 并发GC线程// - WorkerThread 工作线程// - GangWorker 一组线程，类似线程池// - GCTaskThread GC任务线程// - JavaThread C++层面的Java线程实现// - various subclasses eg CompilerThread, ServiceThread// 各种子类，如：编译器线程，服务线程// - WatcherThread 监视器线程，用于模拟计时器中断 比较重要的还有OSThread操作系统层面的本地线程并且包含跟踪线程状态所需的附加操作系统级信息。OSThread还包含一个特定于平台的“句柄”，用于标识操作系统的实际线程 线程的创建与销毁在JVM内部产生一个线程的基本方法有两种 调用java.lang.Thread的start()方法 通过JNI attach到一个已经存在的本地线程上 在java.lang.Thread启动时，JVM会分别创建一个相关联的JavaThread和OSThread对象，最终创建本地线程。在准备完所有的VM状态（例如线程本地存储和分配缓冲区，同步对象等等）之后，本地线程启动。 本地线程完成初始化，然后执行启动方法，该方法导致执行java.lang.Thread对象的run()方法，然后在返回时在处理任何未捕获的异常之后终止该线程，并且交互 与VM一起检查此线程的终止是否需要终止整个VM。 线程终止释放所有分配的资源，从一组已知线程中删除JavaThread，调用OSThread和JavaThread的析构函数，并最终在初始启动方法完成时停止执行。 C++层面的JavaThread状态源码位于src/hotspot/share/utilities/globalDefinitions.hpp 1234567891011121314enum JavaThreadState &#123; _thread_uninitialized = 0, // should never happen (missing initialization) _thread_new = 2, // just starting up, i.e., in process of being initialized _thread_new_trans = 3, // corresponding transition state (not used, included for completness) _thread_in_native = 4, // running in native code _thread_in_native_trans = 5, // corresponding transition state _thread_in_vm = 6, // running in VM _thread_in_vm_trans = 7, // corresponding transition state _thread_in_Java = 8, // running in Java or in stub code _thread_in_Java_trans = 9, // corresponding transition state (not used, included for completness) _thread_blocked = 10, // blocked in vm _thread_blocked_trans = 11, // corresponding transition state _thread_max_state = 12 // maximum thread state+1 - used for statistics allocation&#125;; 最主要的有四个： _thread_new : 刚启动但还没有初始化 _thread_in_native : 在执行本地代码 _thread_in_vm : 在执行JVM本身的代码 _thread_in_Java : 在执行解释的或编译的Java代码 Java语言层面的线程状态源码位于src/hotspot/share/classfile/javaClasses.hpp 这些线程状态主要用于JVMTI和MANGEMENT状态输出。 12345678910111213141516171819202122232425262728enum ThreadStatus &#123; NEW = 0, RUNNABLE = JVMTI_THREAD_STATE_ALIVE + // runnable / running JVMTI_THREAD_STATE_RUNNABLE, SLEEPING = JVMTI_THREAD_STATE_ALIVE + // Thread.sleep() JVMTI_THREAD_STATE_WAITING + JVMTI_THREAD_STATE_WAITING_WITH_TIMEOUT + JVMTI_THREAD_STATE_SLEEPING, IN_OBJECT_WAIT = JVMTI_THREAD_STATE_ALIVE + // Object.wait() JVMTI_THREAD_STATE_WAITING + JVMTI_THREAD_STATE_WAITING_INDEFINITELY + JVMTI_THREAD_STATE_IN_OBJECT_WAIT, IN_OBJECT_WAIT_TIMED = JVMTI_THREAD_STATE_ALIVE + // Object.wait(long) JVMTI_THREAD_STATE_WAITING + JVMTI_THREAD_STATE_WAITING_WITH_TIMEOUT + JVMTI_THREAD_STATE_IN_OBJECT_WAIT, PARKED = JVMTI_THREAD_STATE_ALIVE + // LockSupport.park() JVMTI_THREAD_STATE_WAITING + JVMTI_THREAD_STATE_WAITING_INDEFINITELY + JVMTI_THREAD_STATE_PARKED, PARKED_TIMED = JVMTI_THREAD_STATE_ALIVE + // LockSupport.park(long) JVMTI_THREAD_STATE_WAITING + JVMTI_THREAD_STATE_WAITING_WITH_TIMEOUT + JVMTI_THREAD_STATE_PARKED, BLOCKED_ON_MONITOR_ENTER = JVMTI_THREAD_STATE_ALIVE + // (re-)entering a synchronization block JVMTI_THREAD_STATE_BLOCKED_ON_MONITOR_ENTER, TERMINATED = JVMTI_THREAD_STATE_TERMINATED &#125;; SLEEPING 调用Thread.sleep()进入 IN_OBJECT_WAIT 调用Object.wait()进入 IN_OBJECT_WAIT_TIMED 调用Object.wait(long)进入 PARKED 调用LockSupport.park()进入 PARKED_TIMED 调用LockSupport.park(long)进入 Java线程状态名称12345678910111213141516const char* java_lang_Thread::thread_status_name(oop java_thread) &#123; assert(_thread_status_offset != 0, "Must have thread status"); ThreadStatus status = (java_lang_Thread::ThreadStatus)java_thread-&gt;int_field(_thread_status_offset); switch (status) &#123; case NEW : return "NEW"; case RUNNABLE : return "RUNNABLE"; case SLEEPING : return "TIMED_WAITING (sleeping)"; case IN_OBJECT_WAIT : return "WAITING (on object monitor)"; case IN_OBJECT_WAIT_TIMED : return "TIMED_WAITING (on object monitor)"; case PARKED : return "WAITING (parking)"; case PARKED_TIMED : return "TIMED_WAITING (parking)"; case BLOCKED_ON_MONITOR_ENTER : return "BLOCKED (on object monitor)"; case TERMINATED : return "TERMINATED"; default : return "UNKNOWN"; &#125;;&#125; 实例验证随便实现一个Java线程并在内部sleep， 12345678910111213141516171819202122public class Main &#123; public static void main(String[] args) throws IOException &#123; Thread t = new DemoThread(); // 启动线程 t.start(); System.in.read(); &#125; static class DemoThread extends Thread &#123; @Override public void run() &#123; try &#123; TimeUnit.HOURS.sleep(1); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 然后通过jstack命令获取其运行状态： 1234$ jps82005 Jps81869 Main81868 Launcher 1234567891011121314151617181920212223242526272829303132333435363738$ jstack 818692018-07-02 00:28:52Full thread dump Java HotSpot(TM) 64-Bit Server VM (25.151-b12 mixed mode):"Attach Listener" #12 daemon prio=9 os_prio=31 tid=0x00007f99af000000 nid=0x1307 waiting on condition [0x0000000000000000] java.lang.Thread.State: RUNNABLE"Thread-0" #11 prio=5 os_prio=31 tid=0x00007f99ae817000 nid=0x5a03 waiting on condition [0x0000700011471000] java.lang.Thread.State: TIMED_WAITING (sleeping) at java.lang.Thread.sleep(Native Method) at java.lang.Thread.sleep(Thread.java:340) at java.util.concurrent.TimeUnit.sleep(TimeUnit.java:386) at com.workholiday.demoapp.Main$DemoThread.run(Main.java:30)"Service Thread" #10 daemon prio=9 os_prio=31 tid=0x00007f99ae800800 nid=0x5603 runnable [0x0000000000000000] java.lang.Thread.State: RUNNABLE..."Finalizer" #3 daemon prio=8 os_prio=31 tid=0x00007f99ab814000 nid=0x3903 in Object.wait() [0x0000700010ad3000] java.lang.Thread.State: WAITING (on object monitor) at java.lang.Object.wait(Native Method) - waiting on &lt;0x000000076ab08ec8&gt; (a java.lang.ref.ReferenceQueue$Lock) at java.lang.ref.ReferenceQueue.remove(ReferenceQueue.java:143) - locked &lt;0x000000076ab08ec8&gt; (a java.lang.ref.ReferenceQueue$Lock) at java.lang.ref.ReferenceQueue.remove(ReferenceQueue.java:164) at java.lang.ref.Finalizer$FinalizerThread.run(Finalizer.java:209)"main" #1 prio=5 os_prio=31 tid=0x00007f99ae802000 nid=0x1c03 runnable [0x000070000ffb2000] java.lang.Thread.State: RUNNABLE at java.io.FileInputStream.readBytes(Native Method) at java.io.FileInputStream.read(FileInputStream.java:255) at java.io.BufferedInputStream.fill(BufferedInputStream.java:246) at java.io.BufferedInputStream.read(BufferedInputStream.java:265) - locked &lt;0x000000076ab20660&gt; (a java.io.BufferedInputStream) at com.workholiday.demoapp.Main.main(Main.java:19) 通过日志输出会发现线程中的状态 RUNNABLE TIMED_WAITING (sleeping) WAITING (on object monitor) 正是通过java_lang_Thread::thread_status_name()方法获取的。 ReferenceHotSpot Threading Model]]></content>
      <categories>
        <category>OpenJDK</category>
      </categories>
      <tags>
        <tag>OpenJDK</tag>
        <tag>JVM</tag>
        <tag>HotSpot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【JVM源码探秘】细说Class的装载、链接和初始化]]></title>
    <url>%2Fpost%2F2018%2F05%2F17%2Fhotspot-explore-class-loading-linking-and-initializing%2F</url>
    <content type="text"><![CDATA[接上篇《【JVM源码探秘】细说Class.forName()底层实现》执行Class.forName(“com.xxx.Xxx”)通过JavaCalls组件调用了Java方法ClassLoader.loadClass()对该类进行加载，而最终会调用ClassLoader的native方法defineClass1()，其实现位于src/java.base/share/native/libjava/ClassLoader.c。 ClassLoader.c # Java_java_lang_ClassLoader_defineClass1()1234567891011121314151617181920212223242526272829303132333435363738394041424344// 加载指定类JNIEXPORT jclass JNICALLJava_java_lang_ClassLoader_defineClass1(JNIEnv *env, jclass cls, jobject loader, jstring name, jbyteArray data, jint offset, jint length, jobject pd, jstring source)&#123; jbyte *body; char *utfName; jclass result = 0; char buf[128]; char* utfSource; char sourceBuf[1024]; if (data == NULL) &#123; JNU_ThrowNullPointerException(env, 0); return 0; &#125; .... // ========================================== // 查找并加载class // ========================================== result = JVM_DefineClassWithSource(env, utfName, loader, body, length, pd, utfSource); if (utfSource &amp;&amp; utfSource != sourceBuf) free(utfSource); free_utfName: if (utfName &amp;&amp; utfName != buf) free(utfName); free_body: free(body); return result;&#125; jvm.cpp # JVM_DefineClassWithSource()方法跳转到src/hotspot/share/prims/jvm.cpp12345JVM_ENTRY(jclass, JVM_DefineClassWithSource(JNIEnv *env, const char *name, jobject loader, const jbyte *buf, jsize len, jobject pd, const char *source)) JVMWrapper("JVM_DefineClassWithSource"); return jvm_define_class_common(env, name, loader, buf, len, pd, source, THREAD);JVM_END jvm.cpp # jvm_define_class_common()123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960// common code for JVM_DefineClass() and JVM_DefineClassWithSource()static jclass jvm_define_class_common(JNIEnv *env, const char *name, jobject loader, const jbyte *buf, jsize len, jobject pd, const char *source, TRAPS) &#123; if (source == NULL) source = "__JVM_DefineClass__"; // 如果设置了-XX:+UsePerfData if (UsePerfData) &#123; ClassLoader::perf_app_classfile_bytes_read()-&gt;inc(len); &#125; // Since exceptions can be thrown, class initialization can take place // if name is NULL no check for class name in .class stream has to be made. TempNewSymbol class_name = NULL; if (name != NULL) &#123; const int str_len = (int)strlen(name); // 如果全限定名超过了最大限制则抛出java_lang_NoClassDefFoundError() if (str_len &gt; Symbol::max_length()) &#123; // It's impossible to create this class; the name cannot fit // into the constant pool. Exceptions::fthrow(THREAD_AND_LOCATION, vmSymbols::java_lang_NoClassDefFoundError(), "Class name exceeds maximum length of %d: %s", Symbol::max_length(), name); return 0; &#125; // 将该类写入符号表 class_name = SymbolTable::new_symbol(name, str_len, CHECK_NULL); &#125; ResourceMark rm(THREAD); // 创建文件流 ClassFileStream st((u1*)buf, len, source, ClassFileStream::verify); Handle class_loader (THREAD, JNIHandles::resolve(loader)); if (UsePerfData) &#123; is_lock_held_by_thread(class_loader, ClassLoader::sync_JVMDefineClassLockFreeCounter(), THREAD); &#125; Handle protection_domain (THREAD, JNIHandles::resolve(pd)); // ============================================================================= // // 解析class文件流并返回对应的Klass // // ============================================================================= Klass* k = SystemDictionary::resolve_from_stream(class_name, class_loader, protection_domain, &amp;st, CHECK_NULL); if (log_is_enabled(Debug, class, resolve) &amp;&amp; k != NULL) &#123; trace_class_resolution(k); &#125; return (jclass) JNIHandles::make_local(env, k-&gt;java_mirror());&#125; systemDictionary.cpp # resolve_from_stream()12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758// 把一个klass加入系统（systemDictionary）InstanceKlass* SystemDictionary::resolve_from_stream(Symbol* class_name, Handle class_loader, Handle protection_domain, ClassFileStream* st, TRAPS) &#123; HandleMark hm(THREAD); ClassLoaderData* loader_data = register_loader(class_loader, CHECK_NULL); // 确认同步操作 Handle lockObject = compute_loader_lock_object(class_loader, THREAD); check_loader_lock_contention(lockObject, THREAD); ObjectLocker ol(lockObject, THREAD, DoObjectLock); InstanceKlass* k = NULL; if (k == NULL) &#123; if (st-&gt;buffer() == NULL) &#123; return NULL; &#125; // =============================================== // // 解析class文件流并创建Klass // // =============================================== k = KlassFactory::create_from_stream(st, class_name, loader_data, protection_domain, NULL, // host_klass NULL, // cp_patches CHECK_NULL); &#125; // 如果支持并行加载 if (is_parallelCapable(class_loader)) &#123; InstanceKlass* defined_k = find_or_define_instance_class(h_name, class_loader, k, THREAD); if (!HAS_PENDING_EXCEPTION &amp;&amp; defined_k != k) &#123; loader_data-&gt;add_to_deallocate_list(k); k = defined_k; &#125; &#125; else &#123; // ================================================================ // // 如果不支持并行加载则直接更新systemDictionary，这里主要做两件事： // // 1、把新的class加入到systemDictionary // 2、链接并初始化klass // // ================================================================ define_instance_class(k, THREAD); &#125; return k;&#125; klassFactory.cpp # create_from_stream()这里是整个类加载流程中最为关键的两个步骤，实现逻辑较为复杂，先看KlassFactory::create_from_stream()，位于src/hotspot/share/classfile/klassFactory.cpp 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556// =====================================================================================================================// 解析class文件流并创建InstanceKlass// =====================================================================================================================// 入口1：| classLoader.cpp # ClassLoader::load_class() |// 入口2：| systemDictionary.cpp # SystemDictionary::parse_stream() | 与resolve_from_stream()方法类似，但不会把解析的klass添加至systemDictionary// 入口3：| systemDictionary.cpp # SystemDictionary::resolve_from_stream() | called by jni_DefineClass and JVM_DefineClass).// =====================================================================================================================InstanceKlass* KlassFactory::create_from_stream(ClassFileStream* stream, Symbol* name, ClassLoaderData* loader_data, Handle protection_domain, const InstanceKlass* host_klass, GrowableArray&lt;Handle&gt;* cp_patches, TRAPS) &#123; ClassFileStream* old_stream = stream; // ============================================================================ // // 实例化class文件解析器并执行解析操作，包含： // // ============================================================================ // 1. 魔数 // 2. 版本号 // 3. 常量池 // 4. 访问标识 // 5. 类的修饰符合法性验证 // 6. 父类 // 7. 接口列表 // 8. 域列表 // 9. 方法列表 // 10. 属性和注解列表 // // ============================================================================ ClassFileParser parser(stream, name, loader_data, protection_domain, host_klass, cp_patches, ClassFileParser::BROADCAST, // publicity level CHECK_NULL); // ============================================================================ // // 创建InstanceKlass，并把classFileParser解析的文件流内容填充至InstanceKlass返回 // // ============================================================================ InstanceKlass* result = parser.create_instance_klass(old_stream != stream, CHECK_NULL); if (result == NULL) &#123; return NULL; &#125; return result;&#125; 先实例化class文件解析器并执行解析操作 classFileParser.cpp # ClassFileParser::ClassFileParser()12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879ClassFileParser::ClassFileParser(ClassFileStream* stream, Symbol* name, ClassLoaderData* loader_data, Handle protection_domain, const InstanceKlass* host_klass, GrowableArray&lt;Handle&gt;* cp_patches, Publicity pub_level, TRAPS) : _stream(stream), _requested_name(name), _loader_data(loader_data), _host_klass(host_klass), _cp_patches(cp_patches), _num_patched_klasses(0), _max_num_patched_klasses(0), _orig_cp_size(0), _first_patched_klass_resolved_index(0), _super_klass(), _cp(NULL), _fields(NULL), _methods(NULL), _inner_classes(NULL), _local_interfaces(NULL), _transitive_interfaces(NULL), _combined_annotations(NULL), _annotations(NULL), _type_annotations(NULL), _fields_annotations(NULL), _fields_type_annotations(NULL), _klass(NULL), _klass_to_deallocate(NULL), _parsed_annotations(NULL), _fac(NULL), _field_info(NULL), _method_ordering(NULL), _all_mirandas(NULL), _vtable_size(0), _itable_size(0), _num_miranda_methods(0), _rt(REF_NONE), _protection_domain(protection_domain), _access_flags(), _pub_level(pub_level), _bad_constant_seen(0), _synthetic_flag(false), _sde_length(false), _sde_buffer(NULL), _sourcefile_index(0), _generic_signature_index(0), _major_version(0), _minor_version(0), _this_class_index(0), _super_class_index(0), _itfs_len(0), _java_fields_count(0), _need_verify(false), _relax_verify(false), _has_nonstatic_concrete_methods(false), _declares_nonstatic_concrete_methods(false), _has_final_method(false), _has_finalizer(false), _has_empty_finalizer(false), _has_vanilla_constructor(false), _max_bootstrap_specifier_index(-1) &#123; _class_name = name != NULL ? name : vmSymbols::unknown_class_name(); // synch back verification state to stream stream-&gt;set_verify(_need_verify); // ================================================================ // 执行解析操作 // ================================================================ parse_stream(stream, CHECK); // 执行一些解析的后续操作（计算该类实现的接口列表、对方法列表进行排序等） post_process_parsed_stream(stream, _cp, CHECK);&#125; classFileParser.cpp # parse_stream()123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147// 解析文件流void ClassFileParser::parse_stream(const ClassFileStream* const stream, TRAPS) &#123; // BEGIN STREAM PARSING stream-&gt;guarantee_more(8, CHECK); // magic, major, minor // 魔数 const u4 magic = stream-&gt;get_u4_fast(); guarantee_property(magic == JAVA_CLASSFILE_MAGIC, "Incompatible magic value %u in class file %s", magic, CHECK); // 版本号 _minor_version = stream-&gt;get_u2_fast(); _major_version = stream-&gt;get_u2_fast(); // 检查版本号是否支持，如果不支持抛出java_lang_UnsupportedClassVersionError() if (!is_supported_version(_major_version, _minor_version)) &#123; ResourceMark rm(THREAD); Exceptions::fthrow( THREAD_AND_LOCATION, vmSymbols::java_lang_UnsupportedClassVersionError(), "%s has been compiled by a more recent version of the Java Runtime (class file version %u.%u), " "this version of the Java Runtime only recognizes class file versions up to %u.%u", _class_name-&gt;as_C_string(), _major_version, _minor_version, JAVA_MAX_SUPPORTED_VERSION, JAVA_MAX_SUPPORTED_MINOR_VERSION); return; &#125; stream-&gt;guarantee_more(3, CHECK); // length, first cp tag u2 cp_size = stream-&gt;get_u2_fast(); guarantee_property( cp_size &gt;= 1, "Illegal constant pool size %u in class file %s", cp_size, CHECK); _orig_cp_size = cp_size; if (int(cp_size) + _max_num_patched_klasses &gt; 0xffff) &#123; THROW_MSG(vmSymbols::java_lang_InternalError(), "not enough space for patched classes"); &#125; cp_size += _max_num_patched_klasses; // 分配常量池空间 _cp = ConstantPool::allocate(_loader_data, cp_size, CHECK); ConstantPool* const cp = _cp; // 解析常量池 parse_constant_pool(stream, cp, _orig_cp_size, CHECK); // ACCESS FLAGS stream-&gt;guarantee_more(8, CHECK); // flags, this_class, super_class, infs_len // 访问标识 jint flags; // 定义了JVM_ACC_MODULE in JDK-9 and later. if (_major_version &gt;= JAVA_9_VERSION) &#123; flags = stream-&gt;get_u2_fast() &amp; (JVM_RECOGNIZED_CLASS_MODIFIERS | JVM_ACC_MODULE); &#125; else &#123; flags = stream-&gt;get_u2_fast() &amp; JVM_RECOGNIZED_CLASS_MODIFIERS; &#125; // 验证类的修饰符合法性 verify_legal_class_modifiers(flags, CHECK); short bad_constant = class_bad_constant_seen(); if (bad_constant != 0) &#123; // Do not throw CFE until after the access_flags are checked because if // ACC_MODULE is set in the access flags, then NCDFE must be thrown, not CFE. classfile_parse_error("Unknown constant tag %u in class file %s", bad_constant, CHECK); &#125; _access_flags.set_flags(flags); // 修复匿名类名 // if this is an anonymous class fix up its name if it's in the unnamed // package. Otherwise, throw IAE if it is in a different package than // its host class. if (_host_klass != NULL) &#123; fix_anonymous_class_name(CHECK); &#125; // 解析父类 _super_class_index = stream-&gt;get_u2_fast(); _super_klass = parse_super_class(cp, _super_class_index, _need_verify, CHECK); // 解析接口 _itfs_len = stream-&gt;get_u2_fast(); parse_interfaces(stream, _itfs_len, cp, &amp;_has_nonstatic_concrete_methods, CHECK); // 解析Field // Fields (offsets are filled in later) _fac = new FieldAllocationCount(); parse_fields(stream, _access_flags.is_interface(), _fac, cp, cp_size, &amp;_java_fields_count, CHECK); // ====================================================== // // 解析方法列表 // 包含栈、字节码表、异常表、局部变量表、运行指针等 // // ====================================================== AccessFlags promoted_flags; parse_methods(stream, _access_flags.is_interface(), &amp;promoted_flags, &amp;_has_final_method, &amp;_declares_nonstatic_concrete_methods, CHECK); // promote flags from parse_methods() to the klass' flags _access_flags.add_promoted_flags(promoted_flags.as_int()); if (_declares_nonstatic_concrete_methods) &#123; _has_nonstatic_concrete_methods = true; &#125; // 解析attributes/annotations _parsed_annotations = new ClassAnnotationCollector(); parse_classfile_attributes(stream, cp, _parsed_annotations, CHECK); // Finalize the Annotations metadata object, // now that all annotation arrays have been created. create_combined_annotations(CHECK); // all bytes in stream read and parsed&#125; classFileParser.cpp # parse_methods()1234567891011121314151617181920212223242526272829303132333435363738394041void ClassFileParser::parse_methods(const ClassFileStream* const cfs, bool is_interface, AccessFlags* promoted_flags, bool* has_final_method, bool* declares_nonstatic_concrete_methods, TRAPS) &#123; cfs-&gt;guarantee_more(2, CHECK); // length const u2 length = cfs-&gt;get_u2_fast(); if (length == 0) &#123; _methods = Universe::the_empty_method_array(); &#125; else &#123; _methods = MetadataFactory::new_array&lt;Method*&gt;(_loader_data, length, NULL, CHECK); for (int index = 0; index &lt; length; index++) &#123; // =============================================== // 遍历解析所有方法 // =============================================== Method* method = parse_method(cfs, is_interface, _cp, promoted_flags, CHECK); if (method-&gt;is_final()) &#123; *has_final_method = true; &#125; // declares_nonstatic_concrete_methods: declares concrete instance methods, any access flags // used for interface initialization, and default method inheritance analysis if (is_interface &amp;&amp; !(*declares_nonstatic_concrete_methods) &amp;&amp; !method-&gt;is_abstract() &amp;&amp; !method-&gt;is_static()) &#123; *declares_nonstatic_concrete_methods = true; &#125; // 放入方法表 _methods-&gt;at_put(index, method); &#125; &#125;&#125; classFileParser.cpp # post_process_parsed_stream()1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798void ClassFileParser::post_process_parsed_stream(const ClassFileStream* const stream, ConstantPool* cp, TRAPS) &#123; assert(stream != NULL, "invariant"); assert(stream-&gt;at_eos(), "invariant"); assert(cp != NULL, "invariant"); assert(_loader_data != NULL, "invariant"); if (_class_name == vmSymbols::java_lang_Object()) &#123; check_property(_local_interfaces == Universe::the_empty_klass_array(), "java.lang.Object cannot implement an interface in class file %s", CHECK); &#125; // We check super class after class file is parsed and format is checked if (_super_class_index &gt; 0 &amp;&amp; NULL ==_super_klass) &#123; Symbol* const super_class_name = cp-&gt;klass_name_at(_super_class_index); if (_access_flags.is_interface()) &#123; // Before attempting to resolve the superclass, check for class format // errors not checked yet. guarantee_property(super_class_name == vmSymbols::java_lang_Object(), "Interfaces must have java.lang.Object as superclass in class file %s", CHECK); &#125; Handle loader(THREAD, _loader_data-&gt;class_loader()); // 解析父类 _super_klass = (const InstanceKlass*) SystemDictionary::resolve_super_or_fail(_class_name, super_class_name, loader, _protection_domain, true, CHECK); &#125; if (_super_klass != NULL) &#123; if (_super_klass-&gt;has_nonstatic_concrete_methods()) &#123; _has_nonstatic_concrete_methods = true; &#125; // 确保不是接口 if (_super_klass-&gt;is_interface()) &#123; ResourceMark rm(THREAD); Exceptions::fthrow( THREAD_AND_LOCATION, vmSymbols::java_lang_IncompatibleClassChangeError(), "class %s has interface %s as super class", _class_name-&gt;as_klass_external_name(), _super_klass-&gt;external_name() ); return; &#125; // 确保父类不是final修饰 if (_super_klass-&gt;is_final()) &#123; THROW_MSG(vmSymbols::java_lang_VerifyError(), "Cannot inherit from final class"); &#125; &#125; // 计算由此类实现的所有唯一接口的传递列表 // Compute the transitive list of all unique interfaces implemented by this class _transitive_interfaces = compute_transitive_interfaces(_super_klass, _local_interfaces, _loader_data, CHECK); assert(_transitive_interfaces != NULL, "invariant"); // sort methods _method_ordering = sort_methods(_methods); _all_mirandas = new GrowableArray&lt;Method*&gt;(20); Handle loader(THREAD, _loader_data-&gt;class_loader()); // 计算虚拟表大小 klassVtable::compute_vtable_size_and_num_mirandas(&amp;_vtable_size, &amp;_num_miranda_methods, _all_mirandas, _super_klass, _methods, _access_flags, _major_version, loader, _class_name, _local_interfaces, CHECK); // Size of Java itable (in words) _itable_size = _access_flags.is_interface() ? 0 : klassItable::compute_itable_size(_transitive_interfaces); _field_info = new FieldLayoutInfo(); layout_fields(cp, _fac, _parsed_annotations, _field_info, CHECK); // Compute reference typ _rt = (NULL ==_super_klass) ? REF_NONE : _super_klass-&gt;reference_type();&#125; classFileParser.cpp # create_instance_klass()接下来是创建InstanceKlass，并把classFileParser解析的文件流内容填充至InstanceKlass返回 1234567891011121314InstanceKlass* ClassFileParser::create_instance_klass(bool changed_by_loadhook, TRAPS) &#123; if (_klass != NULL) &#123; return _klass; &#125; // 为新建的InstanceKlass分配内存空间 InstanceKlass* const ik = InstanceKlass::allocate_instance_klass(*this, CHECK_NULL); // 把classFileParser解析的文件流内容填充至InstanceKlass fill_instance_klass(ik, changed_by_loadhook, CHECK_NULL); return ik;&#125; instanceKlass.cpp # allocate_instance_klass()1234567891011121314151617181920212223242526272829303132333435363738394041424344454647// 为新建的InstanceKlass分配内存空间InstanceKlass* InstanceKlass::allocate_instance_klass(const ClassFileParser&amp; parser, TRAPS) &#123; const int size = InstanceKlass::size(parser.vtable_size(), parser.itable_size(), nonstatic_oop_map_size(parser.total_oop_map_count()), parser.is_interface(), parser.is_anonymous(), should_store_fingerprint()); const Symbol* const class_name = parser.class_name(); assert(class_name != NULL, "invariant"); ClassLoaderData* loader_data = parser.loader_data(); assert(loader_data != NULL, "invariant"); InstanceKlass* ik; // Allocation if (REF_NONE == parser.reference_type()) &#123; if (class_name == vmSymbols::java_lang_Class()) &#123; // mirror ik = new (loader_data, size, THREAD) InstanceMirrorKlass(parser); &#125; else if (is_class_loader(class_name, parser)) &#123; // class loader ik = new (loader_data, size, THREAD) InstanceClassLoaderKlass(parser); &#125; else &#123; // 普通类 ik = new (loader_data, size, THREAD) InstanceKlass(parser, InstanceKlass::_misc_kind_other); &#125; &#125; else &#123; // reference ik = new (loader_data, size, THREAD) InstanceRefKlass(parser); &#125; const bool publicize = !parser.is_internal(); // 把当前类加入到classloader // Add all classes to our internal class loader list here, // including classes in the bootstrap (NULL) class loader. loader_data-&gt;add_class(ik, publicize); Atomic::inc(&amp;_total_instanceKlass_count); return ik;&#125; systemDictionary.cpp # define_instance_class()至此，通过KlassFactory解析并创建完毕InstanceKlass，接下来就是调用define_instance_class()进行连接和初始化， 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950void SystemDictionary::define_instance_class(InstanceKlass* k, TRAPS) &#123; // 调用Java方法ClassLoader#addClass()把该类注册到对应的classloader // if (k-&gt;class_loader() != NULL) &#123; methodHandle m(THREAD, Universe::loader_addClass_method()); JavaValue result(T_VOID); JavaCallArguments args(class_loader_h); args.push_oop(Handle(THREAD, k-&gt;java_mirror())); JavaCalls::call(&amp;result, m, &amp;args, CHECK); &#125; // 把新的class加入到systemDictionary // // Add the new class. We need recompile lock during update of CHA. &#123; unsigned int p_hash = placeholders()-&gt;compute_hash(name_h); int p_index = placeholders()-&gt;hash_to_index(p_hash); MutexLocker mu_r(Compile_lock, THREAD); // 添加到class结构目录，初始化虚拟表，并把状态标记为loaded // // Add to class hierarchy, initialize vtables, and do possible // deoptimizations. add_to_hierarchy(k, CHECK); // No exception, but can block // 执行更新操作 // // Add to systemDictionary - so other classes can see it. // Grabs and releases SystemDictionary_lock update_dictionary(d_index, d_hash, p_index, p_hash, k, class_loader_h, THREAD); &#125; // ============================================ // 链接并初始化klass // ============================================ k-&gt;eager_initialize(THREAD); // 通知 jvmti if (JvmtiExport::should_post_class_load()) &#123; assert(THREAD-&gt;is_Java_thread(), "thread-&gt;is_Java_thread()"); JvmtiExport::post_class_load((JavaThread *) THREAD, k); &#125; class_define_event(k, loader_data);&#125; instanceKlass.cpp # eager_initialize()1234567891011121314151617181920void InstanceKlass::eager_initialize(Thread *thread) &#123; if (!EagerInitialization) return; if (this-&gt;is_not_initialized()) &#123; // abort if the the class has a class initializer if (this-&gt;class_initializer() != NULL) return; // abort if it is java.lang.Object (initialization is handled in genesis) Klass* super_klass = super(); if (super_klass == NULL) return; // abort if the super class should be initialized if (!InstanceKlass::cast(super_klass)-&gt;is_initialized()) return; // ============================================ // 执行初始化该指针 // ============================================ eager_initialize_impl(); &#125;&#125; instanceKlass.cpp # eager_initialize_impl()123456789101112131415161718192021222324252627282930void InstanceKlass::eager_initialize_impl() &#123; EXCEPTION_MARK; HandleMark hm(THREAD); Handle h_init_lock(THREAD, init_lock()); ObjectLocker ol(h_init_lock, THREAD, h_init_lock() != NULL); // abort if someone beat us to the initialization if (!is_not_initialized()) return; // note: not equivalent to is_initialized() ClassState old_state = init_state(); // ===================================================== // // 链接class // // ===================================================== link_class_impl(true, THREAD); if (HAS_PENDING_EXCEPTION) &#123; CLEAR_PENDING_EXCEPTION; if (old_state != _init_state) set_init_state(old_state); &#125; else &#123; // ===================================================== // class状态标记为fully_initialized // ===================================================== set_init_state(fully_initialized); fence_and_clear_init_lock();&#125; instanceKlass.cpp # link_class_impl()123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108bool InstanceKlass::link_class_impl(bool throw_verifyerror, TRAPS) &#123; // return if already verified if (is_linked()) &#123; return true; &#125; JavaThread* jt = (JavaThread*)THREAD; // 在链接该类之前先链接父类 Klass* super_klass = super(); if (super_klass != NULL) &#123; if (super_klass-&gt;is_interface()) &#123; // check if super class is an interface ResourceMark rm(THREAD); Exceptions::fthrow( THREAD_AND_LOCATION, vmSymbols::java_lang_IncompatibleClassChangeError(), "class %s has interface %s as super class", external_name(), super_klass-&gt;external_name() ); return false; &#125; InstanceKlass* ik_super = InstanceKlass::cast(super_klass); // 递归调用当前方法进行链接 ik_super-&gt;link_class_impl(throw_verifyerror, CHECK_false); &#125; // 在链接该类之前先链接该类实现的所有接口 Array&lt;Klass*&gt;* interfaces = local_interfaces(); int num_interfaces = interfaces-&gt;length(); for (int index = 0; index &lt; num_interfaces; index++) &#123; InstanceKlass* interk = InstanceKlass::cast(interfaces-&gt;at(index)); interk-&gt;link_class_impl(throw_verifyerror, CHECK_false); &#125; // in case the class is linked in the process of linking its superclasses if (is_linked()) &#123; return true; &#125; // 验证 &amp; 重写 // verification &amp; rewriting &#123; HandleMark hm(THREAD); Handle h_init_lock(THREAD, init_lock()); ObjectLocker ol(h_init_lock, THREAD, h_init_lock() != NULL); // rewritten will have been set if loader constraint error found // on an earlier link attempt // don't verify or rewrite if already rewritten // if (!is_linked()) &#123; if (!is_rewritten()) &#123; &#123; bool verify_ok = verify_code(throw_verifyerror, THREAD); if (!verify_ok) &#123; return false; &#125; &#125; // Just in case a side-effect of verify linked this class already // (which can sometimes happen since the verifier loads classes // using custom class loaders, which are free to initialize things) if (is_linked()) &#123; return true; &#125; // also sets rewritten rewrite_class(CHECK_false); &#125; else if (is_shared()) &#123; SystemDictionaryShared::check_verification_constraints(this, CHECK_false); &#125; // 重写之后链接方法 // relocate jsrs and link methods after they are all rewritten link_methods(CHECK_false); // 方法重写后初始化虚拟表和接口表 // Initialize the vtable and interface table after // methods have been rewritten since rewrite may // fabricate new Method*s. // also does loader constraint checking // // initialize_vtable and initialize_itable need to be rerun for // a shared class if the class is not loaded by the NULL classloader. ClassLoaderData * loader_data = class_loader_data(); if (!(is_shared() &amp;&amp; loader_data-&gt;is_the_null_class_loader_data())) &#123; ResourceMark rm(THREAD); // 初始化虚拟表 vtable().initialize_vtable(true, CHECK_false); // 初始化接口表 itable().initialize_itable(true, CHECK_false); &#125; // class状态标记为linked set_init_state(linked); if (JvmtiExport::should_post_class_prepare()) &#123; Thread *thread = THREAD; assert(thread-&gt;is_Java_thread(), "thread-&gt;is_Java_thread()"); JvmtiExport::post_class_prepare((JavaThread *) thread, this); &#125; &#125; &#125; return true;&#125; 链接完成以后最终在方法eager_initialize_impl()内调用set_init_state(fully_initialized);把klass状态标记为初始化完成状态，并返回一个可用的实例对象，至此类的装载、验证、准备、解析、初始化所有操作全部完成。]]></content>
      <categories>
        <category>OpenJDK</category>
      </categories>
      <tags>
        <tag>OpenJDK</tag>
        <tag>JVM</tag>
        <tag>HotSpot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【JVM源码探秘】细说Class.forName()底层实现]]></title>
    <url>%2Fpost%2F2018%2F05%2F15%2Fhotspot-explore-java-lang-class-forName%2F</url>
    <content type="text"><![CDATA[JVM允许在运行时动态装载类，这为开发者提供了极大方便，使用Class.forName(&quot;com.xxx.Xxx&quot;)，装载完成后可以通过调用其newInstance()完成对象的创建，然后便可以正常操作该类。 接下来我们就细说说Class.forName()在JVM层面所做的事情。 java.lang.Class12345public static Class&lt;?&gt; forName(String className) throws ClassNotFoundException &#123; Class&lt;?&gt; caller = Reflection.getCallerClass(); return forName0(className, true, ClassLoader.getClassLoader(caller), caller);&#125; 这里调用了native方法forName0()12345/** Called after security check for system loader access checks have been made. */ private static native Class&lt;?&gt; forName0(String name, boolean initialize, ClassLoader loader, Class&lt;?&gt; caller) throws ClassNotFoundException; Class.c # Java_java_lang_Class_forName0()源码实现位于src/java.base/share/native/libjava/Class.c123456789101112131415161718192021222324252627282930313233343536373839// 动态装载类型入口JNIEXPORT jclass JNICALLJava_java_lang_Class_forName0(JNIEnv *env, jclass this, jstring classname, jboolean initialize, jobject loader, jclass caller)&#123; char *clname; jclass cls = 0; char buf[128]; jsize len; jsize unicode_len; if (classname == NULL) &#123; JNU_ThrowNullPointerException(env, 0); return 0; &#125; // 把类全限定名里的'.'翻译成'/' if (VerifyFixClassname(clname) == JNI_TRUE) &#123; /* slashes present in clname, use name b4 translation for exception */ (*env)-&gt;GetStringUTFRegion(env, classname, 0, unicode_len, clname); JNU_ThrowClassNotFoundException(env, clname); goto done; &#125; // 验证类全限定名名合法性（是否以'/'分隔） if (!VerifyClassname(clname, JNI_TRUE)) &#123; /* expects slashed name */ JNU_ThrowClassNotFoundException(env, clname); goto done; &#125; // 从指定的加载器查找该类 cls = JVM_FindClassFromCaller(env, clname, initialize, loader, caller); done: if (clname != buf) &#123; free(clname); &#125; return cls;&#125; jvm.cpp # JVM_FindClassFromCaller()JVM_FindClassFromCaller方法位于src/hotspot/share/prims/jvm.cpp12345678910111213141516171819202122232425// 从指定的加载器查找该类// Find a class with this name in this loader, using the caller's protection domain.JVM_ENTRY(jclass, JVM_FindClassFromCaller(JNIEnv* env, const char* name, jboolean init, jobject loader, jclass caller)) // 把当前类加入符号表（一个哈希表实现） TempNewSymbol h_name = SymbolTable::new_symbol(name, CHECK_NULL); // 获取加载器和调用类 oop loader_oop = JNIHandles::resolve(loader); oop from_class = JNIHandles::resolve(caller); oop protection_domain = NULL; if (from_class != NULL &amp;&amp; loader_oop != NULL) &#123; protection_domain = java_lang_Class::as_Klass(from_class)-&gt;protection_domain(); &#125; // 查找该类 jclass result = find_class_from_class_loader(env, h_name, init, h_loader, h_prot, false, THREAD); // 返回结果 return result;JVM_END symbolTable.cpp # lookup()把当前类加入符号表，实现src/hotspot/share/classfile/symbolTable.cpp1234567891011121314151617181920212223// Symbol creationstatic Symbol* new_symbol(const char* utf8_buffer, int length, TRAPS) &#123; assert(utf8_buffer != NULL, "just checking"); return lookup(utf8_buffer, length, THREAD);&#125;Symbol* SymbolTable::lookup(const char* name, int len, TRAPS) &#123; unsigned int hashValue = hash_symbol(name, len); int index = the_table()-&gt;hash_to_index(hashValue); Symbol* s = the_table()-&gt;lookup(index, name, len, hashValue); // 找到则直接返回 // Found if (s != NULL) return s; // 先获取SymbolTable_lock MutexLocker ml(SymbolTable_lock, THREAD); // 然后把该类加入符号表 return the_table()-&gt;basic_add(index, (u1*)name, len, hashValue, true, THREAD);&#125; jvm.cpp # find_class_from_class_loader()加入符号表后紧接着在指定的classloader中查找该类，/src/hotspot/share/prims/jvm.cpp1234567891011121314151617181920// Shared JNI/JVM entry points //////////////////////////////////////////////////////////////// 从指定的classloader中查找类jclass find_class_from_class_loader(JNIEnv* env, Symbol* name, jboolean init, Handle loader, Handle protection_domain, jboolean throwError, TRAPS) &#123; //========================================== // // 根据指定的类名和加载器返回一个Klass对象，必要情况下需要加载该类。 // 如果未找到该类则抛出NoClassDefFoundError或ClassNotFoundException // //========================================= Klass* klass = SystemDictionary::resolve_or_fail(name, loader, protection_domain, throwError != 0, CHECK_NULL); // Check if we should initialize the class if (init &amp;&amp; klass-&gt;is_instance_klass()) &#123; klass-&gt;initialize(CHECK_NULL); &#125; return (jclass) JNIHandles::make_local(env, klass-&gt;java_mirror());&#125; systemDictionary.cpp # resolve_or_fail()方法SystemDictionary::resolve_or_fail()位于src/hotspot/share/classfile/systemDictionary.cpp12345678910// Forwards to resolve_or_nullKlass* SystemDictionary::resolve_or_fail(Symbol* class_name, Handle class_loader, Handle protection_domain, bool throw_error, TRAPS) &#123; Klass* klass = resolve_or_null(class_name, class_loader, protection_domain, THREAD); if (HAS_PENDING_EXCEPTION || klass == NULL) &#123; // can return a null klass klass = handle_resolution_exception(class_name, throw_error, klass, THREAD); &#125; return klass;&#125; systemDictionary.cpp # resolve_or_null()1234567891011121314151617// Forwards to resolve_instance_class_or_nullKlass* SystemDictionary::resolve_or_null(Symbol* class_name, Handle class_loader, Handle protection_domain, TRAPS) &#123; if (FieldType::is_array(class_name)) &#123; return resolve_array_class_or_null(class_name, class_loader, protection_domain, THREAD); &#125; else if (FieldType::is_obj(class_name)) &#123; ResourceMark rm(THREAD); // Ignore wrapping L and ;. TempNewSymbol name = SymbolTable::new_symbol(class_name-&gt;as_C_string() + 1, class_name-&gt;utf8_length() - 2, CHECK_NULL); return resolve_instance_class_or_null(name, class_loader, protection_domain, THREAD); &#125; else &#123; // 解析实例类 return resolve_instance_class_or_null(class_name, class_loader, protection_domain, THREAD); &#125;&#125; systemDictionary.cpp # resolve_instance_class_or_null()12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788Klass* SystemDictionary::resolve_instance_class_or_null(Symbol* name, Handle class_loader, Handle protection_domain, TRAPS) &#123; Handle lockObject = compute_loader_lock_object(class_loader, THREAD); check_loader_lock_contention(lockObject, THREAD); // 获取对象锁 ObjectLocker ol(lockObject, THREAD, DoObjectLock); &#123; MutexLocker mu(SystemDictionary_lock, THREAD); // 查找类 InstanceKlass* check = find_class(d_index, d_hash, name, dictionary); if (check != NULL) &#123; // Klass is already loaded, so just return it class_has_been_loaded = true; k = check; &#125; else &#123; // 查找该类是否在placeholder table中 placeholder = placeholders()-&gt;get_entry(p_index, p_hash, name, loader_data); if (placeholder &amp;&amp; placeholder-&gt;super_load_in_progress()) &#123; super_load_in_progress = true; if (placeholder-&gt;havesupername() == true) &#123; superclassname = placeholder-&gt;supername(); havesupername = true; &#125; &#125; &#125; &#125; // 如果该类在placeholder table中，则说明类加载进行中 if (super_load_in_progress &amp;&amp; havesupername==true) &#123; k = handle_parallel_super_load(name, superclassname, class_loader, protection_domain, lockObject, THREAD); if (HAS_PENDING_EXCEPTION) &#123; return NULL; &#125; if (k != NULL) &#123; class_has_been_loaded = true; &#125; &#125; bool throw_circularity_error = false; if (!class_has_been_loaded) &#123; bool load_instance_added = false; if (!class_has_been_loaded) &#123; // ===================================== // // 执行实例加载动作 // // ===================================== k = load_instance_class(name, class_loader, THREAD); if (!HAS_PENDING_EXCEPTION &amp;&amp; k != NULL &amp;&amp; k-&gt;class_loader() != class_loader()) &#123; check_constraints(d_index, d_hash, k, class_loader, false, THREAD); // Need to check for a PENDING_EXCEPTION again; check_constraints // can throw and doesn't use the CHECK macro. if (!HAS_PENDING_EXCEPTION) &#123; &#123; // Grabbing the Compile_lock prevents systemDictionary updates // during compilations. MutexLocker mu(Compile_lock, THREAD); update_dictionary(d_index, d_hash, p_index, p_hash, k, class_loader, THREAD); &#125; // 通知JVMTI类加载事件 if (JvmtiExport::should_post_class_load()) &#123; Thread *thread = THREAD; assert(thread-&gt;is_Java_thread(), "thread-&gt;is_Java_thread()"); JvmtiExport::post_class_load((JavaThread *) thread, k); &#125; &#125; &#125; &#125; // load_instance_class &#125; ... return k;&#125; systemDictionary.cpp # load_instance_class()123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119// ===================================================================================//// 加载实例class，这里有两种方式：// ===================================================================================//// 1、如果classloader为null则说明是加载系统类，使用bootstrap loader// 调用方式：直接调用ClassLoader::load_class()加载该类//// 2、如果classloader不为null则说明是非系统类，使用ext/app/自定义 classloader// 调用方式：通过JavaCalls::call_virtual()调用Java方法ClassLoader.loadClass()加载该类//// ===================================================================================InstanceKlass* SystemDictionary::load_instance_class(Symbol* class_name, Handle class_loader, TRAPS) &#123; // 使用bootstrap加载器加载 if (class_loader.is_null()) &#123; // 根据全限定名获取包名 // Find the package in the boot loader's package entry table. TempNewSymbol pkg_name = InstanceKlass::package_from_name(class_name, CHECK_NULL); if (pkg_name != NULL) &#123; pkg_entry = loader_data-&gt;packages()-&gt;lookup_only(pkg_name); &#125; InstanceKlass* k = NULL; if (k == NULL) &#123; // Use VM class loader PerfTraceTime vmtimer(ClassLoader::perf_sys_classload_time()); // ================================================================= // // 使用bootstrap loader加载该类 // // ================================================================= k = ClassLoader::load_class(class_name, search_only_bootloader_append, CHECK_NULL); &#125; return k; &#125; else &#123; // ======================================================================================= // // 使用用户指定的加载器加载该类，调用class_loader的loadClass操作方法， // 最终返回一个标准的InstanceKlass，流程如下 // // +-----------+ loadClass() +---------------+ get_jobject() +-------------+ // | className | -------------&gt; | JavaValue | ---------------&gt; | oop | // +-----------+ +---------------+ +-------------+ // | // | as_Klass() // v // +---------------+ cast() +-------------+ // | InstanceKlass | &lt;--------------- | Klass | // +---------------+ +-------------+ // // ======================================================================================= ResourceMark rm(THREAD); assert(THREAD-&gt;is_Java_thread(), "must be a JavaThread"); JavaThread* jt = (JavaThread*) THREAD; PerfClassTraceTime vmtimer(ClassLoader::perf_app_classload_time(), ClassLoader::perf_app_classload_selftime(), ClassLoader::perf_app_classload_count(), jt-&gt;get_thread_stat()-&gt;perf_recursion_counts_addr(), jt-&gt;get_thread_stat()-&gt;perf_timers_addr(), PerfClassTraceTime::CLASS_LOAD); Handle s = java_lang_String::create_from_symbol(class_name, CHECK_NULL); // Translate to external class name format, i.e., convert '/' chars to '.' Handle string = java_lang_String::externalize_classname(s, CHECK_NULL); JavaValue result(T_OBJECT); InstanceKlass* spec_klass = SystemDictionary::ClassLoader_klass(); // Added MustCallLoadClassInternal in case we discover in the field // a customer that counts on this call if (MustCallLoadClassInternal &amp;&amp; has_loadClassInternal()) &#123; JavaCalls::call_special(&amp;result, class_loader, spec_klass, vmSymbols::loadClassInternal_name(), vmSymbols::string_class_signature(), string, CHECK_NULL); &#125; else &#123; // =============================================================== // // 调用ClassLoader.loadClass()方法加载该类，而最终会调用ClassLoader的native方法defineClass1() // 其实现位于ClassLoader.c # Java_java_lang_ClassLoader_defineClass1() // // =============================================================== JavaCalls::call_virtual(&amp;result, class_loader, spec_klass, vmSymbols::loadClass_name(), vmSymbols::string_class_signature(), string, CHECK_NULL); &#125; assert(result.get_type() == T_OBJECT, "just checking"); // 获取oop对象 oop obj = (oop) result.get_jobject(); // 如果不是基本类，则转换成对应的InstanceKlass if ((obj != NULL) &amp;&amp; !(java_lang_Class::is_primitive(obj))) &#123; InstanceKlass* k = InstanceKlass::cast(java_lang_Class::as_Klass(obj)); if (class_name == k-&gt;name()) &#123; // 返回最终InstanceKlass return k; &#125; &#125; // Class is not found or has the wrong name, return NULL return NULL; &#125;&#125; 至此，JVM便完成了类型的InstanceKlass实例创建，这里两种加载方式中不管是通过bootstrap loader还是app(or自定义) loader均是殊途同归，都会经历class文件的装载、验证、准备、解析、初始化等操作。具体流程在下一篇文章中详细介绍。]]></content>
      <categories>
        <category>OpenJDK</category>
      </categories>
      <tags>
        <tag>OpenJDK</tag>
        <tag>JVM</tag>
        <tag>HotSpot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[集群架构中的异步回调模型实现]]></title>
    <url>%2Fpost%2F2018%2F05%2F06%2Fasync-callback-model-in-cluster-architecture%2F</url>
    <content type="text"><![CDATA[团队中前些天遇到这样一个问题，比较有意思也比较典型，我给出方案后团队成员实施出来，最终问题得以解决。 一个智能终端连接到Netty服务保持会话，在异步完成某项操作后回调回来需要通过会话通知终端，终端再根据通知做相应业务处理，在部署单节点的情况下是OK的，但是系统整体由于要做HA，部署多节点后就会出现问题: 并不能保证该回调请求一定负载到终端保持会话的节点。 如何解决这个问题？这里跟大家分享一种类似场景的通用解决方案，以下是流程图： 123456789101112131415161718192021222324252627 &lt; Async Callback Model in Cluster Architecture &gt; (D) Broadcast to all nodes +-----------------------------------------------------------------------+ v | + - - - - - - - - - + &apos; Cluster: &apos; &apos; &apos;+--------+ (A) Connect &apos; +---------------+ &apos; (B) Async call +---------------+ (C) Callback +----+| | -------------&gt; &apos; | Server Node A | &apos; ----------------&gt; | | --------------&gt; | || | &apos; +---------------+ &apos; | | | || | &apos; &apos; | | | || | + - - - - - - - - - + | | | || | (E) Notify : | | | || | &lt;................... | | | || | | | | || Client | + - - - - - - - - - + | Remote Server | | MQ || | &apos; &apos; | | | || | &apos; +---------------+ &apos; | | | || | &apos; | Server Node B | &apos; | | | || | &apos; +---------------+ &apos; | | | || | &apos; +---------------+ &apos; | | | || | &apos; | Server Node C | &apos; | | | || | &apos; +---------------+ &apos; | | | || | &apos; &apos; | | | |+--------+ + - - - - - - - - - + +---------------+ +----+ (A) 客户端向Server Node A发起请求并保持会话。 (B) 异步向Remote Server发起请求处理业务。 (C) Remote Server处理完成后回调将消息放入消息队列。 (D) MQ将回调消息以广播形式广播到集群各个节点。 (E) 各节点收到广播消息后，能取到对应客户端会话则处理，否则丢弃消息。 注：本案例中的客户端是以TCP连接至服务端，在HTTP服务中如果处理类似场景可以使用Java8中的CompletableFuture来实现。]]></content>
      <categories>
        <category>架构</category>
      </categories>
      <tags>
        <tag>架构</tag>
        <tag>集群</tag>
        <tag>异步</tag>
        <tag>回调</tag>
        <tag>Netty</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用Python十行代码打造简单爬虫]]></title>
    <url>%2Fpost%2F2018%2F05%2F05%2Fparse_web_content_and_download_files_using_python%2F</url>
    <content type="text"><![CDATA[今天从某网站上看到一些文档觉得还不错， 一共有300+篇，一个个手动下载？这简直是对一个程序员的侮辱。 怎么办呢，写个简单的爬虫吧。 BeautifulSoup是做爬虫的好手，requests是HTTP访问的强者，这里的Demo场景比较简单略显大材小用， 有效代码不超十行，十分简洁优雅，人生苦短，我用Python。 12345678910111213141516171819202122232425262728293031323334353637#!/usr/bin/env python# -*- coding:utf-8 -*-# author: HunterZhaoimport requestsfrom bs4 import BeautifulSoup'''解析网页内容并下载文件'''def parse_and_download(): url = 'http://docs.huihoo.com/javaone/2015/' r = requests.get(url) if r.status_code == requests.codes.ok: # 解析网页内容 soup = BeautifulSoup(r.text) # 获取到所有&lt;a&gt;标签 for e in soup.select('a'): # 获取到href属性，即文件名 file_name = e['href'] # 忽略返回上层的链接 if file_name == '../': continue # 读取文件 file_req = requests.get(url + file_name) # 写出文件 with open('/Users/hunterzhao/PycharmProjects/files/' + file_name, 'wb') as f: f.write(file_req.content) print(file_name + ' has been downloaded.') print('============= ALL DONE. ===============')if __name__ == '__main__': parse_and_download()]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>爬虫</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[聊一聊使用多线程处理MQ消息的正确姿势]]></title>
    <url>%2Fpost%2F2018%2F05%2F01%2Fconsume-mq-message-with-multithreading%2F</url>
    <content type="text"><![CDATA[Q：有这样一个场景，MQ的生产者生产消息能力是消费者的数倍。如果不能尽快消费完会导致队列中的消息随着时间的推移会越积越多，而且业务也无任何时效性可言，那么问题来了，在不增加消费节点的前提下如何快速处理完消息以保证吞吐量？ 面对以上问题，有人可能会信心满满地脱口而出：用多线程。OK，我只能说思路没错，那么如何落地呢？ 你可能会说使用JDK的ThreadPoolExecutor或者Executors线程池来处理。具体如何去用？只用线程池就够了吗？有什么坑吗？带着这些疑问，我们分别来深入分析一下看看是否能满足需求。 ThreadPoolExecutor()123456789101112131415161718192021222324252627282930313233private void exec() &#123; /* * 创建线程池 * corePoolSize 10 * maximumPoolSize 10 * queue capacity 10 */ ThreadPoolExecutor threadPoolExecutor = new ThreadPoolExecutor( 10, 10, 60, TimeUnit.SECONDS, new ArrayBlockingQueue&lt;Runnable&gt;(10)); // 提交100个任务 for (int i = 0; i &lt; 100; i++) &#123; threadPoolExecutor.submit(new WorkerThread()); &#125;&#125;/** * 任务线程 */private class WorkerThread implements Runnable &#123; public void run() &#123; System.out.println(new Date() + " " + Thread.currentThread().getName() + " is running..."); try &#123; TimeUnit.SECONDS.sleep(2); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 执行以上程序会抛出错误，原因是因为submit的任务数已经超出了其queue的容量，导致触发了拒绝策略。1Exception in thread &quot;main&quot; java.util.concurrent.RejectedExecutionException: Task java.util.concurrent.FutureTask@4d7e1886 Q: 能不能把有界队列ArrayBlockingQueue的容量尽量设置大一些呢？或者干脆换成无界队列LinkedBlockingQueue？ 由于队列中的消息数量无法提前预测具体数量，所以无法使设置准确默认值。 换成LinkedBlockingQueue虽然不会抛出以上错误，但这里会有一个问题：N多待处理任务临时放在JVM中，一方面占用大量内存，另一方面如果服务重启就会导致大量任务丢失。 既然无法从queue容量上去解决，那能否从线程池的拒绝策略着手？ JDK线程池有四种拒绝策略AbortPolicy、CallerRunsPolicy、 DiscardOledestPolicy、DiscardPolicy，默认使用AbortPolicy直接抛出异常。 其中AbortPolicy，DiscardOledestPolicy、DiscardPolicy均会直接丢弃任务肯定不符合预期，CallerRunsPolicy是将该任务抛给主线程执行，这里也会有一个问题，主线程在执行任务时是无法向线程池中提交任务的，假如主线程执行该任务需要3秒，在执行至第1秒的时候，线程池中已经有若干工作线程处于闲置状态，此时主线程需要执行完剩余的2秒才能继续向线程池工作线程分配任务，使用该拒绝策略虽然不会导致消息丢失，但也不能达到资源最优利用，所以pass。 所以，问题解决方案基本浮出水面， 主线程只负责分配任务，Worker线程只负责执行任务。 Worker线程执行完成后第一时间通知主线程，然后主线程及时分配任务。 这里，我们引入Semaphore作为令牌桶，以达到主线程和工作线程间通信的目的。 初始化与Worker线程数量相同的令牌 主线程向线程池提交任务时先尝试从令牌桶获取一个令牌，如果令牌桶为空则block。 把令牌传入Worker线程，Worker线程执行完后调用release()归还令牌。 最终代码参见以下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051/* 初始化与Worker线程数量相同的令牌 */private Semaphore permits = new Semaphore(10);private void exec() throws InterruptedException &#123; /* * 创建线程池 * corePoolSize 10 * maximumPoolSize 10 * queue capacity 10 */ ThreadPoolExecutor threadPoolExecutor = new ThreadPoolExecutor( 10, 10, 60, TimeUnit.SECONDS, new ArrayBlockingQueue&lt;Runnable&gt;(10)); for (int i = 0; i &lt; 100; i++) &#123; // 获取令牌，如果获取不到则block，直到有worker线程归还 permits.acquire(); // 提交任务 threadPoolExecutor.submit(new WorkerThread(permits)); &#125;&#125;/** * 任务线程 */private class WorkerThread implements Runnable &#123; private Semaphore permits; public WorkerThread(Semaphore permits) &#123; this.permits = permits; &#125; public void run() &#123; System.out.println(new Date() + " " + Thread.currentThread().getName() + " is running..."); try &#123; TimeUnit.SECONDS.sleep(2); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; finally &#123; if (permits != null) &#123; // 释放令牌 permits.release(); &#125; &#125; &#125;&#125; 或者使用更为简洁的Executors框架，上面的代码会变成： 12345678910111213141516171819202122232425262728293031323334353637383940414243/* Worker任务线程池 */private Executor taskPool = Executors.newFixedThreadPool(10);/* 初始化与Worker线程数量相同的令牌 */private Semaphore permits = new Semaphore(10);private void exec() throws InterruptedException &#123; for (int i = 0; i &lt; 100; i++) &#123; // 获取令牌，如果获取不到则block，直到有worker线程归还 permits.acquire(); taskPool.execute(new WorkerThread(permits)); &#125;&#125;/** * 任务线程 */private class WorkerThread implements Runnable &#123; private Semaphore permits; public WorkerThread(Semaphore permits) &#123; this.permits = permits; &#125; public void run() &#123; try &#123; // do sth &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; if (permits != null) &#123; // 释放令牌 permits.release(); &#125; &#125; &#125;&#125;]]></content>
      <categories>
        <category>多线程</category>
      </categories>
      <tags>
        <tag>多线程</tag>
        <tag>MQ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【JVM源码探秘】深入registerNatives()底层实现]]></title>
    <url>%2Fpost%2F2018%2F04%2F06%2Fhotspot-explore-register-natives%2F</url>
    <content type="text"><![CDATA[在Java的系统包下如： java.lang.System java.lang.Object java.lang.Class 等类中均有一个静态块用来执行一个叫做registerNatives()的native方法， 1234private static native void registerNatives();static &#123; registerNatives();&#125; 这个native方法里究竟都做了啥？我们进去瞧瞧。 System.c12345678910111213141516/* Only register the performance-critical methods */static JNINativeMethod methods[] = &#123; &#123;"currentTimeMillis", "()J", (void *)&amp;JVM_CurrentTimeMillis&#125;, &#123;"nanoTime", "()J", (void *)&amp;JVM_NanoTime&#125;, &#123;"arraycopy", "(" OBJ "I" OBJ "II)V", (void *)&amp;JVM_ArrayCopy&#125;,&#125;;#undef OBJJNIEXPORT void JNICALLJava_java_lang_System_registerNatives(JNIEnv *env, jclass cls)&#123; // 注册本地方法 (*env)-&gt;RegisterNatives(env, cls, methods, sizeof(methods)/sizeof(methods[0]));&#125; Object.c123456789101112131415static JNINativeMethod methods[] = &#123; &#123;"hashCode", "()I", (void *)&amp;JVM_IHashCode&#125;, &#123;"wait", "(J)V", (void *)&amp;JVM_MonitorWait&#125;, &#123;"notify", "()V", (void *)&amp;JVM_MonitorNotify&#125;, &#123;"notifyAll", "()V", (void *)&amp;JVM_MonitorNotifyAll&#125;, &#123;"clone", "()Ljava/lang/Object;", (void *)&amp;JVM_Clone&#125;,&#125;;JNIEXPORT void JNICALLJava_java_lang_Object_registerNatives(JNIEnv *env, jclass cls)&#123; // 注册本地方法 (*env)-&gt;RegisterNatives(env, cls, methods, sizeof(methods)/sizeof(methods[0]));&#125; Class.c1234567891011121314151617181920212223242526272829303132333435static JNINativeMethod methods[] = &#123; &#123;"getName0", "()" STR, (void *)&amp;JVM_GetClassName&#125;, &#123;"getSuperclass", "()" CLS, NULL&#125;, &#123;"getInterfaces0", "()[" CLS, (void *)&amp;JVM_GetClassInterfaces&#125;, &#123;"isInterface", "()Z", (void *)&amp;JVM_IsInterface&#125;, &#123;"getSigners", "()[" OBJ, (void *)&amp;JVM_GetClassSigners&#125;, &#123;"setSigners", "([" OBJ ")V", (void *)&amp;JVM_SetClassSigners&#125;, &#123;"isArray", "()Z", (void *)&amp;JVM_IsArrayClass&#125;, &#123;"isPrimitive", "()Z", (void *)&amp;JVM_IsPrimitiveClass&#125;, &#123;"getModifiers", "()I", (void *)&amp;JVM_GetClassModifiers&#125;, &#123;"getDeclaredFields0","(Z)[" FLD, (void *)&amp;JVM_GetClassDeclaredFields&#125;, &#123;"getDeclaredMethods0","(Z)[" MHD, (void *)&amp;JVM_GetClassDeclaredMethods&#125;, &#123;"getDeclaredConstructors0","(Z)[" CTR, (void *)&amp;JVM_GetClassDeclaredConstructors&#125;, &#123;"getProtectionDomain0", "()" PD, (void *)&amp;JVM_GetProtectionDomain&#125;, &#123;"getDeclaredClasses0", "()[" CLS, (void *)&amp;JVM_GetDeclaredClasses&#125;, &#123;"getDeclaringClass0", "()" CLS, (void *)&amp;JVM_GetDeclaringClass&#125;, &#123;"getSimpleBinaryName0", "()" STR, (void *)&amp;JVM_GetSimpleBinaryName&#125;, &#123;"getGenericSignature0", "()" STR, (void *)&amp;JVM_GetClassSignature&#125;, &#123;"getRawAnnotations", "()" BA, (void *)&amp;JVM_GetClassAnnotations&#125;, &#123;"getConstantPool", "()" CPL, (void *)&amp;JVM_GetClassConstantPool&#125;, &#123;"desiredAssertionStatus0","("CLS")Z",(void *)&amp;JVM_DesiredAssertionStatus&#125;, &#123;"getEnclosingMethod0", "()[" OBJ, (void *)&amp;JVM_GetEnclosingMethodInfo&#125;, &#123;"getRawTypeAnnotations", "()" BA, (void *)&amp;JVM_GetClassTypeAnnotations&#125;,&#125;;JNIEXPORT void JNICALLJava_java_lang_Class_registerNatives(JNIEnv *env, jclass cls)&#123; // 注册本地方法 methods[1].fnPtr = (void *)(*env)-&gt;GetSuperclass; (*env)-&gt;RegisterNatives(env, cls, methods, sizeof(methods)/sizeof(JNINativeMethod));&#125; jni.cpp # jni_RegisterNatives()通过以上源码发现均调用的(*env)-&gt;RegisterNatives(env, cls, methods...，这里的*env为JNI环境，方法进入jni_RegisterNatives() 1234567891011121314151617181920212223242526272829303132333435363738394041424344 // 注册Java系统类中的本地方法JNI_ENTRY(jint, jni_RegisterNatives(JNIEnv *env, jclass clazz, const JNINativeMethod *methods, jint nMethods)) JNIWrapper("RegisterNatives"); HOTSPOT_JNI_REGISTERNATIVES_ENTRY(env, clazz, (void *) methods, nMethods); jint ret = 0; DT_RETURN_MARK(RegisterNatives, jint, (const jint&amp;)ret); // 加载对应的类并转换成Klass对象 Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(clazz)); for (int index = 0; index &lt; nMethods; index++) &#123; const char* meth_name = methods[index].name; const char* meth_sig = methods[index].signature; int meth_name_len = (int)strlen(meth_name); // The class should have been loaded (we have an instance of the class // passed in) so the method and signature should already be in the symbol // table. If they're not there, the method doesn't exist. // 方法名 TempNewSymbol name = SymbolTable::probe(meth_name, meth_name_len); // 方法签名 TempNewSymbol signature = SymbolTable::probe(meth_sig, (int)strlen(meth_sig)); // 如果没找到该方法则抛出java.lang.NoSuchMethodError() if (name == NULL || signature == NULL) &#123; ResourceMark rm; stringStream st; st.print("Method %s.%s%s not found", k-&gt;external_name(), meth_name, meth_sig); // Must return negative value on failure THROW_MSG_(vmSymbols::java_lang_NoSuchMethodError(), st.as_string(), -1); &#125; // 执行注册本地方法 bool res = register_native(k, name, signature, (address) methods[index].fnPtr, THREAD); if (!res) &#123; ret = -1; break; &#125; &#125; return ret;JNI_END jni.cpp # register_native()1234567891011121314151617181920212223242526272829303132333435363738static bool register_native(Klass* k, Symbol* name, Symbol* signature, address entry, TRAPS) &#123; // 找到对应的方法 Method* method = k-&gt;lookup_method(name, signature); if (method == NULL) &#123; ResourceMark rm; stringStream st; st.print("Method %s name or signature does not match", Method::name_and_sig_as_C_string(k, name, signature)); THROW_MSG_(vmSymbols::java_lang_NoSuchMethodError(), st.as_string(), false); &#125; if (!method-&gt;is_native()) &#123; // 检查JVMTI是否指定native方法前缀 // trying to register to a non-native method, see if a JVM TI agent has added prefix(es) method = find_prefixed_native(k, name, signature, THREAD); if (method == NULL) &#123; ResourceMark rm; stringStream st; st.print("Method %s is not declared as native", Method::name_and_sig_as_C_string(k, name, signature)); THROW_MSG_(vmSymbols::java_lang_NoSuchMethodError(), st.as_string(), false); &#125; &#125; if (entry != NULL) &#123; // 设置本为本地方法 method-&gt;set_native_function(entry, Method::native_bind_event_is_interesting); &#125; else &#123; method-&gt;clear_native_function(); &#125; if (PrintJNIResolving) &#123; ResourceMark rm(THREAD); tty-&gt;print_cr("[Registering JNI native method %s.%s]", method-&gt;method_holder()-&gt;external_name(), method-&gt;name()-&gt;as_C_string()); &#125; return true;&#125;]]></content>
      <categories>
        <category>OpenJDK</category>
      </categories>
      <tags>
        <tag>OpenJDK</tag>
        <tag>JVM</tag>
        <tag>HotSpot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【JVM源码探秘】深入System.gc()底层实现]]></title>
    <url>%2Fpost%2F2018%2F04%2F05%2Fhotspot-explore-system-gc%2F</url>
    <content type="text"><![CDATA[对于Java语言来说是不用手动释放内存的，并且不需要手动干预JVM的GC行为，但在一些监控和agent工具里却是必要的。 Hotspot为我们开放了Java语言级别的GC手动触发入口System.gc()，本文将深入介绍JVM底层实现。 java.lang.System#gc()123456789101112131415161718192021/** * Runs the garbage collector. * &lt;p&gt; * Calling the &lt;code&gt;gc&lt;/code&gt; method suggests that the Java Virtual * Machine expend effort toward recycling unused objects in order to * make the memory they currently occupy available for quick reuse. * When control returns from the method call, the Java Virtual * Machine has made a best effort to reclaim space from all discarded * objects. * &lt;p&gt; * The call &lt;code&gt;System.gc()&lt;/code&gt; is effectively equivalent to the * call: * &lt;blockquote&gt;&lt;pre&gt; * Runtime.getRuntime().gc() * &lt;/pre&gt;&lt;/blockquote&gt; * * @see java.lang.Runtime#gc() */public static void gc() &#123; Runtime.getRuntime().gc();&#125; java.lang.Runtime#gc()1234567891011121314151617/** * Runs the garbage collector. * Calling this method suggests that the Java virtual machine expend * effort toward recycling unused objects in order to make the memory * they currently occupy available for quick reuse. When control * returns from the method call, the virtual machine has made * its best effort to recycle all discarded objects. * &lt;p&gt; * The name &lt;code&gt;gc&lt;/code&gt; stands for "garbage * collector". The virtual machine performs this recycling * process automatically as needed, in a separate thread, even if the * &lt;code&gt;gc&lt;/code&gt; method is not invoked explicitly. * &lt;p&gt; * The method &#123;@link System#gc()&#125; is the conventional and convenient * means of invoking this method. */public native void gc(); Runtime.c # Java_java_lang_Runtime_gc()这里调用了native方法gc()，对应的方法在Hotspot源码src/java.base/share/native/libjava/Runtime.c 12345JNIEXPORT void JNICALLJava_java_lang_Runtime_gc(JNIEnv *env, jobject this)&#123; JVM_GC();&#125; jvm.cpp方法实现在src/hotspot/share/prims/jvm.cpp 1234567JVM_ENTRY_NO_ENV(void, JVM_GC(void)) JVMWrapper("JVM_GC"); if (!DisableExplicitGC) &#123; // 调用具体堆实现的collect方法 Universe::heap()-&gt;collect(GCCause::_java_lang_system_gc); &#125;JVM_END 通过Universe调用具体堆实现的collect方法，取决于使用当前实例使用的GC模式，在JVM中目前堆实现主要有： 串行回收堆实现 src/hotspot/share/gc/serial/defNewGeneration.cpp（年轻代） src/hotspot/share/gc/serial/tenuredGeneration.cpp（年老代） 并行回收堆实现 src/hotspot/share/gc/parallel/parallelScavengeHeap.cpp CMS并发回收堆实现 src/hotspot/share/gc/shared/genCollectedHeap.cpp G1并发回收堆实现 src/hotspot/share/gc/g1/g1CollectedHeap.cpp 串行回收堆（年轻代）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156void DefNewGeneration::collect(bool full, bool clear_all_soft_refs, size_t size, bool is_tlab) &#123; assert(full || size &gt; 0, "otherwise we don't want to collect"); GenCollectedHeap* gch = GenCollectedHeap::heap(); _gc_timer-&gt;register_gc_start(); DefNewTracer gc_tracer; gc_tracer.report_gc_start(gch-&gt;gc_cause(), _gc_timer-&gt;gc_start()); _old_gen = gch-&gt;old_gen(); // 如果下个代空间不足以容纳当前代空间中即将晋升的对象，则标记让下个代空间先进行回收 // If the next generation is too full to accommodate promotion // from this generation, pass on collection; let the next generation // do it. if (!collection_attempt_is_safe()) &#123; log_trace(gc)(":: Collection attempt not safe ::"); gch-&gt;set_incremental_collection_failed(); // Slight lie: we did not even attempt one return; &#125; assert(to()-&gt;is_empty(), "Else not collection_attempt_is_safe"); init_assuming_no_promotion_failure(); GCTraceTime(Trace, gc, phases) tm("DefNew", NULL, gch-&gt;gc_cause()); gch-&gt;trace_heap_before_gc(&amp;gc_tracer); // These can be shared for all code paths IsAliveClosure is_alive(this); ScanWeakRefClosure scan_weak_ref(this); age_table()-&gt;clear(); to()-&gt;clear(SpaceDecorator::Mangle); // The preserved marks should be empty at the start of the GC. _preserved_marks_set.init(1); gch-&gt;rem_set()-&gt;prepare_for_younger_refs_iterate(false); assert(gch-&gt;no_allocs_since_save_marks(), "save marks have not been newly set."); // Not very pretty. CollectorPolicy* cp = gch-&gt;collector_policy(); FastScanClosure fsc_with_no_gc_barrier(this, false); FastScanClosure fsc_with_gc_barrier(this, true); KlassScanClosure klass_scan_closure(&amp;fsc_with_no_gc_barrier, gch-&gt;rem_set()-&gt;klass_rem_set()); CLDToKlassAndOopClosure cld_scan_closure(&amp;klass_scan_closure, &amp;fsc_with_no_gc_barrier, false); set_promo_failure_scan_stack_closure(&amp;fsc_with_no_gc_barrier); FastEvacuateFollowersClosure evacuate_followers(gch, &amp;fsc_with_no_gc_barrier, &amp;fsc_with_gc_barrier); assert(gch-&gt;no_allocs_since_save_marks(), "save marks have not been newly set."); &#123; // DefNew needs to run with n_threads == 0, to make sure the serial // version of the card table scanning code is used. // See: CardTableModRefBSForCTRS::non_clean_card_iterate_possibly_parallel. StrongRootsScope srs(0); gch-&gt;young_process_roots(&amp;srs, &amp;fsc_with_no_gc_barrier, &amp;fsc_with_gc_barrier, &amp;cld_scan_closure); &#125; // "evacuate followers". evacuate_followers.do_void(); FastKeepAliveClosure keep_alive(this, &amp;scan_weak_ref); ReferenceProcessor* rp = ref_processor(); rp-&gt;setup_policy(clear_all_soft_refs); ReferenceProcessorPhaseTimes pt(_gc_timer, rp-&gt;num_q()); const ReferenceProcessorStats&amp; stats = rp-&gt;process_discovered_references(&amp;is_alive, &amp;keep_alive, &amp;evacuate_followers, NULL, &amp;pt); gc_tracer.report_gc_reference_stats(stats); gc_tracer.report_tenuring_threshold(tenuring_threshold()); pt.print_all_references(); if (!_promotion_failed) &#123; // Swap the survivor spaces. eden()-&gt;clear(SpaceDecorator::Mangle); from()-&gt;clear(SpaceDecorator::Mangle); if (ZapUnusedHeapArea) &#123; // This is now done here because of the piece-meal mangling which // can check for valid mangling at intermediate points in the // collection(s). When a young collection fails to collect // sufficient space resizing of the young generation can occur // an redistribute the spaces in the young generation. Mangle // here so that unzapped regions don't get distributed to // other spaces. to()-&gt;mangle_unused_area(); &#125; swap_spaces(); assert(to()-&gt;is_empty(), "to space should be empty now"); adjust_desired_tenuring_threshold(); // A successful scavenge should restart the GC time limit count which is // for full GC's. AdaptiveSizePolicy* size_policy = gch-&gt;gen_policy()-&gt;size_policy(); size_policy-&gt;reset_gc_overhead_limit_count(); assert(!gch-&gt;incremental_collection_failed(), "Should be clear"); &#125; else &#123; assert(_promo_failure_scan_stack.is_empty(), "post condition"); _promo_failure_scan_stack.clear(true); // Clear cached segments. remove_forwarding_pointers(); log_info(gc, promotion)("Promotion failed"); // Add to-space to the list of space to compact // when a promotion failure has occurred. In that // case there can be live objects in to-space // as a result of a partial evacuation of eden // and from-space. swap_spaces(); // For uniformity wrt ParNewGeneration. from()-&gt;set_next_compaction_space(to()); gch-&gt;set_incremental_collection_failed(); // Inform the next generation that a promotion failure occurred. _old_gen-&gt;promotion_failure_occurred(); gc_tracer.report_promotion_failed(_promotion_failed_info); // Reset the PromotionFailureALot counters. NOT_PRODUCT(gch-&gt;reset_promotion_should_fail();) &#125; // We should have processed and cleared all the preserved marks. _preserved_marks_set.reclaim(); // set new iteration safe limit for the survivor spaces from()-&gt;set_concurrent_iteration_safe_limit(from()-&gt;top()); to()-&gt;set_concurrent_iteration_safe_limit(to()-&gt;top()); // We need to use a monotonically non-decreasing time in ms // or we will see time-warp warnings and os::javaTimeMillis() // does not guarantee monotonicity. jlong now = os::javaTimeNanos() / NANOSECS_PER_MILLISEC; update_time_of_last_gc(now); gch-&gt;trace_heap_after_gc(&amp;gc_tracer); _gc_timer-&gt;register_gc_end(); gc_tracer.report_gc_end(_gc_timer-&gt;gc_end(), _gc_timer-&gt;time_partitions());&#125; 串行回收堆（年老代）123456789101112131415161718192021222324252627void TenuredGeneration::collect(bool full, bool clear_all_soft_refs, size_t size, bool is_tlab) &#123; GenCollectedHeap* gch = GenCollectedHeap::heap(); // Temporarily expand the span of our ref processor, so // refs discovery is over the entire heap, not just this generation ReferenceProcessorSpanMutator x(ref_processor(), gch-&gt;reserved_region()); STWGCTimer* gc_timer = GenMarkSweep::gc_timer(); gc_timer-&gt;register_gc_start(); SerialOldTracer* gc_tracer = GenMarkSweep::gc_tracer(); gc_tracer-&gt;report_gc_start(gch-&gt;gc_cause(), gc_timer-&gt;gc_start()); gch-&gt;pre_full_gc_dump(gc_timer); GenMarkSweep::invoke_at_safepoint(ref_processor(), clear_all_soft_refs); gch-&gt;post_full_gc_dump(gc_timer); gc_timer-&gt;register_gc_end(); gc_tracer-&gt;report_gc_end(gc_timer-&gt;gc_end(), gc_timer-&gt;time_partitions());&#125; 串行回收堆1234567891011121314151617// This method is used by System.gc() and JVMTI.void ParallelScavengeHeap::collect(GCCause::Cause cause) &#123; assert(!Heap_lock-&gt;owned_by_self(), "this thread should not own the Heap_lock"); uint gc_count = 0; uint full_gc_count = 0; &#123; MutexLocker ml(Heap_lock); // This value is guarded by the Heap_lock gc_count = total_collections(); full_gc_count = total_full_collections(); &#125; VM_ParallelGCSystemGC op(gc_count, full_gc_count, cause); VMThread::execute(&amp;op);&#125; CMS分代并发回收堆12345678910111213141516171819202122232425262728// public collection interfacesvoid GenCollectedHeap::collect(GCCause::Cause cause) &#123; if (should_do_concurrent_full_gc(cause)) &#123;#if INCLUDE_ALL_GCS // Mostly concurrent full collection. collect_mostly_concurrent(cause);#else // INCLUDE_ALL_GCS ShouldNotReachHere();#endif // INCLUDE_ALL_GCS &#125; else if (cause == GCCause::_wb_young_gc) &#123; // Young collection for the WhiteBox API. collect(cause, YoungGen); &#125; else &#123;#ifdef ASSERT if (cause == GCCause::_scavenge_alot) &#123; // Young collection only. collect(cause, YoungGen); &#125; else &#123; // Stop-the-world full collection. collect(cause, OldGen); &#125;#else // Stop-the-world full collection. collect(cause, OldGen);#endif &#125;&#125; G1并发回收堆12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667void G1CollectedHeap::collect(GCCause::Cause cause) &#123; assert_heap_not_locked(); uint gc_count_before; uint old_marking_count_before; uint full_gc_count_before; bool retry_gc; do &#123; retry_gc = false; &#123; MutexLocker ml(Heap_lock); // Read the GC count while holding the Heap_lock gc_count_before = total_collections(); full_gc_count_before = total_full_collections(); old_marking_count_before = _old_marking_cycles_started; &#125; if (should_do_concurrent_full_gc(cause)) &#123; // Schedule an initial-mark evacuation pause that will start a // concurrent cycle. We're setting word_size to 0 which means that // we are not requesting a post-GC allocation. VM_G1IncCollectionPause op(gc_count_before, 0, /* word_size */ true, /* should_initiate_conc_mark */ g1_policy()-&gt;max_pause_time_ms(), cause); op.set_allocation_context(AllocationContext::current()); VMThread::execute(&amp;op); if (!op.pause_succeeded()) &#123; if (old_marking_count_before == _old_marking_cycles_started) &#123; retry_gc = op.should_retry_gc(); &#125; else &#123; // A Full GC happened while we were trying to schedule the // initial-mark GC. No point in starting a new cycle given // that the whole heap was collected anyway. &#125; if (retry_gc) &#123; if (GCLocker::is_active_and_needs_gc()) &#123; GCLocker::stall_until_clear(); &#125; &#125; &#125; &#125; else &#123; if (cause == GCCause::_gc_locker || cause == GCCause::_wb_young_gc DEBUG_ONLY(|| cause == GCCause::_scavenge_alot)) &#123; // Schedule a standard evacuation pause. We're setting word_size // to 0 which means that we are not requesting a post-GC allocation. VM_G1IncCollectionPause op(gc_count_before, 0, /* word_size */ false, /* should_initiate_conc_mark */ g1_policy()-&gt;max_pause_time_ms(), cause); VMThread::execute(&amp;op); &#125; else &#123; // Schedule a Full GC. VM_G1CollectFull op(gc_count_before, full_gc_count_before, cause); VMThread::execute(&amp;op); &#125; &#125; &#125; while (retry_gc);&#125;]]></content>
      <categories>
        <category>OpenJDK</category>
      </categories>
      <tags>
        <tag>OpenJDK</tag>
        <tag>JVM</tag>
        <tag>HotSpot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【JVM源码探秘】Java对象模型之对象头]]></title>
    <url>%2Fpost%2F2018%2F02%2F25%2Fhotspot-explore-java-object-header%2F</url>
    <content type="text"><![CDATA[一个Java对象在JVM中是由一个对应角色的oop对象来描述的，比如instanceOopDesc用来描述普通实例对象，arrayOopDesc用来描述数组对象，而这些类型的oop对象均是继承自oopDesc。 123456789101112class oopDesc &#123; friend class VMStructs; friend class JVMCIVMStructs;private: // 对象头 volatile markOop _mark; // 元数据 union _metadata &#123; // 对应的Klass对象 Klass* _klass; narrowKlass _compressed_klass; &#125; _metadata; oopDesc主要包含两部分，一部分是_mark，一部分是_metadata， _mark _mark是一个markOop实例，它描述了一个对象的头信息，用于存储对象的运行时记录信息，如哈希值、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等： 123456789101112131415161718// 32 bits:// --------// hash:25 ------------&gt;| age:4 biased_lock:1 lock:2 (normal object)// JavaThread*:23 epoch:2 age:4 biased_lock:1 lock:2 (biased object)// size:32 ------------------------------------------&gt;| (CMS free block)// PromotedObject*:29 ----------&gt;| promo_bits:3 -----&gt;| (CMS promoted object)//// 64 bits:// --------// unused:25 hash:31 --&gt;| unused:1 age:4 biased_lock:1 lock:2 (normal object)// JavaThread*:54 epoch:2 unused:1 age:4 biased_lock:1 lock:2 (biased object)// PromotedObject*:61 ---------------------&gt;| promo_bits:3 -----&gt;| (CMS promoted object)// size:64 -----------------------------------------------------&gt;| (CMS free block)//// unused:25 hash:31 --&gt;| cms_free:1 age:4 biased_lock:1 lock:2 (COOPs &amp;&amp; normal object)// JavaThread*:54 epoch:2 cms_free:1 age:4 biased_lock:1 lock:2 (COOPs &amp;&amp; biased object)// narrowOop:32 unused:24 cms_free:1 unused:4 promo_bits:3 -----&gt;| (COOPs &amp;&amp; CMS promoted object)// unused:21 size:35 --&gt;| cms_free:1 unused:7 ------------------&gt;| (COOPs &amp;&amp; CMS free block) _metadata 包含一个普通_klass和一个压缩后的_compressed_klass，详细信息参见OpenJDK Wiki。]]></content>
      <categories>
        <category>OpenJDK</category>
      </categories>
      <tags>
        <tag>OpenJDK</tag>
        <tag>JVM</tag>
        <tag>HotSpot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【JVM源码探秘】Java对象模型OOP-Klass]]></title>
    <url>%2Fpost%2F2018%2F02%2F24%2Fhotspot-explore-java-object-model-oop-klass%2F</url>
    <content type="text"><![CDATA[一个Java类在JVM中是如何描述的？创建一个Java对象在JVM中数据又是如何存储的？ 在Hotspot VM中，设计者设计了OOP-Klass模型用来描述class的属性和行为，这里的OOP并不是面向对象编程（Object-oriented programming），而是Ordinary Object Pointer（普通对象指针），之所以设计为OOP和Klass两部分是因为不希望每个对象都有一个C ++ vtbl指针，因此，普通的oops没有任何虚拟功能。 相反，他们将所有“虚拟”函数转发到它们的klass，它具有vtbl并根据对象的实际类型执行C ++调度。 OOPoopDesc是对象类的最高基类。 {name}Desc类描述了Java对象的格式，因此可以从C++访问这些字段。 oopDesc是抽象的。 123456789101112class oopDesc &#123; friend class VMStructs; friend class JVMCIVMStructs;private: // 对象头 volatile markOop _mark; // 元数据 union _metadata &#123; // 对应的Klass对象 Klass* _klass; narrowKlass _compressed_klass; &#125; _metadata; 有关完整的类层次结构，请参见src/hotspot/share/oops/oopsHierarchy.hpp OOP体系如下：12345typedef class oopDesc* oop;typedef class instanceOopDesc* instanceOop;typedef class arrayOopDesc* arrayOop;typedef class objArrayOopDesc* objArrayOop;typedef class typeArrayOopDesc* typeArrayOop; KlassKlass体系如下：12345678class Klass;class InstanceKlass;class InstanceMirrorKlass;class InstanceClassLoaderKlass;class InstanceRefKlass;class ArrayKlass;class ObjArrayKlass;class TypeArrayKlass; Klass对象提供： 1：语言级别的类对象（方法字典等） 2：为对象提供虚拟机调度行为 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364class Klass : public Metadata &#123; friend class VMStructs; friend class JVMCIVMStructs; protected: // If you add a new field that points to any metaspace object, you // must add this field to Klass::metaspace_pointers_do(). enum &#123; _primary_super_limit = 8 &#125;; // The "layout helper" is a combined descriptor of object layout. // For klasses which are neither instance nor array, the value is zero. jint _layout_helper; // 类名 // Class name. Instance classes: java/lang/String, etc. Array classes: [I, // [Ljava/lang/String;, etc. Set to zero for all other kinds of classes. Symbol* _name; // Cache of last observed secondary supertype Klass* _secondary_super_cache; // Array of all secondary supertypes Array&lt;Klass*&gt;* _secondary_supers; // Ordered list of all primary supertypes Klass* _primary_supers[_primary_super_limit]; // java.lang.Class镜像类 // java/lang/Class instance mirroring this class oop _java_mirror; // 父类 // Superclass Klass* _super; // First subclass (NULL if none); _subklass-&gt;next_sibling() is next one Klass* _subklass; // Sibling link (or NULL); links all subklasses of a klass Klass* _next_sibling; // All klasses loaded by a class loader are chained through these links Klass* _next_link; // 加载该类的类加载器 // The VM's representation of the ClassLoader used to load this class. // Provide access the corresponding instance java.lang.ClassLoader. ClassLoaderData* _class_loader_data; // 修饰符 jint _modifier_flags; // Processed access flags, for use by Class.getModifiers. // 访问权限 AccessFlags _access_flags; // Access flags. The class/interface distinction is stored here. TRACE_DEFINE_TRACE_ID_FIELD; // 偏向锁实现 // Biased locking implementation and statistics // (the 64-bit chunk goes first, to avoid some fragmentation) jlong _last_biased_lock_bulk_revocation_time; markOop _prototype_header; // Used when biased locking is both enabled and disabled for this type jint _biased_lock_revocation_count; // 虚拟表长度 // vtable length int _vtable_len; // Remembered sets support for the oops in the klasses. jbyte _modified_oops; // Card Table Equivalent (YC/CMS support) jbyte _accumulated_modified_oops; // Mod Union Equivalent (CMS support)]]></content>
      <categories>
        <category>OpenJDK</category>
      </categories>
      <tags>
        <tag>OpenJDK</tag>
        <tag>JVM</tag>
        <tag>HotSpot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【JVM源码探秘】HotSpot启动流程分析-初始化]]></title>
    <url>%2Fpost%2F2018%2F02%2F23%2Fhotspot-explore-startup-process-initialization%2F</url>
    <content type="text"><![CDATA[接上篇，HotSpot在启动流程完成了参数的解析、JNI入口的定位、环境变量的设置等一系列操作， 最终在JavaMain()中调用了InitializeJVM()方法，用于完成虚拟机所需的内存申请、挂载和初始化，本文我们就一起一探究竟。 java.c # InitializeJVM()123456789101112131415161718192021222324252627282930313233/* * Initializes the Java Virtual Machine. Also frees options array when * finished. */static jbooleanInitializeJVM(JavaVM **pvm, JNIEnv **penv, InvocationFunctions *ifn)&#123; JavaVMInitArgs args; jint r; memset(&amp;args, 0, sizeof(args)); args.version = JNI_VERSION_1_2; args.nOptions = numOptions; args.options = options; args.ignoreUnrecognized = JNI_FALSE; if (JLI_IsTraceLauncher()) &#123; int i = 0; printf("JavaVM args:\n "); printf("version 0x%08lx, ", (long)args.version); printf("ignoreUnrecognized is %s, ", args.ignoreUnrecognized ? "JNI_TRUE" : "JNI_FALSE"); printf("nOptions is %ld\n", (long)args.nOptions); for (i = 0; i &lt; numOptions; i++) printf(" option[%2d] = '%s'\n", i, args.options[i].optionString); &#125; // 调用JNI_CreateJavaVM方法 r = ifn-&gt;CreateJavaVM(pvm, (void **)penv, &amp;args); JLI_MemFree(options); return r == JNI_OK;&#125; jni.cpp # JNI_CreateJavaVM()此处调用了之前加载的JNI_CreateJavaVM方法，位于src/hotspot/share/prims/jni.cpp 1234567891011121314_JNI_IMPORT_OR_EXPORT_ jint JNICALL JNI_CreateJavaVM(JavaVM **vm, void **penv, void *args) &#123; jint result = JNI_ERR; // On Windows, let CreateJavaVM run with SEH protection#ifdef _WIN32 __try &#123;#endif result = JNI_CreateJavaVM_inner(vm, penv, args);#ifdef _WIN32 &#125; __except(topLevelExceptionFilter((_EXCEPTION_POINTERS*)_exception_info())) &#123; // Nothing to do. &#125;#endif return result;&#125; jni.cpp # JNI_CreateJavaVM_inner()JNI_CreateJavaVM()调用了内部方法JNI_CreateJavaVM_inner() 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455static jint JNI_CreateJavaVM_inner(JavaVM **vm, void **penv, void *args) &#123; HOTSPOT_JNI_CREATEJAVAVM_ENTRY((void **) vm, penv, args); /** * Certain errors during initialization are recoverable and do not * prevent this method from being called again at a later time * (perhaps with different arguments). However, at a certain * point during initialization if an error occurs we cannot allow * this function to be called again (or it will crash). In those * situations, the 'canTryAgain' flag is set to false, which atomically * sets safe_to_recreate_vm to 1, such that any new call to * JNI_CreateJavaVM will immediately fail using the above logic. */ bool can_try_again = true; // ================================= // 创建虚拟机 // ================================= result = Threads::create_vm((JavaVMInitArgs*) args, &amp;can_try_again); // 如果创建成功 if (result == JNI_OK) &#123; JavaThread *thread = JavaThread::current(); assert(!thread-&gt;has_pending_exception(), "should have returned not OK"); /* thread is thread_in_vm here */ *vm = (JavaVM *)(&amp;main_vm); *(JNIEnv**)penv = thread-&gt;jni_environment(); // Tracks the time application was running before GC RuntimeService::record_application_start(); // Notify JVMTI if (JvmtiExport::should_post_thread_life()) &#123; JvmtiExport::post_thread_start(thread); &#125; EventThreadStart event; if (event.should_commit()) &#123; event.set_thread(THREAD_TRACE_ID(thread)); event.commit(); &#125; // Since this is not a JVM_ENTRY we have to set the thread state manually before leaving. ThreadStateTransition::transition_and_fence(thread, _thread_in_vm, _thread_in_native); &#125; // 如果未创建成功 else &#123; .... &#125; return result;&#125; thread.cpp # Threads::create_vm()Threads::create_vm()方法位于src/hotspot/share/runtime/thread.cpp中 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216jint Threads::create_vm(JavaVMInitArgs* args, bool* canTryAgain) &#123; extern void JDK_Version_init(); // 版本信息初始化 VM_Version::early_initialize(); // 检查JNI版本 if (!is_supported_jni_version(args-&gt;version)) return JNI_EVERSION; // 初始化TLS // Initialize library-based TLS ThreadLocalStorage::init(); // 初始化系统输出流模块 // Initialize the output stream module ostream_init(); // 处理Java启动参数，如-Dsun.java.launcher* // Process java launcher properties. Arguments::process_sun_java_launcher_properties(args); // 初始化操作系统模块，如页大小，处理器数量，系统时钟等 // Initialize the os module os::init(); // 启动VM创建计时器 // Record VM creation timing statistics TraceVmCreationTime create_vm_timer; create_vm_timer.start(); // 初始化系统属性，其中分为【可读属性】和【可读写属性】 // 可读属性： // java.vm.specification.name // java.vm.version // java.vm.name // java.vm.info // 可读写属性： // java.ext.dirs // java.endorsed.dirs // sun.boot.library.path // java.library.path // java.home // sun.boot.class.path // java.class.path // Initialize system properties. Arguments::init_system_properties(); // JDK版本初始化 // So that JDK version can be used as a discriminator when parsing arguments JDK_Version_init(); // 设置java.vm.specification.vendor // java.vm.specification.version和java.vm.vendor属性 // Update/Initialize System properties after JDK version number is known Arguments::init_version_specific_system_properties(); // 初始化日志配置 // Make sure to initialize log configuration *before* parsing arguments LogConfiguration::initialize(create_vm_timer.begin_time()); // 解析启动参数，如-XX:Flags=、-XX:+PrintVMOptions、-XX:+PrintFlagsInitial etc. // Parse arguments jint parse_result = Arguments::parse(args); if (parse_result != JNI_OK) return parse_result; os::init_before_ergo(); // 初始化GC日志输出流，用来处理-Xloggc参数 // Initialize output stream logging ostream_init_log(); // Convert -Xrun to -agentlib: if there is no JVM_OnLoad // Must be before create_vm_init_agents() if (Arguments::init_libraries_at_startup()) &#123; convert_vm_init_libraries_to_agents(); &#125; // 初始化agent // Launch -agentlib/-agentpath and converted -Xrun agents if (Arguments::init_agents_at_startup()) &#123; create_vm_init_agents(); &#125; // Initialize Threads state _thread_list = NULL; _number_of_threads = 0; _number_of_non_daemon_threads = 0; /* * ======================================== * 初始化VM全局数据结构及系统类 * ======================================== * 初始化Java基础类型 * 初始化对象OOP大小 * 初始化锁 * 初始化chunkpool * 初始化性能数据统计模块 * ======================================== */ // Initialize global data structures and create system classes in heap vm_init_globals(); // 初始化Java级别的对象同步器子系统 // Initialize Java-Level synchronization subsystem ObjectMonitor::Initialize(); /* * 初始化全局模块 * ======================================== * 1. 初始化management模块 * 2. 初始化字节码/操作符表 * 3. 初始化ClassLoader * 4. 根据命令行参数决定编译策略 * 5. 代码缓存初始化 * 6. 虚拟机版本初始化 * 7. OS全局初始化 * .... * * ======================================== */ jint status = init_globals(); if (status != JNI_OK) &#123; delete main_thread; *canTryAgain = false; // don't let caller call JNI_CreateJavaVM again return status; &#125; if (TRACE_INITIALIZE() != JNI_OK) &#123; vm_exit_during_initialization("Failed to initialize tracing backend"); &#125; // Should be done after the heap is fully created main_thread-&gt;cache_global_variables(); HandleMark hm; &#123; MutexLocker mu(Threads_lock); Threads::add(main_thread); &#125; Thread* THREAD = Thread::current(); // Always call even when there are not JVMTI environments yet, since environments // may be attached late and JVMTI must track phases of VM execution JvmtiExport::enter_early_start_phase(); // Notify JVMTI agents that VM has started (JNI is up) - nop if no agents. JvmtiExport::post_early_vm_start(); // 初始化Java的lang包 initialize_java_lang_classes(main_thread, CHECK_JNI_ERR); // We need this for ClassDataSharing - the initial vm.info property is set // with the default value of CDS "sharing" which may be reset through // command line options. reset_vm_info_property(CHECK_JNI_ERR); quicken_jni_functions(); // No more stub generation allowed after that point. StubCodeDesc::freeze(); // Set flag that basic initialization has completed. Used by exceptions and various // debug stuff, that does not work until all basic classes have been initialized. set_init_completed(); LogConfiguration::post_initialize(); Metaspace::post_initialize(); HOTSPOT_VM_INIT_END(); // record VM initialization completion time#if INCLUDE_MANAGEMENT Management::record_vm_init_completed();#endif // INCLUDE_MANAGEMENT // 启动一个叫做“信号分发器”的线程用来处理进程间的信号 // 比如通过jstack获取一个jvm实例的栈信息 // Signal Dispatcher needs to be started before VMInit event is posted os::signal_init(CHECK_JNI_ERR); // Start Attach Listener if +StartAttachListener or it can't be started lazily if (!DisableAttachMechanism) &#123; AttachListener::vm_start(); if (StartAttachListener || AttachListener::init_at_startup()) &#123; AttachListener::init(); &#125; &#125; // Launch -Xrun agents // Must be done in the JVMTI live phase so that for backward compatibility the JDWP // back-end can launch with -Xdebug -Xrunjdwp. if (!EagerXrunInit &amp;&amp; Arguments::init_libraries_at_startup()) &#123; create_vm_init_libraries(); &#125; // 通知JVMTI agents虚拟机初始化开始 // Notify JVMTI agents that VM has started (JNI is up) - nop if no agents. JvmtiExport::post_vm_start(); // Final system initialization including security manager and system class loader call_initPhase3(CHECK_JNI_ERR); // cache the system class loader SystemDictionary::compute_java_system_loader(CHECK_(JNI_ERR)); if (MemProfiling) MemProfiler::engage(); StatSampler::engage(); if (CheckJNICalls) JniPeriodicChecker::engage(); // 初始化偏向锁 BiasedLocking::init(); return JNI_OK;&#125; init.cpp # init_globals()init_globals()方法用于初始化虚拟机全局模块，位于调用了src/hotspot/share/runtime/init.cpp 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081jint init_globals() &#123; HandleMark hm; // 初始化各子系统的监控及管理服务 // JMX、线程和同步子系统、类加载子系统的监控和管理 management_init(); // 初始化字节码表，如istore、iload、iadd bytecodes_init(); // 类加载器初始化 classLoader_init1(); // 初始化编译策略（根据启动参数决定编译策略） compilationPolicy_init(); // 代码缓存池初始化 codeCache_init(); // 虚拟机版本初始化 VM_Version_init(); // OS全局初始化 os_init_globals(); stubRoutines_init1(); // ============================ // 初始化堆以及决定所使用GC策略 // ============================ jint status = universe_init(); // dependent on codeCache_init and // stubRoutines_init1 and metaspace_init. if (status != JNI_OK) return status; // 初始化解析器 interpreter_init(); // before any methods loaded // 初始化动作触发器 invocationCounter_init(); // before any methods loaded // 初始化MarkSweep marksweep_init(); // 初始化访问标识 accessFlags_init(); // 初始化操作码模板表 templateTable_init(); // 接口支持提供了VM_LEAF_BASE和VM_ENTRY_BASE宏 InterfaceSupport_init(); SharedRuntime::generate_stubs(); // 初始化语法表及系统字典等 universe2_init(); // dependent on codeCache_init and stubRoutines_init1 // 初始化软引用时间戳表并设定软引用清除策略 referenceProcessor_init(); jni_handles_init();#if INCLUDE_VM_STRUCTS // 代码数据结构的必要性检查（仅限debug版本） vmStructs_init();#endif // INCLUDE_VM_STRUCTS vtableStubs_init(); InlineCacheBuffer_init(); // oracle编译器初始化（oracle编译器是一个编译器开关接口） compilerOracle_init(); dependencyContext_init(); if (!compileBroker_init()) &#123; return JNI_EINVAL; &#125; VMRegImpl::set_regName(); // 执行初始化 if (!universe_post_init()) &#123; return JNI_ERR; &#125; javaClasses_init(); // must happen after vtable initialization stubRoutines_init2(); // note: StubRoutines need 2-phase init MethodHandles::generate_adapters();#if INCLUDE_NMT // Solaris stack is walkable only after stubRoutines are set up. // On Other platforms, the stack is always walkable. NMT_stack_walkable = true;#endif // INCLUDE_NMT // All the flags that get adjusted by VM_Version_init and os::init_2 // have been set so dump the flags now. if (PrintFlagsFinal || PrintFlagsRanges) &#123; CommandLineFlags::printFlags(tty, false, PrintFlagsRanges); &#125; return JNI_OK;&#125; universe.cpp # universe_init()universe_init()方法初始化堆以及决定所使用GC策略，位于src/hotspot/share/memory/universe.cpp 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687jint universe_init() &#123; assert(!Universe::_fully_initialized, "called after initialize_vtables"); guarantee(1 &lt;&lt; LogHeapWordSize == sizeof(HeapWord), "LogHeapWordSize is incorrect."); guarantee(sizeof(oop) &gt;= sizeof(HeapWord), "HeapWord larger than oop?"); guarantee(sizeof(oop) % sizeof(HeapWord) == 0, "oop size is not not a multiple of HeapWord size"); TraceTime timer("Genesis", TRACETIME_LOG(Info, startuptime)); JavaClasses::compute_hard_coded_offsets(); /* * ============================================================== * 初始化堆空间 * ============================================================== * 在JDK7以前的版本中默认使用CMS收集器，这里会创建及初始化各分区代，设定空间比例大小，回收策略等 * 流程：根据启动参数决定使用的回收策略，初始化回收策略时会指定所使用的代规范， * 最后根据规范创建对应类型的回收堆。 * i.e. arguments -&gt; policy -&gt; spec -&gt; heap * * 在最新的JDK10中默认使用G1作为默认收集器，在JEP248里就提议，参见http://openjdk.java.net/jeps/248， * 虽然也采用分代算法，但由连续内存的年轻（老）代改为非连续的小块region（单个region连续） * ============================================================== */ jint status = Universe::initialize_heap(); if (status != JNI_OK) &#123; return status; &#125; // 初始化元数据空间 // 在JDK8里移除了PermGen，就是加入了它 Metaspace::global_initialize(); // 初始化AOT loader AOTLoader::universe_init(); // Checks 'AfterMemoryInit' constraints. if (!CommandLineFlagConstraintList::check_constraints(CommandLineFlagConstraint::AfterMemoryInit)) &#123; return JNI_EINVAL; &#125; // 为元数据申请内存空间 // Create memory for metadata. Must be after initializing heap for // DumpSharedSpaces. ClassLoaderData::init_null_class_loader_data(); // We have a heap so create the Method* caches before // Metaspace::initialize_shared_spaces() tries to populate them. Universe::_finalizer_register_cache = new LatestMethodCache(); Universe::_loader_addClass_cache = new LatestMethodCache(); Universe::_pd_implies_cache = new LatestMethodCache(); Universe::_throw_illegal_access_error_cache = new LatestMethodCache(); Universe::_do_stack_walk_cache = new LatestMethodCache();#if INCLUDE_CDS if (UseSharedSpaces) &#123; // Read the data structures supporting the shared spaces (shared // system dictionary, symbol table, etc.). After that, access to // the file (other than the mapped regions) is no longer needed, and // the file is closed. Closing the file does not affect the // currently mapped regions. MetaspaceShared::initialize_shared_spaces(); StringTable::create_table(); &#125; else#endif &#123; // 创建符号表 SymbolTable::create_table(); // 创建字符串缓存池 StringTable::create_table();#if INCLUDE_CDS if (DumpSharedSpaces) &#123; MetaspaceShared::prepare_for_dumping(); &#125;#endif &#125; if (strlen(VerifySubSet) &gt; 0) &#123; Universe::initialize_verify_flags(); &#125; // 创建方法表 ResolvedMethodTable::create_table(); return JNI_OK;&#125; universe.cpp # initialize_heap()initialize_heap()方法用于初始化堆空间，位于src/hotspot/share/memory/universe.cpp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384// Choose the heap base address and oop encoding mode// when compressed oops are used:// Unscaled - Use 32-bits oops without encoding when// NarrowOopHeapBaseMin + heap_size &lt; 4Gb// ZeroBased - Use zero based compressed oops with encoding when// NarrowOopHeapBaseMin + heap_size &lt; 32Gb// HeapBased - Use compressed oops with heap base + encoding.jint Universe::initialize_heap() &#123; jint status = JNI_ERR; // 根据GC策略创建堆空间 _collectedHeap = create_heap_ext(); if (_collectedHeap == NULL) &#123; _collectedHeap = create_heap(); &#125; /* * ========================================== * 初始化堆空间 * ========================================== * 这里会调用G1CollectedHeap::initialize()方法， * 真正向操作系统申请内存 * ========================================== */ status = _collectedHeap-&gt;initialize(); if (status != JNI_OK) &#123; return status; &#125; log_info(gc)("Using %s", _collectedHeap-&gt;name()); ThreadLocalAllocBuffer::set_max_size(Universe::heap()-&gt;max_tlab_size());#ifdef _LP64 // 在LP64数据模型下是否开启对象指针压缩 if (UseCompressedOops) &#123; // Subtract a page because something can get allocated at heap base. // This also makes implicit null checking work, because the // memory+1 page below heap_base needs to cause a signal. // See needs_explicit_null_check. // Only set the heap base for compressed oops because it indicates // compressed oops for pstack code. if ((uint64_t)Universe::heap()-&gt;reserved_region().end() &gt; UnscaledOopHeapMax) &#123; // Didn't reserve heap below 4Gb. Must shift. Universe::set_narrow_oop_shift(LogMinObjAlignmentInBytes); &#125; if ((uint64_t)Universe::heap()-&gt;reserved_region().end() &lt;= OopEncodingHeapMax) &#123; // Did reserve heap below 32Gb. Can use base == 0; Universe::set_narrow_oop_base(0); &#125; Universe::set_narrow_ptrs_base(Universe::narrow_oop_base()); LogTarget(Info, gc, heap, coops) lt; if (lt.is_enabled()) &#123; ResourceMark rm; LogStream ls(lt); Universe::print_compressed_oops_mode(&amp;ls); &#125; // Tell tests in which mode we run. Arguments::PropertyList_add(new SystemProperty("java.vm.compressedOopsMode", narrow_oop_mode_to_string(narrow_oop_mode()), false)); &#125; // Universe::narrow_oop_base() is one page below the heap. assert((intptr_t)Universe::narrow_oop_base() &lt;= (intptr_t)(Universe::heap()-&gt;base() - os::vm_page_size()) || Universe::narrow_oop_base() == NULL, "invalid value"); assert(Universe::narrow_oop_shift() == LogMinObjAlignmentInBytes || Universe::narrow_oop_shift() == 0, "invalid value");#endif // We will never reach the CATCH below since Exceptions::_throw will cause // the VM to exit if an exception is thrown during initialization // 如果使用TLAB if (UseTLAB) &#123; assert(Universe::heap()-&gt;supports_tlab_allocation(), "Should support thread-local allocation buffers"); ThreadLocalAllocBuffer::startup_initialization(); &#125; return JNI_OK;&#125; universe.cpp # create_heap()create_heap()用于根据GC策略创建堆空间，位于src/hotspot/share/memory/universe.cpp 12345678910111213141516171819202122232425CollectedHeap* Universe::create_heap() &#123; assert(_collectedHeap == NULL, "Heap already created");#if !INCLUDE_ALL_GCS if (UseParallelGC) &#123; fatal("UseParallelGC not supported in this VM."); &#125; else if (UseG1GC) &#123; fatal("UseG1GC not supported in this VM."); &#125; else if (UseConcMarkSweepGC) &#123; fatal("UseConcMarkSweepGC not supported in this VM.");#else if (UseParallelGC) &#123; return Universe::create_heap_with_policy&lt;ParallelScavengeHeap, GenerationSizer&gt;(); &#125; else if (UseG1GC) &#123; // 此处默认使用G1 return Universe::create_heap_with_policy&lt;G1CollectedHeap, G1CollectorPolicy&gt;(); &#125; else if (UseConcMarkSweepGC) &#123; return Universe::create_heap_with_policy&lt;GenCollectedHeap, ConcurrentMarkSweepPolicy&gt;();#endif &#125; else if (UseSerialGC) &#123; return Universe::create_heap_with_policy&lt;GenCollectedHeap, MarkSweepPolicy&gt;(); &#125; ShouldNotReachHere(); return NULL;&#125; g1CollectedHeap.cpp # G1CollectedHeap::initialize()堆空间创建完毕，接下来是初始化，从上面return Universe::create_heap_with_policy&lt;G1CollectedHeap, G1CollectorPolicy&gt;();可以看出，_collectedHeap对应的堆实现是G1CollectedHeap，位于src/hotspot/share/gc/g1/g1CollectedHeap.cpp，对应上面的_collectedHeap-&gt;initialize()， 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136// G1CollectedHeap初始化jint G1CollectedHeap::initialize() &#123; CollectedHeap::pre_initialize(); os::enable_vtime(); // Necessary to satisfy locking discipline assertions. MutexLocker x(Heap_lock); size_t init_byte_size = collector_policy()-&gt;initial_heap_byte_size(); size_t max_byte_size = collector_policy()-&gt;max_heap_byte_size(); size_t heap_alignment = collector_policy()-&gt;heap_alignment(); // 申请Java堆内存及确定CompressedOops模式 ReservedSpace heap_rs = Universe::reserve_heap(max_byte_size, heap_alignment); // 初始化申请的内存区域 initialize_reserved_region((HeapWord*)heap_rs.base(), (HeapWord*)(heap_rs.base() + heap_rs.size())); // 为整个保留区域创建barrier // Create the barrier set for the entire reserved region. G1SATBCardTableLoggingModRefBS* bs = new G1SATBCardTableLoggingModRefBS(reserved_region()); bs-&gt;initialize(); assert(bs-&gt;is_a(BarrierSet::G1SATBCTLogging), "sanity"); set_barrier_set(bs); // 创建热卡缓存 // Create the hot card cache. _hot_card_cache = new G1HotCardCache(this); // Carve out the G1 part of the heap. ReservedSpace g1_rs = heap_rs.first_part(max_byte_size); size_t page_size = UseLargePages ? os::large_page_size() : os::vm_page_size(); // 创建mapper G1RegionToSpaceMapper* heap_storage = G1RegionToSpaceMapper::create_mapper(g1_rs, g1_rs.size(), page_size, HeapRegion::GrainBytes, 1, mtJavaHeap); os::trace_page_sizes("Heap", collector_policy()-&gt;min_heap_byte_size(), max_byte_size, page_size, heap_rs.base(), heap_rs.size()); heap_storage-&gt;set_mapping_changed_listener(&amp;_listener); FreeRegionList::set_unrealistically_long_length(max_regions() + 1); _bot = new G1BlockOffsetTable(reserved_region(), bot_storage); &#123; HeapWord* start = _hrm.reserved().start(); HeapWord* end = _hrm.reserved().end(); size_t granularity = HeapRegion::GrainBytes; _in_cset_fast_test.initialize(start, end, granularity); _humongous_reclaim_candidates.initialize(start, end, granularity); &#125; // 创建G1ConcurrentMark数据结构和线程 // Create the G1ConcurrentMark data structure and thread. // (Must do this late, so that "max_regions" is defined.) _cm = new G1ConcurrentMark(this, prev_bitmap_storage, next_bitmap_storage); if (_cm == NULL || !_cm-&gt;completed_initialization()) &#123; vm_shutdown_during_initialization("Could not create/initialize G1ConcurrentMark"); return JNI_ENOMEM; &#125; _cmThread = _cm-&gt;cmThread(); // Now expand into the initial heap size. if (!expand(init_byte_size, _workers)) &#123; vm_shutdown_during_initialization("Failed to allocate initial heap."); return JNI_ENOMEM; &#125; // 执行委托给内存（G1）策略的所有初始化操作 // Perform any initialization actions delegated to the policy. g1_policy()-&gt;init(this, &amp;_collection_set); JavaThread::satb_mark_queue_set().initialize(SATB_Q_CBL_mon, SATB_Q_FL_lock, G1SATBProcessCompletedThreshold, Shared_SATB_Q_lock); jint ecode = initialize_concurrent_refinement(); if (ecode != JNI_OK) &#123; return ecode; &#125; JavaThread::dirty_card_queue_set().initialize(DirtyCardQ_CBL_mon, DirtyCardQ_FL_lock, (int)concurrent_g1_refine()-&gt;yellow_zone(), (int)concurrent_g1_refine()-&gt;red_zone(), Shared_DirtyCardQ_lock, NULL, // fl_owner true); // init_free_ids dirty_card_queue_set().initialize(DirtyCardQ_CBL_mon, DirtyCardQ_FL_lock, -1, // never trigger processing -1, // no limit on length Shared_DirtyCardQ_lock, &amp;JavaThread::dirty_card_queue_set()); // Here we allocate the dummy HeapRegion that is required by the // G1AllocRegion class. HeapRegion* dummy_region = _hrm.get_dummy_region(); // We'll re-use the same region whether the alloc region will // require BOT updates or not and, if it doesn't, then a non-young // region will complain that it cannot support allocations without // BOT updates. So we'll tag the dummy region as eden to avoid that. dummy_region-&gt;set_eden(); // Make sure it's full. dummy_region-&gt;set_top(dummy_region-&gt;end()); G1AllocRegion::setup(this, dummy_region); _allocator-&gt;init_mutator_alloc_region(); // Do create of the monitoring and management support so that // values in the heap have been properly initialized. _g1mm = new G1MonitoringSupport(this); G1StringDedup::initialize(); _preserved_marks_set.init(ParallelGCThreads); _collection_set.initialize(max_regions()); return JNI_OK;&#125; 至此，JVM的整个初始化工作完成，关于GC策略的空间分配具体细节在以后的文章中再详细介绍。]]></content>
      <categories>
        <category>OpenJDK</category>
      </categories>
      <tags>
        <tag>OpenJDK</tag>
        <tag>JVM</tag>
        <tag>HotSpot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【JVM源码探秘】HotSpot启动流程分析-创建]]></title>
    <url>%2Fpost%2F2018%2F02%2F23%2Fhotspot-explore-startup-process-creation%2F</url>
    <content type="text"><![CDATA[在之前的文章中已经介绍了如何在Mac上编译及调试OpenJDK10源码， 那么，一个Java实例从开始运行至结束经历了什么？本文将从JVM源码角度一探究竟，深入剖析HotSpot其创建流程。 main.c # main()程序主入口位于src/java.base/share/native/launcher/main.c 12345678910111213141516171819202122intmain(int argc, char **argv)&#123; int margc; char** margv; int jargc; char** jargv; const jboolean const_javaw = JNI_FALSE; ...#endif /* WIN32 */ return JLI_Launch(margc, margv, jargc, (const char**) jargv, 0, NULL, VERSION_STRING, DOT_VERSION, (const_progname != NULL) ? const_progname : *margv, (const_launcher != NULL) ? const_launcher : *margv, jargc &gt; 0, const_cpwildcard, const_javaw, 0);&#125; main返回了JLI_Launch()函数，位于src/java.base/share/native/libjli/java.c java.c # JLI_Launch()123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102/* * Entry point. */intJLI_Launch(int argc, char ** argv, /* main argc, argc */ int jargc, const char** jargv, /* java args */ int appclassc, const char** appclassv, /* app classpath */ const char* fullversion, /* full version defined */ const char* dotversion, /* UNUSED dot version defined */ const char* pname, /* program name */ const char* lname, /* launcher name */ jboolean javaargs, /* JAVA_ARGS */ jboolean cpwildcard, /* classpath wildcard*/ jboolean javaw, /* windows-only javaw */ jint ergo /* unused */)&#123; int mode = LM_UNKNOWN; char *what = NULL; char *main_class = NULL; int ret; InvocationFunctions ifn; jlong start, end; char jvmpath[MAXPATHLEN]; char jrepath[MAXPATHLEN]; char jvmcfg[MAXPATHLEN]; /* * 确保运行适当的JRE * * SelectVersion() has several responsibilities: * * 1) Disallow specification of another JRE. With 1.9, another * version of the JRE cannot be invoked. * 2) Allow for a JRE version to invoke JDK 1.9 or later. Since * all mJRE directives have been stripped from the request but * the pre 1.9 JRE [ 1.6 thru 1.8 ], it is as if 1.9+ has been * invoked from the command line. */ SelectVersion(argc, argv, &amp;main_class); // 创建运行环境，如检查系统使用的数据模型（32bit、64bit），获取使用的JRE路径，找到jvm.cfg解析已知的vm类型 // 设置新的LD_LIBRARY_PATH变量 CreateExecutionEnvironment(&amp;argc, &amp;argv, jrepath, sizeof(jrepath), jvmpath, sizeof(jvmpath), jvmcfg, sizeof(jvmcfg)); // 加载JVM // 通过jvmpath找到libjvm.so 返回以下方法 // JNI_CreateJavaVM // JNI_GetDefaultJavaVMInitArgs // GetCreatedJavaVMs // 的符号地址返回，挂载到InvocationFunctions以便后续调用 if (!LoadJavaVM(jvmpath, &amp;ifn)) &#123; return(6); &#125; if (IsJavaArgs()) &#123; // 转换命令行参数 如：javac -cp foo:foo/"*" -J-ms32m /* Preprocess wrapper arguments */ TranslateApplicationArgs(jargc, jargv, &amp;argc, &amp;argv); /* * 添加了三个VM选项 * -Denv.class.path 用户设置的CLASSPATH变量，如果CLASSPATH显式设置了tools.jar * 则可以反编译VM的工具类sun.tools.* * -Dapplication.home 应用程序目录 * -Djava.class.path 应用程序的类文件目录 */ if (!AddApplicationOptions(appclassc, appclassv)) &#123; return(1); &#125; &#125; else &#123; /* Set default CLASSPATH */ char* cpath = getenv("CLASSPATH"); if (cpath != NULL) &#123; SetClassPath(cpath); &#125; &#125; /* 解析命令行参数-jar -cp、-version、-*path、-X*等参数 * * Parse command line options; if the return value of * ParseArguments is false, the program should exit. */ if (!ParseArguments(&amp;argc, &amp;argv, &amp;mode, &amp;what, &amp;ret, jrepath)) &#123; return(ret); &#125; // 设置classpath /* Override class path if -jar flag was specified */ if (mode == LM_JAR) &#123; SetClassPath(what); /* Override class path */ &#125; ... return JVMInit(&amp;ifn, threadStackSize, argc, argv, mode, what, ret);&#125; 继续跟进JVMInit()方法，位于src/java.base/macosx/native/libjli/java_md_macosx.c， 注：由于我的系统是Mac，所以对应的是java_md_macosx.c，其他系统位于目录src/java.base对应操作系统类型下的java_md.c或java_md_xxx.c java_md_macosx.c # JVMInit()12345678910111213141516171819202122232425262728293031323334353637intJVMInit(InvocationFunctions* ifn, jlong threadStackSize, int argc, char **argv, int mode, char *what, int ret) &#123; if (sameThread) &#123; JLI_TraceLauncher("In same thread\n"); // need to block this thread against the main thread // so signals get caught correctly __block int rslt = 0; NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init]; &#123; NSBlockOperation *op = [NSBlockOperation blockOperationWithBlock: ^&#123; JavaMainArgs args; args.argc = argc; args.argv = argv; args.mode = mode; args.what = what; args.ifn = *ifn; rslt = JavaMain(&amp;args); &#125;]; /* * We cannot use dispatch_sync here, because it blocks the main dispatch queue. * Using the main NSRunLoop allows the dispatch queue to run properly once * SWT (or whatever toolkit this is needed for) kicks off it's own NSRunLoop * and starts running. */ [op performSelectorOnMainThread:@selector(start) withObject:nil waitUntilDone:YES]; &#125; [pool drain]; return rslt; &#125; else &#123; // block当前线程并且在新线程中继续执行 // 至于为什么在新线程中创建JVM见引用https://bugs.openjdk.java.net/browse/JDK-6316197 return ContinueInNewThread(ifn, threadStackSize, argc, argv, mode, what, ret); &#125;&#125; JVMInit方法紧接着又return回java.c的ContinueInNewThread()方法 java.c # ContinueInNewThread()1234567891011121314151617181920212223242526272829303132333435363738394041intContinueInNewThread(InvocationFunctions* ifn, jlong threadStackSize, int argc, char **argv, int mode, char *what, int ret)&#123; /* * 指定线程大小 * If user doesn't specify stack size, check if VM has a preference. * Note that HotSpot no longer supports JNI_VERSION_1_1 but it will * return its default stack size through the init args structure. */ if (threadStackSize == 0) &#123; struct JDK1_1InitArgs args1_1; memset((void*)&amp;args1_1, 0, sizeof(args1_1)); args1_1.version = JNI_VERSION_1_1; ifn-&gt;GetDefaultJavaVMInitArgs(&amp;args1_1); /* ignore return value */ if (args1_1.javaStackSize &gt; 0) &#123; threadStackSize = args1_1.javaStackSize; &#125; &#125; &#123; /* Create a new thread to create JVM and invoke main method */ JavaMainArgs args; int rslt; args.argc = argc; args.argv = argv; args.mode = mode; args.what = what; args.ifn = *ifn; // 在新线程中执行 rslt = ContinueInNewThread0(JavaMain, threadStackSize, (void*)&amp;args); /* If the caller has deemed there is an error we * simply return that, otherwise we return the value of * the callee */ return (ret != 0) ? ret : rslt; &#125;&#125; ContinueInNewThread()方法调用了执行方法ContinueInNewThread0() java.c # ContinueInNewThread0()1234567891011121314151617181920212223242526272829303132333435/* * Block current thread and continue execution in a new thread */intContinueInNewThread0(int (JNICALL *continuation)(void *), jlong stack_size, void * args) &#123; int rslt; pthread_t tid; pthread_attr_t attr; pthread_attr_init(&amp;attr); pthread_attr_setdetachstate(&amp;attr, PTHREAD_CREATE_JOINABLE); if (stack_size &gt; 0) &#123; pthread_attr_setstacksize(&amp;attr, stack_size); &#125; pthread_attr_setguardsize(&amp;attr, 0); // no pthread guard page on java threads if (pthread_create(&amp;tid, &amp;attr, (void *(*)(void*))continuation, (void*)args) == 0) &#123; void * tmp; pthread_join(tid, &amp;tmp); rslt = (int)(intptr_t)tmp; &#125; else &#123; /* * 调用JNI_CreateJavaVM执行创建虚拟机 * * Continue execution in current thread if for some reason (e.g. out of * memory/LWP) a new thread can't be created. This will likely fail * later in continuation as JNI_CreateJavaVM needs to create quite a * few new threads, anyway, just give it a try.. */ rslt = continuation(args); &#125; pthread_attr_destroy(&amp;attr); return rslt;&#125; ContinueInNewThread0()中最终执行了名为continuation的JNICALL，而这个的JNICALL正是上一步传过来的JavaMain，单看JavaMain这个名字就好熟悉，有木有？接下来我们看看JavaMain的庐山真面目 java.c # JavaMain()123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140int JNICALLJavaMain(void * _args)&#123; JavaMainArgs *args = (JavaMainArgs *)_args; int argc = args-&gt;argc; char **argv = args-&gt;argv; int mode = args-&gt;mode; char *what = args-&gt;what; InvocationFunctions ifn = args-&gt;ifn; JavaVM *vm = 0; JNIEnv *env = 0; jclass mainClass = NULL; jclass appClass = NULL; // actual application class being launched jmethodID mainID; jobjectArray mainArgs; int ret = 0; jlong start, end; RegisterThread(); // ================================ // 初始化虚拟机 // ================================ /* Initialize the virtual machine */ start = CounterGet(); if (!InitializeJVM(&amp;vm, &amp;env, &amp;ifn)) &#123; JLI_ReportErrorMessage(JVM_ERROR1); exit(1); &#125; ... // 如果输入了-version或-showversion参数 if (printVersion || showVersion) &#123; PrintJavaVersion(env, showVersion); CHECK_EXCEPTION_LEAVE(0); if (printVersion) &#123; LEAVE(); &#125; &#125; // 如果jar文件和类名均未指定则输出默认usage信息 /* If the user specified neither a class name nor a JAR file */ if (printXUsage || printUsage || what == 0 || mode == LM_UNKNOWN) &#123; PrintUsage(env, printXUsage); CHECK_EXCEPTION_LEAVE(1); LEAVE(); &#125; FreeKnownVMs(); /* after last possible PrintUsage */ ret = 1; /* * 加载Java程序的main方法，如果没找到则退出 * * Get the application's main class. It also checks if the main * method exists. * * See bugid 5030265. The Main-Class name has already been parsed * from the manifest, but not parsed properly for UTF-8 support. * Hence the code here ignores the value previously extracted and * uses the pre-existing code to reextract the value. This is * possibly an end of release cycle expedient. However, it has * also been discovered that passing some character sets through * the environment has "strange" behavior on some variants of * Windows. Hence, maybe the manifest parsing code local to the * launcher should never be enhanced. * * Hence, future work should either: * 1) Correct the local parsing code and verify that the * Main-Class attribute gets properly passed through * all environments, * 2) Remove the vestages of maintaining main_class through * the environment (and remove these comments). * * This method also correctly handles launching existing JavaFX * applications that may or may not have a Main-Class manifest entry. */ mainClass = LoadMainClass(env, mode, what); CHECK_EXCEPTION_NULL_LEAVE(mainClass); /* * 获取程序主类Class对象 * * In some cases when launching an application that needs a helper, e.g., a * JavaFX application with no main method, the mainClass will not be the * applications own main class but rather a helper class. To keep things * consistent in the UI we need to track and report the application main class. */ appClass = GetApplicationClass(env); NULL_CHECK_RETURN_VALUE(appClass, -1); // 构建main方法参数列表 /* Build platform specific argument array */ mainArgs = CreateApplicationArgs(env, argv, argc); CHECK_EXCEPTION_NULL_LEAVE(mainArgs); if (dryRun) &#123; ret = 0; LEAVE(); &#125; /* * PostJVMInit uses the class name as the application name for GUI purposes, * for example, on OSX this sets the application name in the menu bar for * both SWT and JavaFX. So we'll pass the actual application class here * instead of mainClass as that may be a launcher or helper class instead * of the application class. */ PostJVMInit(env, appClass, vm); CHECK_EXCEPTION_LEAVE(1); /* * 获取main方法ID * * The LoadMainClass not only loads the main class, it will also ensure * that the main method's signature is correct, therefore further checking * is not required. The main method is invoked here so that extraneous java * stacks are not in the application stack trace. */ mainID = (*env)-&gt;GetStaticMethodID(env, mainClass, "main", "([Ljava/lang/String;)V"); CHECK_EXCEPTION_NULL_LEAVE(mainID); // 调用main方法 /* Invoke main method. */ (*env)-&gt;CallStaticVoidMethod(env, mainClass, mainID, mainArgs); /* * 如果有异常抛出，程序将返回非零结束码 * * The launcher's exit code (in the absence of calls to * System.exit) will be non-zero if main threw an exception. */ ret = (*env)-&gt;ExceptionOccurred(env) == NULL ? 0 : 1; // 退出 LEAVE();&#125; 可见JavaMain()是Java主程序的native调用。在该方法里会执行虚拟机的初始化，获取Java程序主类及main方法，然后通过JNI调用main方法，自此，整个JVM进程执行结束，最终退出。 值得注意的是:该方法中调用的InitializeJVM()方法会执行一系列关于虚拟机的分配、挂载、初始化等工作，下篇文章我们继续详细深入介绍。]]></content>
      <categories>
        <category>OpenJDK</category>
      </categories>
      <tags>
        <tag>OpenJDK</tag>
        <tag>JVM</tag>
        <tag>HotSpot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【JVM源码探秘】Java中的Class文件结构]]></title>
    <url>%2Fpost%2F2018%2F02%2F12%2Fhotspot-explore-java-class-file-structure%2F</url>
    <content type="text"><![CDATA[我们都知道JVM并不能直接运行Java源文件，而是程序猿通过JDK提供的javac命令将Java源文件编译成.class二进制文件，然后供JVM加载并使用，也就是说class文件其实是程序猿和JVM之间交互的媒介，相当于介于用户和Linux内核之间的shell。 一个class文件完整地描述了Java源文件的各种信息，Oracle JVM规范中的4.1 The ClassFile Structure 详细定义了一个标准class文件的结构 123456789101112131415161718ClassFile &#123; u4 magic; u2 minor_version; u2 major_version; u2 constant_pool_count; cp_info constant_pool[constant_pool_count-1]; u2 access_flags; u2 this_class; u2 super_class; u2 interfaces_count; u2 interfaces[interfaces_count]; u2 fields_count; field_info fields[fields_count]; u2 methods_count; method_info methods[methods_count]; u2 attributes_count; attribute_info attributes[attributes_count];&#125; magicclass文件的魔数值，用于鉴定是否为一个合法class文件，值为0xCAFEBABE minor_version &amp; major_versionclass文件的主次版本号，随着JDK版本release递增，JVM运行时向下兼容，也就是说在JDK10上编译出的class文件在JRE7上无法运行，否则会抛出java.lang.UnsupportedClassVersionErrorminor_version和major_version项目的值是该类文件的次版本号和主版本号。 主版本号和次版本号一起决定了类文件格式的版本。如果一个类文件的主版本号为M，次版本号为m，那么我们将它的类文件格式的版本表示为M.m. 因此，类文件格式版本可以按照字典顺序排列，例如，1.5 &lt;2.0 &lt;2.1。Java虚拟机实现可以支持版本v的类文件格式，当且仅当v处于某个连续范围Mi.0≤v≤Mj.m. 范围基于实现符合的Java SE平台的版本。符合给定Java SE平台版本的实现必须支持表4.1-A中为该版本指定的范围，并且不支持其他范围。 （对于历史案例，显示的是JDK版本而不是Java SE平台版本。） Java SE版本 class文件格式版本号范围 1.0.2 45.0 ≤ v ≤ 45.3 1.1 45.0 ≤ v ≤ 45.65535 1.2 45.0 ≤ v ≤ 46.0 1.3 45.0 ≤ v ≤ 47.0 1.4 45.0 ≤ v ≤ 48.0 5.0 45.0 ≤ v ≤ 49.0 6 45.0 ≤ v ≤ 50.0 7 45.0 ≤ v ≤ 51.0 8 45.0 ≤ v ≤ 52.0 9 45.0 ≤ v ≤ 53.0 10 45.0 ≤ v ≤ 54.0 constant_pool_count常量池元素条目数量，constant_pool_count项的值等于constant_pool表中的条目数加1。 constant_pool[constant_pool_count-1]constant_pool是一个结构表，它表示在ClassFile结构及其子结构中引用的各种字符串常量，类和接口名称，字段名称以及其他常量。每个constant_pool表项的格式由其第一个“标记”字节指示。constant_pool表的索引从1到constant_pool_count - 1。 access_flagsaccess_flags项的值是用于表示对此类或接口的访问权限和属性的标志掩码。 Flag 值 说明 ACC_PUBLIC 0x0001 Declared public; may be accessed from outside its package. ACC_FINAL 0x0010 Declared final; no subclasses allowed. ACC_SUPER 0x0020 Treat superclass methods specially when invoked by the invokespecial instruction. ACC_INTERFACE 0x0200 Is an interface, not a class. ACC_ABSTRACT 0x0400 Declared abstract; must not be instantiated. ACC_SYNTHETIC 0x1000 Declared synthetic; not present in the source code. ACC_ANNOTATION 0x2000 Declared as an annotation type. ACC_ENUM 0x4000 Declared as an enum type. ACC_MODULE 0x8000 Is a module, not a class or interface. ACC_MODULE标志表明这个类文件定义了一个模块，而不是类或接口。如果设置了ACC_MODULE标志，则特殊规则适用于本节末尾给出的类文件。如果未设置ACC_MODULE标志，则当前段落下方的规则将应用于类文件。一个接口通过设置ACC_INTERFACE标志来区分。如果未设置ACC_INTERFACE标志，则此类文件定义一个类，而不是接口或模块。如果设置了ACC_INTERFACE标志，则还必须设置ACC_ABSTRACT标志，并且不得设置ACC_FINAL，ACC_SUPER，ACC_ENUM和ACC_MODULE标志集。如果ACC_INTERFACE标志没有置位，除了ACC_ANNOTATION和ACC_MODULE之外，可以设置表4.1-B中的其他任何标志。但是，这样的类文件不能同时设置其ACC_FINAL和ACC_ABSTRACT标志（JLS§8.1.1.2）。ACC_SUPER标志指示如果它出现在这个类或接口中，则由invokespecial指令（§invokespecial）表示两个可选语义中的哪一个。Java虚拟机指令集的编译器应该设置ACC_SUPER标志。在Java SE 8及更高版本中，Java虚拟机认为ACC_SUPER标志将在每个类文件中设置，而不管类文件中标志的实际值和类文件的版本如何。 ACC_SUPER标志的存在是为了与用于Java编程语言的早期编译器编译的代码向后兼容。 在1.0.2之前的JDK版本中，编译器生成了access_flags，其中现在表示ACC_SUPER的标志没有指定的含义，并且Oracle的Java虚拟机实现忽略该标志（如果已设置）。ACC_SYNTHETIC标志表示该类或接口是由编译器生成的，并未出现在源代码中。注释类型（JLS§9.6）必须设置其ACC_ANNOTATION标志。 如果设置了ACC_ANNOTATION标志，则还必须设置ACC_INTERFACE标志。ACC_ENUM标志表明该类或其超类被声明为枚举类型（JLS§8.9）。未在表4.1-B中分配的access_flags项目的所有位保留供将来使用。 它们应该在生成的类文件中设置为零，并且应该被Java虚拟机实现忽略。 this_classthis_class项的值必须是constant_pool表中的有效索引。 该索引处的constant_pool条目必须是表示由此类文件定义的类或接口的CONSTANT_Class_info结构。 super_class对于类来说，super_class项的值必须为零，或者必须是常量池表中的有效索引。 如果super_class项的值不为零，则该索引处的constant_pool条目必须是表示由此类文件定义的类的直接超类的CONSTANT_Class_info结构。 直接超类或其任何超类都不能在其ClassFile结构的access_flags项中设置ACC_FINAL标志。如果super_class项的值为零，那么这个类文件必须表示类Object，唯一没有直接超类的类或接口。对于接口来说，super_class项的值必须始终是constant_pool表中的有效索引。 该索引处的constant_pool条目必须是表示类Object的CONSTANT_Class_info结构。 interfaces_countinterfaces_count项的值给出了此类或接口类型的直接超接口的数量。 interfaces[interfaces_count]interfaces数组中的每个值都必须是constant_pool表中的有效索引。 在接口[i]的每个值处的constant_pool条目（其中0≤i&lt;interfaces_count）必须是CONSTANT_Class_info结构，该结构表示作为该类或接口类型的直接超级接口的接口，按照从左到右的顺序 类型的来源。 fields_countfields_count项的值给出了field表中field_info结构的数量。 field_info结构表示由此类或接口类型声明的所有字段，包括类变量和实例变量。 fields[fields_count]字段表中的每个值都必须是一个field_info结构，以便对此类或接口中的字段进行完整描述。 字段表仅包含由此类或接口声明的那些字段。它不包含表示从超类或超接口继承的字段的项。 methods_countmethods_count项的值给出了method_info的编号结构在方法表中。 methods[methods_count]方法表中的每个值都必须是一个method_info结构（第4.6节），以提供此类或接口中方法的完整描述。 如果在method_info结构的access_flags项中没有设置ACC_NATIVE和ACC_ABSTRACT标志，则也会提供实现该方法的Java虚拟机指令。method_info结构表示由此类或接口类型声明的所有方法，包括实例方法，类方法，实例初始化方法）以及任何类或接口初始化方法。方法表不包含表示从超类或超接口继承的方法的项。 attributes_countattributes_count项的值给出了此类的属性表中的属性数量。 attributes[attributes_count]属性表的每个值必须是一个attribute_info结构 如果在access_flags项中设置了ACC_MODULE标志，则可以设置access_flags项中的其他标志，并且以下规则适用于ClassFile结构的其余部分： •major_version，minor_version：≥53.0（即Java SE 9及以上） •this_class：模块信息 •super_class，interfaces_count，fields_count，methods_count：零 •属性：必须存在一个模块属性。 除了Module，ModulePackages，ModuleMainClass，InnerClasses，SourceFile，SourceDebugExtension， RuntimeVisibleAnnotations和RuntimeInvisibleAnnotations之外，可能不会出现任何预定义的属性（§4.7）。]]></content>
      <categories>
        <category>OpenJDK</category>
      </categories>
      <tags>
        <tag>OpenJDK</tag>
        <tag>JVM</tag>
        <tag>HotSpot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【JVM源码探秘】在Mac上搭建OpenJDK10源码调试环境]]></title>
    <url>%2Fpost%2F2018%2F01%2F30%2Fdebug-openjdk10-source-code-on-mac-with-clion-ide%2F</url>
    <content type="text"><![CDATA[前面文章已经介绍了如何在Mac上编译OpenJDK10源码，拥有了自己的JDK版本， 为了深入了解Java实例的创建、初始化和执行流程以及内部实现原理，DEBUG是必不可少的必杀技。 所以，本篇文章继续介绍在Mac上搭建OpenJDK10源码调试环境，黑喂狗。 软件环境 OS: macOS Sierra 10.12 IDE: Clion 2018.1 Code: OpenJDK 10 下载IDE从JetBrains官网下载Clion，安装。 导入项目打开Clion依次选择File &gt; Import Project 编辑配置如下图编辑DEBUG配置信息 Executable 选择之前build出的镜像里的java可执行文件（i.e. build/macosx-x86_64-normal-server-slowdebug/jdk/bin/java） Program arguments 填写-version，输出Java版本 Before launch 注意：这里一定要移除Build，否则会报错无法调试 调试源码在hotspot/share/runtime/thread.cpp文件的Threads::create_vm方法内部打断点， 点击DEBUG按钮，不出意外会发现进入如下界面，congrats！ 接下来，泡杯咖啡，Step by step慢慢DEBUG吧，后面的文章将陆续介绍JVM创建及初始化流程。]]></content>
      <categories>
        <category>OpenJDK</category>
      </categories>
      <tags>
        <tag>OpenJDK</tag>
        <tag>JVM</tag>
        <tag>HotSpot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【JVM源码探秘】在Mac上编译OpenJDK10源码]]></title>
    <url>%2Fpost%2F2018%2F01%2F29%2Fcompile-openjdk10-source-code-on-mac%2F</url>
    <content type="text"><![CDATA[博主在11年到12年的时候曾连续研究过十个月的JVM，读过的相关书籍包括： 深入Java虚拟机这本书可以说是介绍JVM内部原理的鼻祖了，于2003年出版现已绝版，不过可以再某宝买到影印版。虽然当时JDK最高仅为1.4但JVM内部的构造已大体形成，所以博主强烈推荐此书。p.s 我肯定不会告诉你这书博主看了3遍：D 深入理解Java虚拟机国内周某人写的，鉴于博主对于国人写的书向来不怎么感兴趣还是不提了。 HotSpot实战 揭秘Java虚拟机 JVM设计原理与实现 自己动手写Java虚拟机 之前的研究基本上都是虚拟机规范和JVM参数调优层面的内容，但是总觉得有些意犹未尽所以决定深入研究一下Hotspot实现，由大部分C/C++和少量汇编代码构成，但清晰的结构和优雅的编码使其并不难读，不得不赞叹一句SUN的大师们的智慧。今天就从编译OpenJDK开始我们的《JVM源码探秘》系列文章之旅。 以前尝试编译过OpenJDK7、8和9，由于源代码中存在诸多BUG，导致各种编译问题，解决来解决去，还是很难编译通过，很是不爽。今天抱着试试看的态度又服用了一个疗程，拿起桌上的OpenJDK10，反手就是一次编译，居然像德芙一样丝滑，一次通过。 软件环境 OS：macOS Sierra 10.12 Xcode: 8.3.3 Oracle JDK: 1.8.0_151 freetype: 2.9 ccache: 3.3.5(Optional) 前置条件先确保系统已安装freetype和ccache1$ brew install freetype ccache 拉取代码1$ hg clone http://hg.openjdk.java.net/jdk10/master openjdk10 此处需要耐心等待一段时间，必要情况下需要多尝试几次才能拉取成功。 配置参数接下来配置编译参数，以下是相关选项说明 --with-debug-level=slowdebug 启用slowdebug级别调试 --enable-dtrace 启用dtrace --with-jvm-variants=server 编译server类型JVM --with-target-bits=64 指定JVM为64位 --enable-ccache 启用ccache，加快编译 --with-num-cores=8 编译使用CPU核心数 --with-memory-size=8000 编译使用内存 --disable-warnings-as-errors 忽略警告 123456789101112131415161718192021222324252627$ bash configure --with-debug-level=slowdebug --enable-dtrace --with-jvm-variants=server --with-target-bits=64 --enable-ccache --with-num-cores=8 --with-memory-size=8000 --disable-warnings-as-errors...====================================================A new configuration has been successfully created in/Users/hunterzhao/CLionProjects/OpenJDK10/build/macosx-x86_64-normal-server-slowdebugusing configure arguments '--with-debug-level=slowdebug --enable-dtrace --with-jvm-variants=server --with-target-bits=64 --enable-ccache --with-num-cores=8 --with-memory-size=8000 --disable-warnings-as-errors'.Configuration summary:* Debug level: slowdebug* HS debug level: debug* JDK variant: normal* JVM variants: server* OpenJDK target: OS: macosx, CPU architecture: x86, address length: 64* Version string: 10-internal+0-adhoc.hunterzhao.OpenJDK10 (10-internal)Tools summary:* Boot JDK: java version "1.8.0_151" Java(TM) SE Runtime Environment (build 1.8.0_151-b12) Java HotSpot(TM) 64-Bit Server VM (build 25.151-b12, mixed mode) (at /Library/Java/JavaVirtualMachines/jdk1.8.0_151.jdk/Contents/Home)* Toolchain: clang (clang/LLVM from Xcode 8.3.3)* C Compiler: Version 8.1.0 (at /usr/bin/clang)* C++ Compiler: Version 8.1.0 (at /usr/bin/clang++)Build performance summary:* Cores to use: 7* Memory limit: 8000 MB* ccache status: Active (3.3.5) 执行编译123456789101112131415161718192021222324$ make images...Creating support/demos/image/jfc/CodePointIM/CodePointIM.jarCreating support/demos/image/applets/MoleculeViewer/MoleculeViewer.jarCreating support/demos/image/applets/WireFrame/WireFrame.jarCreating support/demos/image/jfc/SwingApplet/SwingApplet.jarCreating support/demos/image/jfc/FileChooserDemo/FileChooserDemo.jarCreating support/demos/image/jfc/Font2DTest/Font2DTest.jarCreating support/demos/image/jfc/Metalworks/Metalworks.jarCreating support/demos/image/jfc/Notepad/Notepad.jarCreating support/demos/image/jfc/SampleTree/SampleTree.jarCreating support/demos/image/jfc/TableExample/TableExample.jarCreating support/demos/image/jfc/TransparentRuler/TransparentRuler.jarCreating support/classlist.jarCreating images/jmods/jdk.jlink.jmodCreating images/jmods/java.base.jmodCreating jre jimageCreating jdk jimageWARNING: Using incubator modules: jdk.incubator.httpclientWARNING: Using incubator modules: jdk.incubator.httpclientStopping sjavac serverFinished building target &apos;images&apos; in configuration &apos;macosx-x86_64-normal-server-slowdebug&apos; 大约10分钟后编译完成，由于机器配置不同可能会导致编译时长有所差异。 测试1234$ ./build/macosx-x86_64-normal-server-slowdebug/jdk/bin/java -versionopenjdk version "10-internal"OpenJDK Runtime Environment (slowdebug build 10-internal+0-adhoc.hunterzhao.OpenJDK10)OpenJDK 64-Bit Server VM (slowdebug build 10-internal+0-adhoc.hunterzhao.OpenJDK10, mixed mode) 本篇文章至此结束，下篇介绍搭建OpenJDK10 DEBUG环境。]]></content>
      <categories>
        <category>OpenJDK</category>
      </categories>
      <tags>
        <tag>OpenJDK</tag>
        <tag>JVM</tag>
        <tag>HotSpot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringCloud自定义Feign解码器]]></title>
    <url>%2Fpost%2F2017%2F12%2F02%2Fcustomize-feign-decoder-in-spring-cloud%2F</url>
    <content type="text"><![CDATA[在SpringCloud微服务中，Feign组件帮我们把跨服务HTTP请求模板化，我们的FeignClient看上去可能是下面这样， 返回值都被封装在一个ApiResponse中，调用者获取真正内容时需要再次获取ApiResponse中的data内容，略显恶心。 1234567@FeignClient(value = Const.FeignClient.USER_CENTER, path = "user")public interface UserCloudService &#123; @PostMapping("save") ApiResponse&lt;User&gt; saveUser(@RequestBody UserVo userVo);&#125; 使用其Decoder让我们更方便地自定义FeignClient中的方法返回值， 1234567891011@Beanpublic Decoder decoder() &#123; return (response, type) -&gt; &#123; String body = Util.toString(response.body().asReader()); ObjectMapper mapper = new ObjectMapper(); JavaType javaType = mapper.getTypeFactory() .constructParametricType(ApiResponse.class, mapper.getTypeFactory().constructType(type)); ApiResponse&lt;?&gt; apiResponse = mapper.readValue(body, javaType); return apiResponse.getData(); &#125;;&#125; 所以以上FeignClient就会变成如下，跟普通Service无异，平滑过渡。1234567@FeignClient(value = Const.FeignClient.USER_CENTER, path = "user")public interface UserCloudService &#123; @PostMapping("save") User saveUser(@RequestBody UserVo userVo);&#125;]]></content>
      <categories>
        <category>Spring Cloud</category>
      </categories>
      <tags>
        <tag>Spring Cloud</tag>
        <tag>Spring Boot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringCloud设置zuul网关跨域访问]]></title>
    <url>%2Fpost%2F2017%2F11%2F22%2Fcors-filter-settings-in-zuul-of-spring-cloud%2F</url>
    <content type="text"><![CDATA[SpringCloud设置跨域访问只需在zuul网关服务中加入如下configuration即可。 123456789101112131415161718192021/** * CORS配置 * @return */@Beanpublic CorsFilter corsFilter() &#123; UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource(); CorsConfiguration config = new CorsConfiguration(); config.setAllowCredentials(true); config.addAllowedOrigin("*"); config.addAllowedHeader("*"); config.addAllowedMethod("OPTIONS"); config.addAllowedMethod("HEAD"); config.addAllowedMethod("GET"); config.addAllowedMethod("PUT"); config.addAllowedMethod("POST"); config.addAllowedMethod("DELETE"); config.addAllowedMethod("PATCH"); source.registerCorsConfiguration("/**", config); return new CorsFilter(source);&#125;]]></content>
      <categories>
        <category>Spring Cloud</category>
      </categories>
      <tags>
        <tag>Spring Cloud</tag>
        <tag>Spring Boot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringCloud集成Redis哨兵]]></title>
    <url>%2Fpost%2F2017%2F11%2F20%2Fusing-redis-in-spring-cloud%2F</url>
    <content type="text"><![CDATA[在SpringCloud中我们可以很容易地集成并使用Redis缓存，在pom.xml中加入依赖，pom.xml1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;&lt;/dependency&gt; 在application.yml中加入如下内容：123456789101112spring: profiles: active: default redis: sentinel: master: $&#123;spring.redis.sentinel.master&#125; nodes: $&#123;spring.redis.sentinel.nodes&#125; pool: max-idle: $&#123;spring.redis.pool.max-idle&#125; min-idle: $&#123;spring.redis.pool.min-idle&#125; max-active: $&#123;spring.redis.pool.max-active&#125; max-wait: $&#123;spring.redis.pool.max-wait&#125; 在Configuration中加入RedisTemplate，然后在代码中注入RedisTemplate即可使用。1234567891011@Beanpublic RedisTemplate&lt;String, Object&gt; redisTemplate(RedisConnectionFactory factory) &#123; RedisTemplate&lt;String, Object&gt; redisTemplate = new RedisTemplate&lt;&gt;(); redisTemplate.setKeySerializer(new StringRedisSerializer()); redisTemplate.setHashKeySerializer(new StringRedisSerializer()); redisTemplate.setHashValueSerializer(new StringRedisSerializer()); redisTemplate.setValueSerializer(new GenericToStringSerializer&lt;&gt;(String.class)); redisTemplate.setConnectionFactory(factory); return redisTemplate;&#125;]]></content>
      <categories>
        <category>Spring Cloud</category>
      </categories>
      <tags>
        <tag>Spring Cloud</tag>
        <tag>Spring Boot</tag>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringCloud设置HttpMessageConverter为fastjson格式化输出]]></title>
    <url>%2Fpost%2F2017%2F11%2F16%2Fset-http-message-converter-as-fastjson-in-spring-cloud%2F</url>
    <content type="text"><![CDATA[我们的API响应的Media类型一般是application/json;charset=UTF-8，在SpringCloud中可以通过如下方式设置， 并且将HttpMessageConverter设置为fastjson，使用fastjson提供的各种功能格式化输出内容。 12345678910111213141516171819202122@Beanpublic HttpMessageConverters fastjsonHttpMessageConverter() &#123; StringHttpMessageConverter converter = new StringHttpMessageConverter(StandardCharsets.UTF_8); FastJsonHttpMessageConverter fastConverter = new FastJsonHttpMessageConverter(); // 配置Media类型 List&lt;MediaType&gt; supportedMediaTypes = new ArrayList&lt;&gt;(); supportedMediaTypes.add(MediaType.TEXT_HTML); supportedMediaTypes.add(MediaType.APPLICATION_JSON_UTF8); fastConverter.setSupportedMediaTypes(supportedMediaTypes); // fastjson配置 FastJsonConfig fastJsonConfig = new FastJsonConfig(); fastJsonConfig.setSerializerFeatures(SerializerFeature.PrettyFormat); fastJsonConfig.setSerializerFeatures(SerializerFeature.DisableCircularReferenceDetect); fastJsonConfig.setSerializerFeatures(SerializerFeature.WriteMapNullValue); fastJsonConfig.setSerializerFeatures(SerializerFeature.WriteNullStringAsEmpty); fastConverter.setFastJsonConfig(fastJsonConfig); return new HttpMessageConverters(converter, fastConverter);&#125;]]></content>
      <categories>
        <category>Spring Cloud</category>
      </categories>
      <tags>
        <tag>Spring Cloud</tag>
        <tag>Spring Boot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringCloud配置中心多级目录多文件匹配搜索]]></title>
    <url>%2Fpost%2F2017%2F11%2F14%2Fmultiple-files-and-directories-search-in-config-center-of-spring-cloud%2F</url>
    <content type="text"><![CDATA[SpringCloud将所有配置通过文件或Git模式集中化，微服务在启动时通过注册中心找到配置中心并拉取对应配置文件，让微服务动态更新配置成为可能。很多情况下，不同功能角色的配置文件分散在不同的配置文件中，比如redis和rabbitmq，多文件匹配SpringCloud也是支持的，如下： 配置中心 application.yml：12345678910111213141516spring: application: name: config-center cloud: bus: trace: enabled: true config: server: git: uri: $&#123;GIT_URL:https://git.xyz.com/cloud-config-repo.git&#125; username: $&#123;GIT_USERNAME:someuser&#125; password: $&#123;GIT_PASSWORD:somepass&#125; clone-on-start: $&#123;CLONE_ON_START:true&#125; # 搜索配置仓库多级目录 search-paths: services/**,platform/** 微服务bootstrap.yml:1234567891011121314spring: application: name: base-service profiles: active: default cloud: config: # 匹配配置中心多个配置文件 name: common,datasource,redis,rabbitmq,$&#123;spring.application.name&#125;,$&#123;spring.application.name&#125;-application profile: $&#123;spring.profiles.active&#125; label: $&#123;COFNIG_BRANCH:master&#125; discovery: enabled: true service-id: config-center 通过命令行spring.profiles.active参数指定目标运行环境（dev、test、prod），比如运行在test环境，微服务启动时会去配置中心匹配如下文件： common-test.properties datasource-test.properties redis-test.properties rabbitmq-test properties base-service-test.properties base-service-application.yml]]></content>
      <categories>
        <category>Spring Cloud</category>
      </categories>
      <tags>
        <tag>Spring Cloud</tag>
        <tag>Spring Boot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringCloud中读取命令行参数或系统环境变量]]></title>
    <url>%2Fpost%2F2017%2F11%2F10%2Fuse-environment-variable-or-command-line-parameter-in-spring-cloud%2F</url>
    <content type="text"><![CDATA[SpringCloud中帮我们很方便地提供了环境适配方案，通过命令行参数或export系统环境变量指定REGISTRY_CENTER_URI值， 如果读取到，SpringCloud优先使用该值，如果该变量未指定则使用默认值http://localhost:9000/eureka/ 123456eureka: instance: prefer-ip-address: true client: serviceUrl: defaultZone: $&#123;REGISTRY_CENTER_URI:http://localhost:9000/eureka/&#125;]]></content>
      <categories>
        <category>Spring Cloud</category>
      </categories>
      <tags>
        <tag>Spring Cloud</tag>
        <tag>Spring Boot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[通过Nginx内嵌Lua脚本实现资源访问权限控制]]></title>
    <url>%2Fpost%2F2017%2F10%2F15%2Fresource-access-control-via-lua-script-in-nginx%2F</url>
    <content type="text"><![CDATA[有些敏感的静态资源（比如身份证照片，企业执照等）是不能裸奔在互联网上的，被爬虫抓取后果比较严重，所以要加入一定的访问权限，满足某种规则后才可以访问。 最常用的做法是访问者发起请求时首先对资源名使用私钥进行MD5作为signature，再将signature作为参数传入，服务端接到请求后按照同样规则进行验签，signature匹配则视为合法请求，否则deny返回403。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364---- Author: Hunter Zhao-- Mail: zhaohevip@gmail.com-- Date: 13/10/2017-- Time: 10:25-- Description：敏感资源访问签名认证---- =============================================-- the secret keySECRET_KEY = "iamasecretkey"--[[ 获取资源名 e.g. 访问路径 /image/some_pic_name.jpg 返回 -&gt; some_pic_name.jpg]]function getResourceName() local url = ngx.var.uri local len = string.len(url) local _url = string.reverse(url) local pos = string.find(_url, "/") -- start position index local start_pos = len - pos + 1 -- get substring from the index local img_name = string.sub(url, start_pos + 1, len) return img_nameend--[[ 验证签名合法性]]function validateSignature() local sign = ngx.var.arg_sign -- exit if signature is blank if sign == nil or sign == "" then ngx.exit(401) return false end -- get request resource name local img_name = getResourceName() -- sign the specified string via MD5 algorithm local token = ngx.md5(img_name..SECRET_KEY) -- if signature doesn't equal the token if sign ~= token then ngx.exit(403) return false end -- if everything is OK return trueend-- =============================================-- return the result of access interceptorreturn validateSignature() Nginx配置12345678910server &#123; listen 80 default; server_name localhost; root /path/to/root; location /image/ &#123; default_type 'text/html'; access_by_lua_file "/path/to/resource_access_control.lua"; #通过lua来控制访问权限 &#125;&#125;]]></content>
      <categories>
        <category>Lua</category>
      </categories>
      <tags>
        <tag>Nginx</tag>
        <tag>Lua</tag>
        <tag>权限</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一行Python命令开启简单的静态文件服务器]]></title>
    <url>%2Fpost%2F2017%2F08%2F30%2Fstart-up-a-file-server-using-one-python-command%2F</url>
    <content type="text"><![CDATA[在开发过程当中，常常会需要启动一个静态文件服务器用来访问静态资源或传输文件，安装Nginx？安装Tomcat？ No！都太重了。只需要执行一个Python命令即可马上拥有一个轻量级静态服务器。 如果你使用的是Python2.x12$ python -m SimpleHTTPServerServing HTTP on 0.0.0.0 port 8000 ... 如果你使用的是Python3.x1$ python -m http.server 打开浏览器即可访问http://localhost:8000，也可在后面追加指定目标端口，如：python -m SimpleHTTPServer 9000]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于MyBatis通用代码生成器CoffeeMaker的设计思路]]></title>
    <url>%2Fpost%2F2017%2F07%2F21%2Fdesign-of-universal-code-generator-coffee-maker%2F</url>
    <content type="text"><![CDATA[CoffeeMaker是一款经过良好设计的代码生成器，可快速生成通用CRUD代码模板，使用方便且易于扩展。于2017年7月开发完成，源代码托管于GitHub仓库。 引言在整个软件开发过程中有一大部分内容是相当有共性的，比如模型对象、配置文件、基本CRUD操作方法等等， 程序员是用来思考问题的，不是用来执行重复任务的，所以那些重复性的工作交给机器或工具去做就好了。 而开源社区里不乏一些代码生成器，但生成代码的格式、风格往往并不符合团队开发规范，去修改的话还得先去去读懂别人代码，为何不写一个出来沉淀为自己团队的产物呢。 设计 通过JDBC读取DB元数据封装成数据对象。 使用DefinitionConverter转换成模型文件定义对象。 将模型文件对象封装成所需文件封装器FileWrapper。 使用FileParser将FileWrapper渲染至对应的模板文件。 输出最终目标文件。 流程1234567891011121314151617181920212223242526272829303132333435 &lt; Workflow diagram of CoffeeMaker &gt; +----------+ JDBC +---------------------+ TableMetadata +------------------------+| | ------&gt; | | ----------------&gt; | DefinitionConverter || Database | | MetadataProvider | +------------------------+| | | | || | | | | FileDefinition+----------+ +---------------------+ v +- - - - - - - - - - - - - - + &apos; Various of file wrappers &apos; &apos; &apos; &apos; +------------------------+ &apos; &apos; | FileWrapper | &apos; &apos; +------------------------+ &apos; &apos; &apos; +- - - - - - - - - - - - - - + | | | +- - - - - - - - - - - - -+ | &apos; OUTPUT: &apos; | &apos; &apos; | &apos; XxxEntity.java &apos; | &apos; XxxMapper.xml &apos; | &apos; XxxDao.java &apos; | &apos; XxxService.java &apos; | &apos; XxxServiceImpl.java &apos; | &apos; XxxController.java &apos; | &apos; XxxVo.java &apos; | &apos; &apos; v &apos; +---------------------+ &apos; Parse &amp; export +------------------------+ &apos; | Ultimate Code Files | &apos; &lt;---------------- | | &apos; +---------------------+ &apos; | FileParser | &apos; &apos; | | +- - - - - - - - - - - - -+ +------------------------+ 配置 配置数据源文件src/main/resource/config.properties 配置代码生成规则 1234567Configuration configuration = new Configuration(); configuration.setTableName("t_user") .setTablePrefix("") .setPackageName("com.workholiday") .setPagerPackageName("com.workholiday.base.core.page") .setWithPager(true) .setOutputPath("/Users/hunterzhao/tmp/output"); 执行通过CoffeeMakerLauncher类的main方法执行代码生成器 输出生成的代码模板如下： Entity文件 DAO文件 MyBatis mapper文件 Service文件 Service实现类 VO文件 Controller文件 扩展如果需要定制化CoffeeMaker，可以通过修改（新增）FileWrapper和FileTemplate来轻松实现。]]></content>
      <categories>
        <category>MyBatis</category>
      </categories>
      <tags>
        <tag>MyBatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于IntelliJ IDEA插件Open Terminal Here的设计思路]]></title>
    <url>%2Fpost%2F2015%2F12%2F03%2Fdesign-of-intellij-plugin-open-terminal-here%2F</url>
    <content type="text"><![CDATA[Open Terminal Here是一款用于在终端中直接打开文件所在目录的IntelliJ插件，于2015年12月3日发布至IntelliJ IDEA官方插件库，目前有3K+次下载，源代码托管于GitHub。 痛点场景一直使用IntelliJ IDEA作为IDE，深爱它的智能，正如其名。然而，再完美的东西也有不完美的地方。 作为命令行重度用户自然免不了在命令行进行操作，这种情况下就不得不逐级cd到某个工程文件所在目录，如果目录层级特别深，那酸爽不可思议。 那么，问题来了，如何从命令行中一步切换到文件所在目录？答案就是：给IntelliJ写插件。 实现思路IntelliJ IDEA开放了一套完整的OpenAPI，通过该OpenAPI几乎可以完成对IDEA各个组件的操作及扩展，非常方便。 思路大致为： 首先通过OpenAPI获取工程文件的VirtualFile对象，VirtualFile是对文件系统的封装，包含了工程文件几乎所有信息，包括所在系统目录。 将文件系统目录封装成对应OS的自定义Command对象 通过Runtime.getRuntime().exec(command)调用系统命令行并切换至目标目录 代码实现通过OpenAPI获取工程文件所在目录12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849/** * Author: Hunter Zhao * Date: 12/2/15 18:31 * Description: tool for file operation */public class FileUtil &#123; /** * determine the VirtualFile which selected in Project view * @param project * @return */ public static VirtualFile getSelectedProjectFile(@NotNull Project project) &#123; AbstractProjectViewPane currentProjectViewPane = ProjectView.getInstance(project).getCurrentProjectViewPane(); if (currentProjectViewPane == null) &#123; return null; &#125; DefaultMutableTreeNode node = currentProjectViewPane.getSelectedNode(); if (node == null) &#123; return null; &#125; Object selected = null; Object userObject = node.getUserObject(); if (userObject instanceof AbstractTreeNode) &#123; selected = ((AbstractTreeNode)userObject).getValue(); &#125; else if (userObject instanceof NodeDescriptor) &#123; selected = ((NodeDescriptor)userObject).getElement(); &#125; if (selected == null) &#123; return null; &#125; VirtualFile vf = null; if (selected instanceof PsiDirectory) &#123; vf = ((PsiDirectory)selected).getVirtualFile(); &#125; else if (selected instanceof PsiElement) &#123; vf = ((PsiElement) selected).getContainingFile().getVirtualFile().getParent(); &#125; else &#123; // ignored &#125; return vf; &#125;&#125; 封装成Command对象 Command对象 1234567891011121314151617181920public class Command &#123; private String[] cmdArray; private String[] envp; private File dir; public Command(String[] cmdArray) &#123; this.cmdArray = cmdArray; &#125; public Command(String[] cmdArray, String[] envp, File dir) &#123; this.cmdArray = cmdArray; this.envp = envp; this.dir = dir; &#125; ... 省略setters &amp; getters&#125; Win平台命令执行器 123456789101112131415161718192021222324252627/** * Author: Hunter Zhao * Date: 12/2/15 18:43 * Description: command executor for Windows Platform */public class WinExecutor extends CommandExecutor &#123;private static final String WIN_CMD = "C:\\Windows\\System32\\cmd.exe"; public WinExecutor(String targetPath) &#123; super.targetPath = targetPath; &#125; @Override public String getTerminalPath() &#123; return WIN_CMD; &#125; @Override public Command buildCommand() &#123; String terminalPath = this.getTerminalPath(); String[] cmdArr = &#123;terminalPath, "/k", "start", "cd", getTargetPath()&#125;; return new Command(cmdArr, null, new File(getTargetPath())); &#125;&#125; Mac平台命令执行器 123456789101112131415161718192021222324252627282930313233343536/** * Author: Hunter Zhao * Date: 12/2/15 18:42 * Description: command executor for Mac Platform */public class MacExecutor extends CommandExecutor &#123; private static final String MAC_TERMINAL = "/Applications/Utilities/Terminal.app/Contents/MacOS/Terminal"; private static final String ITERM = "/Applications/iTerm.app/Contents/MacOS/iTerm"; private static final String ITERM2 = "/Applications/iTerm.app/Contents/MacOS/iTerm2"; public MacExecutor(String targetPath) &#123; setTargetPath(targetPath); &#125; @Override public String getTerminalPath() &#123; if (isTerminalInstalled(ITERM)) &#123; return ITERM; &#125; else if (isTerminalInstalled(ITERM2)) &#123; return ITERM2; &#125; return MAC_TERMINAL; &#125; @Override Command buildCommand() &#123; String terminalPath = this.getTerminalPath(); String[] cmdArr = &#123;terminalPath, getTargetPath()&#125;; return new Command(cmdArr); &#125;&#125; 调用系统命令行并切换至目标目录123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354/** * Author: Hunter Zhao * Date: 12/2/15 18:41 * Description: command execution template */public abstract class CommandExecutor &#123; /** * determine which terminal to be used * @return */ abstract String getTerminalPath(); /** * build the Command object * @return */ abstract Command buildCommand(); /** path to open */ protected String targetPath; /** * determine if the specified terminal has been installed * @param terminalPath * @return */ protected boolean isTerminalInstalled(String terminalPath) &#123; File terminal = new File(terminalPath); return terminal.exists() &amp;&amp; terminal.canExecute(); &#125; /** * open the target path in terminal */ public void openTerminal() &#123; Command cmd = this.buildCommand(); try &#123; Runtime.getRuntime().exec(cmd.getCmdArray(), cmd.getEnvp(), cmd.getDir()); &#125; catch (IOException e) &#123; // ignored &#125; &#125;; public String getTargetPath() &#123; return targetPath; &#125; public void setTargetPath(String targetPath) &#123; this.targetPath = targetPath; &#125;&#125; 开放插件入口1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950/** * Author: Hunter Zhao * Date: 12/2/15 18:31 * Description: An IntelliJ plugin for opening current directory in terminal */public class OpenTerminalHereAction extends AnAction &#123; public static final String PLUGIN_NAME = "OpenTerminalHere"; @Override public void actionPerformed(AnActionEvent event) &#123; Project project = event.getProject(); if (project == null) &#123; return; &#125; perform(project); &#125; /** * perform the action * @param project */ private void perform(@NotNull Project project) &#123; VirtualFile selectedFile = FileUtil.getSelectedProjectFile(project); if (selectedFile == null) &#123; return; &#125; String targetPath = selectedFile.getPath(); CommandExecutor executor = null; if (SystemInfo.isMac) &#123; executor = new MacExecutor(targetPath); &#125; else if (SystemInfo.isWindows) &#123; executor = new WinExecutor(targetPath); &#125; if (executor == null) &#123; NotificationTool.notify(project, PLUGIN_NAME, "Your operating system is not supported temporarily.", NotificationType.ERROR); return; &#125; executor.openTerminal(); &#125;&#125; 编辑plugin.xml配置12345678910&lt;actions&gt; &lt;!-- 插件基本信息 --&gt; &lt;action id="com.bobz.action.OpenTerminalHereAction" class="com.bobz.action.OpenTerminalHereAction" text="Open Terminal Here" description="Open Terminal Here"&gt; &lt;!-- 添加至目标分组 --&gt; &lt;add-to-group group-id="ProjectViewPopupMenu" anchor="after" relative-to-action="RevealIn"/&gt; &lt;!-- 快捷键设置 --&gt; &lt;keyboard-shortcut keymap="$default" first-keystroke="ctrl alt T"/&gt; &lt;/action&gt;&lt;/actions&gt; 参考引用 IntelliJ Platform SDK]]></content>
      <categories>
        <category>IntelliJ IDEA</category>
      </categories>
      <tags>
        <tag>IntelliJ IDEA</tag>
        <tag>插件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CentOS通过yum安装配置MySQL]]></title>
    <url>%2Fpost%2F2014%2F01%2F20%2Finstall-and-configure-mysql-on-centos%2F</url>
    <content type="text"><![CDATA[安装MySQL1[root@HunterWorkStation local]# yum -y install mysql mysql-server 启动MySQL服务1234567891011121314151617181920212223242526272829303132[root@HunterWorkStation local]# service mysqld startInitializing MySQL database: Installing MySQL system tables... OKFilling help tables... OKTo start mysqld at boot time you have to copysupport-files/mysql.server to the right place for your systemPLEASE REMEMBER TO SET A PASSWORD FOR THE MySQL root USER !To do so, start the server, then issue the following commands:/usr/bin/mysqladmin -u root password 'new-password'/usr/bin/mysqladmin -u root -h localhost.localdomain password 'new-password'Alternatively you can run:/usr/bin/mysql_secure_installationwhich will also give you the option of removing the testdatabases and anonymous user created by default. This isstrongly recommended for production servers.See the manual for more instructions.You can start the MySQL daemon with:cd /usr ; /usr/bin/mysqld_safe &amp;You can test the MySQL daemon with mysql-test-run.plcd /usr/mysql-test ; perl mysql-test-run.plPlease report any problems with the /usr/bin/mysqlbug script!Starting mysqld: [ OK ] 设置root用户密码1[root@HunterWorkStation local]# mysqladmin -u root password 'YOUR PASSWORD HERE' 登陆数据库并授权此时用户是无法远程登陆该数据库的，接下来为用户授权1234567891011121314151617[root@HunterWorkStation local]# mysql -u root -pEnter password: Welcome to the MySQL monitor. Commands end with ; or \g.Your MySQL connection id is 4Server version: 5.1.71 Source distributionCopyright (c) 2000, 2013, Oracle and/or its affiliates. All rights reserved.Oracle is a registered trademark of Oracle Corporation and/or itsaffiliates. Other names may be trademarks of their respectiveowners.Type 'help;' or '\h' for help. Type '\c' to clear the current input statement.mysql&gt; grant all on *.* to root@'%' identified by '123456'; # 为所有主机授权使用root用户操作所有库和表，密码123456Query OK, 0 rows affected (0.00 sec) 设置MySQL服务开机自启动1[root@HunterWorkStation local]# chkconfig mysqld on 设置后查看是否设置成功123[root@HunterWorkStation local]# chkconfig --list | grep mysqldmysqld 0:off 1:off 2:on 3:on 4:on 5:on 6:off # 2-5为on则表示自启动 设置服务端编码123456789[root@HunterWorkStation local]# vim /etc/my.cnf[mysqld]datadir=/var/lib/mysqlsocket=/var/lib/mysql/mysql.sockuser=mysqldefault-character-set=utf8# Disabling symbolic-links is recommended to prevent assorted security riskssymbolic-links=0 重启MySQL服务123[root@HunterWorkStation local]# service mysqld restartStopping mysqld: [ OK ]Starting mysqld: [ OK ] 至此，安装配置完毕，接来下可以用客户端连接操作MySQL。]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>CentOS</tag>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac下vim开启语法高亮&着色]]></title>
    <url>%2Fpost%2F2014%2F01%2F20%2Fconfigure-vim-syntax-highlight-on-mac%2F</url>
    <content type="text"><![CDATA[Mac OS并不像大多数Linux发行版vim默认自带语法着色高亮显示（通常Linux可通过编辑/etc/vimrc进行全局设置或~/vimrc进行单用户设置），使用vi/vim编辑文件时很不方便，如何解决 ? 编辑文件/usr/share/vim/vimrc1234567891011121314BobZhao@mac:~ &gt; sudo vim /usr/share/vim/vimrcPassword:" Configuration file for vimset modelines=0 " CVE-2007-2438" Normally we use vim-extensions. If you want true vi-compatibility" remove change the following statementsset nocompatible " Use Vim defaults instead of 100% vi compatibilityset backspace=2 " more powerful backspacing" Don't write backup file if vim is being called by "crontab -e"au BufWrite /private/tmp/crontab.* set nowritebackup" Don't write backup file if vim is being called by "chpass"au BufWrite /private/etc/pw.* set nowritebackup 在set backspace=2下插入配置1234567891011121314set ai " auto indentingset history=100 " keep 100 lines of historyset ruler " show the cursor positionsyntax on " syntax highlightingset hlsearch " highlight the last searched termfiletype plugin on " use the file type plugins" When editing a file, always jump to the last cursor positionautocmd BufReadPost *\ if ! exists("g:leave_my_cursor_position_alone") |\ if line("'\"") &gt; 0 &amp;&amp; line ("'\"") &lt;= line("$") |\ exe "normal g'\"" |\ endif |\ endif 验证再次打开该文件发现已经生效]]></content>
      <categories>
        <category>Mac</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>vim</tag>
        <tag>Mac</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2Fpost%2F2011%2F01%2F10%2Fhello-world%2F</url>
    <content type="text"><![CDATA[原博客从2007年7月24日注册已经有10+个年头了，估计也算是中国第一批博客用户了，也见证了网易博客从最初到后来发展成熟的过程。 记得当年比较流行装扮博客，网易官方推出了各式各样的皮肤，并且允许用户博客自定义和分享，后来推出首页自定义模块，具体方式是通过特定的代码来加入更丰富的功能，也就是那时候最初接触到了HTML/CSS。 装扮玩博客后还有更重要的一项就是：推广。当时为了提高博客访问量增加影响力也着实费了一番功夫，通过各种方式各种渠道宣传、互换人气，当时比较有名的是博客群(http://www.bokequn.cn) 博搜(http://www.boosou.com)和博无忧（http://www.bo56.com）。 2009年的时候，网易博客推出了圈子功能，类似QQ群，博友可以把自己的博文、相册推荐到圈子里，圈子里同时有论坛功能，于是大家开始各种灌水，我的圈子从2009年1月份开通，到后来网易博客没落共有3万7千多圈友，在当时也是个比较大的社群了。同年，网易博客每隔段时间就发系统公告，说要对系统存储空间进行扩容，后来技术团队应该是攻克了存储扩容问题，于是便再也没有发过类似公告。 从2011年工作后开始更新技术文章，有时候写博客需要贴代码，但网易博客没有这个功能，所以通过意见反馈渠道反馈了这一情况，意外的是居然收到了网易的产品经理的回复，并且网易博客很快加入了该功能，虽然不太好用，但还是很感谢。 2013年网易博客向部分博主推出了广告服务内测，很荣幸被选入其中，由于访问量还不错，前后一年内共入账了1K左右，算是人生中第一桶金。不过随着业务发展，网易公司决定对推广资源进行合理调整，于2014年4月1日下线网易博客有道推广广告位。 … 十一年，零零散散记载了很多篇，随着工作的忙碌近几年更新频率与日俱减。工作年头越来越多，反而慢慢有了重新执笔的冲动，突然想写点什么。 今年（2017）建立了自己的GitHub Pages并注册了自己的域名，经过一番折腾后，决定把原博客的部分文章迁移过来，一方面用于纪念曾经的青葱岁月，另一方面同时鼓励自己笔耕不辍，把自己这些年以来的所见所闻、所感所悟以文字的方式记录下来，如果恰巧你也有类似的经历或共鸣，那也算是人生中一大幸事了。]]></content>
      <categories>
        <category>默认分类</category>
      </categories>
  </entry>
</search>
